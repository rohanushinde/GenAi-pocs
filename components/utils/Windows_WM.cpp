#include "stdafx.h"

#ifndef WM_H
#include "WM.h"
#endif

#ifndef	WMLIBRARY_H
#include "WMLibrary.h"
#endif

#ifndef MAINFRM_H
#include "MainFrm.h"
#endif

#ifndef SIGNALDOC_H
#include "SignalDoc.h"
#endif

#ifndef SIGNALVIEW_H
#include "SignalView.h"
#endif

#ifndef HOLTERVIEW_H
#include "HolterView.h"
#endif

#ifndef MONITORVIEW_H
#include "MonitorView.h"
#endif

#ifndef RFVIEW_H
#include "RFView.h"
#endif

#ifndef	DBVIEW_H
#include "DBView.h"
#endif

#ifndef CINEDOC_H
#include "CineDoc.h"
#endif

#ifndef CINEVIEW_H
#include "CineView.h"
#endif

#ifndef	MEASSAVEDIALOG_H
#include "MeasSaveDialog.h"
#endif

#ifndef LOGDOC_H
#include "LOGDoc.h"
#endif

#ifndef LOGVIEW_H
#include "LogView.h"
#endif

#ifndef	WMPOPUPWINDOW_H
#include "WMPopupWindow.h"
#endif

#ifndef	SIGNALCHILDFRAME_H
#include "SignalChildFrame.h"
#endif

#include "../Shared/Amplifier/IAmplifier.h"

#ifndef WMSPLASHSCREEN
#include "WMSplashScreen.h" 
#endif 

#ifndef	LOGCHILDFRAME_H
#include "LogChildFrame.h"
#endif

#ifndef	HOLTERCHILDFRAME_H
#include "HolterChildFrame.h"
#endif

#ifndef	MONITORCHILDFRAME_H
#include "MonitorChildFrame.h"
#endif

#ifndef	CINECHILDFRAME_H
#include "CineChildFrame.h"
#endif

#ifndef	RFCHILDFRAME_H
#include "RFChildFrame.h"
#endif

#ifndef	ABOUT_H
#include "About.h"
#endif

#ifndef SIGNALDOC_H
#include "SignalDoc.h"
#endif

#ifndef	REVIEWVIEW_H
#include "ReviewView.h"
#endif

#ifndef	PREVREVIEWVIEW_H
#include "PrevReviewView.h"
#endif

#ifndef SIGNALDOC_H
#include "SignalDoc.h"
#endif

#ifndef	EDITDIALOG_H
#include "EditDialog.h"
#endif

#ifndef	WMPOPUPDIALOG_H
#include "WMPopupDialog.h"
#endif

#ifndef	DATETIMEPICKDIALOG_H
#include "DateTimePickDialog.h"
#endif


#ifndef WMSPLASHSCREEN
#include "WMSplashScreen.h" 
#endif 

#ifndef	MONITORTHREAD_H
#include "MonitorThread.h"
#endif

#ifndef	MONITORDIALOGBAR_H
#include "MonitorDialogBar.h"
#endif

#ifndef	REALTIMEDIALOGBAR_H
#include "RealTimeDialogBar.h"
#endif

#ifndef MESSAGE_H
#include "Message.h"
#endif

#ifndef DATETIME_H
#include "Datetime.h"
#endif

#ifndef FILESTREAM_H
#include "filestrm.h"
#endif

#ifndef	SIGNALDIALOGBAR_H
#include "SignalDialogBar.h"
#endif

#ifndef	MYPREVIEWVIEW_H
#include "WMPrintPreview.h"
#endif

#ifndef	PRINTCHILDFRAME_H
#include "PrintChildFrame.h"
#endif

#ifndef	REALTIMECHILDFRAME_H
#include "RealTimeChildFrame.h"
#endif

#ifndef	SHELL_H
#include "Shell.h"
#endif

#ifndef	PRETABDIALOG_H
#include "PreTabDialog.h"
#endif

#ifndef	DATEDIALOG_H
#include "DateDialog.h"
#endif

#ifndef	STOPWATCHDIALOG_H
#include "StopWatchDialog.h"
#endif

#ifndef	QUERYDIALOG_H
#include "QueryDialog.h"
#endif

#ifndef	VIEWDATADIALOG_H
#include "ViewDataDialog.h"
#endif

#ifndef	RFSUMMARYDIALOG_H
#include "RFSummaryDialog.h"
#endif

#ifndef	CATHMAPVIEW_H
#include "CathmapView.h"
#endif

#ifndef	CATHMAPFRAME_H
#include "CATHMAPFrame.h"
#endif

#ifndef	DBFRAME_H
#include "DBFrame.h"
#endif

#include<winspool.h>

#ifndef	HOLTERDIALOGBAR_H
#include "HolterDialogBar.h"
#endif

#ifndef	MONITORCHANGEDIALOG_H
#include "MonitorChangeDialog.h"
#endif

#ifndef	REVIEWCHANGEDIALOG_H
#include "ReviewChangeDialog.h"
#endif

#ifndef	CONFIGSCREEN_H
#include "ConfigScreen.h"
#endif

#ifndef	AMPDIALOGBAR_H
#include "AMPDialogBar.h"
#endif

#ifndef	MAPPINGCHILDFRAME_H
#include "MappingChildFrame.h"
#endif

#include "EnsiteMappingDoc.h"

#ifndef	ATMMAPVIEW_H
#include "ATMMapView.h"
#endif

#ifndef	ATMMAPDIALOGBAR_H
#include "ATMMapDialogBar.h"
#endif

#ifndef	WAITPOPUPDIALOG_H
#include "WaitPopupDialog.h"
#endif

#ifndef	IMAGEWINDOW_H
#include "ImageWindow.h"
#endif

#ifdef OTHER_MAP_TYPES
#include "AFLMapView.h"
#include "SMMMapView.h"
#include "DPMMapView.h"
#endif

#ifndef	MERGEDIALOG_H
#include "MergeDialog.h"
#endif

#ifndef	NMDEFINES_H
#include "NMDefines.h"
#endif

#include "TraceDialog.h"

#ifndef	VMEXCEPTION_H
#include "VMException.h"
#endif

#ifndef PHILIPS_VIEWER

	#ifndef	SYSMAINTDIALOG_H
	#include "SysMaintDialog.h"
	#endif

#ifdef ALLURA_TSM
	#ifndef	ALLURAADAPTER_H
	#include "AlluraAdapter.h"
	#endif
#endif

	#ifndef	ARCHIVEDIALOG_H
	#include "ArchiveDialog.h"
	#endif

#endif

#ifndef	FREQREVIEWVIEW_H
#include "FreqReviewView.h"
#endif

#ifndef	EP4_H
#include "EP4.h"
#endif

#ifndef	DEFINEDLG_H
#include "DefineDlg.h"
#endif

#ifndef CHARTVIEW_H
#include "ChartView.h"
#endif

#ifndef	CHARTCHILDFRAME_H
#include "ChartChildFrame.h"
#endif

#ifndef	CHARTSUPPLIESDIALOG_H
#include "ChartSuppliesDialog.h"
#endif

#ifndef	LOGINDIALOG_H
#include "LoginDialog.h"
#endif

#ifndef	REVIEWCHILDFRAME_H
#include "ReviewChildFrame.h"
#endif

#ifndef CHARTEVENTVIEW_H
#include "ChartEventView.h"
#endif

#ifndef CINEDEFINES_H
#include "CineDefines.h"
#endif

#ifndef	DIRDIALOG_H
#include "DirDialog.h"
#endif

#ifndef	LOGDIALOGBAR_H
#include "LogDialogBar.h"
#endif

#ifndef	CHARTDIALOGBAR_H
#include "ChartDialogBar.h"
#endif

#ifndef	IMAGE_H
#include "Image.h"
#endif

/*
#ifndef	CARTOMAPNOTESCHILDFRAME_H
#include "CartoMapNotesChildFrame.h"
#endif

#ifndef	CARTOMAPNOTESVIEW_H
#include "CartoMapNotesView.h"
#endif
*/
#include "ATMCartoMapDialogBar.h"

#ifndef	MEASUREMENTCHILDFRAME_H
#include "MeasurementChildFrame.h"
#endif

#ifndef	MEASUREMENTVIEW_H
#include "MeasurementView.h"
#endif

#ifndef	PRESTUDYTABDIALOG_H
#include "PreStudyTabDialog.h"
#endif

#ifndef	EJECTMODISK_H
#include "EjectMODisk.h"
#endif

#include "RealTimeChildFrameBar.h"
#include "RealTimeBarView.h"
#include "resource.h"


//#include <winuser.h>
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifndef PHILIPS_VIEWER
#ifdef ALLURA_TSM
extern CAlluraAdapter m_TSM;
#endif
#endif


#include "DirectSoundManager.h"
#include "HL7.h"
#include "MessageBox.h"
#include "LibreOfficeImpress.h"
#include "LibreOfficeWriter.h"
#include "PrintService.h"
#include "MiniDump.h"
#include <wincrypt.h>


enum { WSA_NURSE_MATE_PORT = 5901 };

enum
{
	DB_VIEW_FILE_NOT_FOUND		=	0,
	DB_VIEW_FILE_VERSION_ERROR	=	1,
	DB_VIEW_FILE_CORRUPTED		=	2,
	DB_VIEW_FILE_SUCCESS			=	3
};

CTime		CWMApp::m_ctTime = CDateTime::GetLocalTime();

LONGLONG	CWMApp::m_lStartTime;
INT64		CWMApp::m_iStartMS;

SWMNMVersionConfirm CWMApp::m_sNMVersion = {0};

CRandomGenerator CWMApp::m_RandomGenerator;

SAutoRecordParams	CWMApp::m_arDefaultAutoRecordParams[MAX_AUTO_RECORD_PARAMS] =
{ // pre, post, rate, count
	{4, 4, -1, -1},	// AUTO_RECORD_PARAM_STIM
	{4, 4, 450, 3},	// AUTO_RECORD_PARAM_HIGH_RATE
	{4, 4, 1200, 3},	// AUTO_RECORD_PARAM_LOW_RATE
	{4, 4, -1, -1},	// AUTO_RECORD_PARAM_RF
	{4, 4, 450, 3},	// AUTO_RECORD_PARAM_HIGH_RATE_ATRIAL
	{4, 4, 450, 3}		// AUTO_RECORD_PARAM_HIGH_RATE_VENTRICULAR
};

//Claris-7680
SLogin CWMApp::m_sServiceLogin;
//Removed code related to initialize m_sServiceLogin and is handled in InitServiceLogin().

/////////////////////////////////////////////////////////////////////////////
// The one and only CWMApp object
/////////////////////////////////////////////////////////////////////////////
CWMApp theApp;
/////////////////////////////////////////////////////////////////////////////


// anonymous namespace for free functions private to this source file
namespace
{
    void InitAppDirectory()
    {
        auto& settingAlias = theApp.m_INIfile.m_szMsiDirName;
        _tcsncpy(settingAlias, 
                 CRegistry::Instance()->GetString(_T("CONFIG\\APPLICATION DIRECTORY"), 
                                                  settingAlias), 
                 sizeof(settingAlias));
    }
}

BEGIN_MESSAGE_MAP(CWMApp, CWinApp)
	//{{AFX_MSG_MAP(CWMApp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//Claris-7680
/*-------------------------------------------------------------------------
Function Name    :    InitServiceLogin()
Description      :    Function fetches user details for Service user(EPMED) from database
					  and initializes it in m_sServiceLogin.
-------------------------------------------------------------------------*/
void CWMApp::InitServiceLogin()
{
	//get the record from DB
	theApp.m_dbLogin.FreeRecord();
	ZEROSET(theApp.m_sLogin);
	theApp.m_dbLogin.InitRecord();

	::strncpy((PCHAR)theApp.m_dbLogin.m_pIndex->key1, CT2A(SERVICE_USER_NAME), theApp.m_dbLogin.m_pIndex->key1_length);

	if (theApp.m_dbLogin.GetRecord(GET_FROM_INDEX, LOCK_EDIT, 9999) == DB_OK)
	{
		//Save record from DB file to Variable m_sServiceLogin
		m_sServiceLogin.sHashPassword = theApp.m_sLogin.sHashPassword;
		m_sServiceLogin.uiPrivilege = theApp.m_sLogin.uiPrivilege;
		::strncpy((PCHAR)m_sServiceLogin.szUserName, (PCHAR)theApp.m_sLogin.szUserName, ARRAY_SIZE(m_sServiceLogin.szUserName));
		::strncpy((PCHAR)m_sServiceLogin.szInitial, (PCHAR)theApp.m_sLogin.szInitial, ARRAY_SIZE(m_sServiceLogin.szInitial));
	}
	else
	{
		//Record for Service user not found, show error message.
		CString csErr = _T("");
		csErr.Format(GETMESSAGE(11), SERVICE_USER_NAME);
		CMessage::PopupMessage(WMFILELINE, csErr);
	}
}

CWMApp::CWMApp(void)
    : m_thePrintService(CPrintService::Instance())
{
#ifndef PHILIPS_VIEWER
	SetStimActive(false);
#endif
	
	m_bDisableAutoRec = false;

	memset(m_pdfReaderPath, 0, sizeof(m_pdfReaderPath));
	m_hEastWest				=	NULL;
	m_hNorthSouth			=	NULL;
	m_hSouthEast			=	NULL;
	m_hSouthWest			=	NULL;
	m_hPruckaHorz			=	NULL;
	m_fMain					=	NULL;
	m_dReview.m_rppReview.eType	=	eReview;
	m_vReview				=	NULL;
	m_dPrevReview.m_rppReview.eType=	ePrevReview;
	m_vPrevReview			=	NULL;
	m_vFreqReview			=	NULL;
	m_dFreqReview.m_rppReview.eType=	eFreqReview;
	m_vHolter				=	NULL;
	m_vRF						=	NULL;
	m_vCine					=	NULL;
	m_vLog					=	NULL;
	m_hMutex					=	NULL;
	m_bCathMapScrnActive=	false;
	m_bReportWindowActive=	false;
	m_fReview				=	NULL;
	m_fPrevReview			=	NULL;
	m_fHolter				=	NULL;
	m_fMonitor				=	NULL;
	m_fRealTime				=	NULL;
	m_fRealTimeBar			=	NULL;
	m_vRealTimeBar			=	NULL;
	m_fRF						=	NULL;
	m_fCine					=	NULL;
	m_fLog					=	NULL;
	m_fChart					=	NULL;
	m_vChart					=	NULL;
	m_vChartEvent			=	NULL;
	m_fDB						=	NULL;
	m_vDB						=	NULL;
	m_fMapping				=	NULL;
	m_vATMMap				=	NULL;
	m_fMeasurement			=	NULL;
	m_vMeasurement			=	NULL;

	m_iTotalScreenWidth	=	0;
	m_eCursor				=	eDefaultCursor;
	m_hDefaultCursor		=	NULL;
	m_hNullCursor			=	NULL;
	m_hHandCursor			=	NULL;
	m_szImportProcName	=	_T("PROC");
	m_szImportMeasName	=	_T("MEAS");
	m_szImportMasterName	=	_T("MASTER");
	m_szImportOpnoteName	=	_T("OPNOTE");
	m_szImportSessionName=	_T("SESSION");
#ifdef ALLURA_TSM
	m_szImportAlluraName	=	_T("ALLURA");
#endif
	m_szImportPrePostName=	_T("PREPOST");

	m_uiMSecTimer			=	0L;
	m_iPrintingReview		=	PR_NONE;
	m_bDisplayIntervals	=	true;
	m_eLastCal				=	eHor;
	m_bDBScrnActive		=	false;
	m_bPrintFromList		=	false;
#ifndef PHILIPS_VIEWER
	m_pShell					=	NULL;
	m_pArchiveDialog		=	NULL;
	m_pTrace					=	NULL;
	m_hCurWnd				=	NULL;
	m_pSysMaintDialog		=	NULL;
#endif
	m_szBaseLogName		=	_T("00000000.LOG");
	m_eCaliper				=	eNoneCaliper;
	m_iTriggeredSweepStimStart				=	0;
   m_iTriggeredSweepLevelStart			=	0;
	m_bTriggeredSweepStimSave				=	false;
	m_usTriggeredSweepMonitorPop			=	0;
	m_bTriggeredFirstSweep[TS_MONITOR]	=	false;
   m_bTriggeredFirstSweep[TS_REVIEW]	=	false;
	m_iTriggeredSweepActive[TS_MONITOR]	=	0;
   m_iTriggeredSweepActive[TS_REVIEW]	=	0;
	m_bMapJBoxAlive		=	false;
	m_bPKeyEditDlgActive	=	false;
	m_bConfigScrnActive	=	false;
	m_bShellActive			=	true;
	m_bArchiveCreated		=	false;
	m_bSysMaintCreated	=	FALSE;
	m_bQueryCreated		=	FALSE;
	m_bAskPath				=	false;
	m_bReviewFit			=	false;
   m_bStimulating			=	false;
	m_iCathMapDlgs			=	0;
	m_pWMSplashScreen		= NULL;
	m_fFontFactor			=	2.0f;
	m_bProcessData			=	false;
	m_bMute					=	false;
	m_hDown					=	NULL;
	m_hDownDisable			=	NULL;
	m_hUp						=	NULL;
	m_hUpDisable			=	NULL;
	m_hLock					=	NULL;
	m_hLockDisable			=	NULL;
	m_bPrevReviewActive	=	false;
	m_vAFLMap				=	NULL;
	m_vSMMMap				=	NULL;
	m_vDPMMap				=	NULL;
	MEMSET(m_szBeep);
	m_iStimBeep				=	0;
	m_bResizing				=	false;
	m_bChartSuppliesDialogCreated	=	false;
	m_pChartSuppliesDialog	=	NULL;
	m_iCurrentDBView		=	0;
	m_iTopLevel				=	0;
	m_bUpdateMapWindow	=	FALSE;
	m_bAutoArchiving		=	false;
	m_bSaveMeasurements	=	false;
	m_bActiveMode				= false;
	m_bAutoChartMeasurementsEnabled	=	false;
	m_bSplash				=	false;
	m_hhkLowLevelKybd		=	NULL;
	m_bColorPrint			=	false;
	m_uiTriggeredReviewMode	=	TRIGGERED_MODE_NONE;
		
#ifdef PHILIPS_VIEWER
	m_bViewerMode			=	false;
#endif

#ifdef ALLURA_TSM
	m_bPrimaryEdited		=	false;
	m_bReferringEdited	=	false;
#endif

	MEMSET(m_szTodaysDate);
 	MEMSET(m_szTodaysDate2);
	ZEROSET(m_tmPrint);
	ZEROSET(m_osInfo);
	ZEROSET(m_sLogin);
	ZEROSET(m_sAll);
	ZEROSET(m_sAllura);
	MEMSET(m_arDBView);
	MEMSET(m_arTop);
	MEMSET(m_arCSAutoMeasurementInterval);
	ZEROSET(m_sLicense);
	::strncpy((PCHAR)m_sLicense.szAppName, 
					"WorkMate Claris", 
					ARRAY_SIZE(m_sLicense.szAppName));
	
	for(register short iIndex=0; iIndex<CHART_AUTO_MEAS_TOTAL; ++iIndex)
	{
		m_aruiChartAutoMeasurementTime[iIndex] = 10000U;
	}

	CWMLibrary::CreateFont(m_cfAppFont, FONT_SIZE_20);

	m_ctTime = CDateTime::GetLocalTime();

	CDateTime::GetTime(m_lStartTime);

	m_iStartMS = GetFastTimeMS();
}

CWMApp::~CWMApp( void )
{
	m_fMain	=	NULL;
	m_vReview		=	NULL;
	m_vPrevReview	=	NULL;
	m_vHolter		=	NULL;
	m_vRF				=	NULL;
	m_vCine			=	NULL;
	m_vLog			=	NULL;
	m_fChart			=	NULL;
	m_vChart			=	NULL;
	m_vChartEvent	=	NULL;
#ifndef PHILIPS_VIEWER
	m_vCathMap		=	NULL;
	m_fCathMap		=	NULL;
	m_pTrace			=	NULL;
#endif
	m_fDB				=	NULL;
	m_fMapping		=	NULL;
	m_vATMMap		=	NULL;
	m_vDB				=	NULL;

	m_saCommands.clear();

	if((m_hDevMode!=NULL) && 
		(::GlobalFlags(m_hDevMode)!=GMEM_INVALID_HANDLE))
	{
		UINT nCount = GlobalFlags(m_hDevMode) & GMEM_LOCKCOUNT;
		while(nCount--)
			GlobalUnlock(m_hDevMode);

		GlobalFree(m_hDevMode);		
	}
	m_hDevMode=NULL;

	if((m_hDevNames!=NULL) && 
		(::GlobalFlags(m_hDevNames)!=GMEM_INVALID_HANDLE))
	{
		UINT nCount = GlobalFlags(m_hDevNames) & GMEM_LOCKCOUNT;
		while(nCount--)
			GlobalUnlock(m_hDevNames);

		GlobalFree(m_hDevNames);				
	}

	m_hDevNames=NULL;
}

//Claris-7680
/*-------------------------------------------------------------------------
Function Name    :    ConvertStringToHash()
Description      :    Function to convert input string to hash value using SHA256 algorithm from Wincrypt.h.
					  Return either success or error.
-------------------------------------------------------------------------*/
LRESULT CWMApp::ConvertStringToHash(const CString& sString, BYTE** sHashVal, DWORD& HashLength)
{
	LRESULT	iResult = CRYPT_SUCCESS;
	HCRYPTPROV hProv = 0;
	HCRYPTHASH hHash = 0;
	BYTE *pbHash = NULL;
	DWORD dwHashLen = 0;
	BYTE * pbBuffer = NULL;
	DWORD dwCount = 0;
	DWORD i = 0;
	size_t bufLen = 0;

	const std::string dataStr = CT2A(sString);

	if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
	{
		CMessage::m_erLog.ReportError(_T("Failure in creating hash context."));
		return CRYPT_ERROR_ACQUIRE_KEY_CONTAINER;
	}
	if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
	{
		CryptReleaseContext(hProv, 0);
		CMessage::m_erLog.ReportError(_T("Failure in creating SHA 256 hash key."));
		return CRYPT_ERROR_CREATE_HASH_KEY;
	}

	bufLen = dataStr.length();

	pbBuffer = (BYTE*)malloc(bufLen + 1);
	memset(pbBuffer, 0, bufLen + 1);

	for (i = 0; i < bufLen; i++) {
		pbBuffer[i] = (BYTE)dataStr[i];
	}

	//Create Hash data for sString
	if (!CryptHashData(hHash, pbBuffer, bufLen, 0))
	{
		//Delete memory allocated to pbBuffer
		if (pbBuffer)
		{
			free(pbBuffer);
		}
		CryptDestroyHash(hHash);
		CryptReleaseContext(hProv, 0);
		CMessage::m_erLog.ReportError(_T("Failure in creating SHA 256 hash data."));
		return CRYPT_ERROR_CREATE_HASH_DATA;
	}

	dwCount = sizeof(DWORD);

	//Get length for converted hash value and store in output variable HashLength
	if (!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE *)&dwHashLen, &dwCount, 0))
	{
		//Delete memory allocated to pbBuffer
		if (pbBuffer)
		{
			free(pbBuffer);
		}
		CryptDestroyHash(hHash);
		CryptReleaseContext(hProv, 0);
		CMessage::m_erLog.ReportError(_T("Failure in fetching SHA 256 hash lenghth."));
		return CRYPT_ERROR_GET_HASH_LENGTH;
	}
	if ((pbHash = (unsigned char*)malloc(dwHashLen)) == NULL)
	{
		//deleter memory allocated to pbBuffer
		if (pbBuffer)
		{
			free(pbBuffer);
		}
		CryptDestroyHash(hHash);
		CryptReleaseContext(hProv, 0);
		CMessage::m_erLog.ReportError(_T("Failure in fetching SHA 256 hash value."));
		return CRYPT_ERROR_GET_HASH_VALUE;
	}

	memset(pbHash, 0, dwHashLen);

	//Get converted hash value and store in output variable sHashVal
	if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHash, &dwHashLen, 0))
	{
		//Delete memory allocated to pbBuffer
		if (pbBuffer)
		{
			free(pbBuffer);
		}
		CryptDestroyHash(hHash);
		CryptReleaseContext(hProv, 0);
		CMessage::m_erLog.ReportError(_T("Failure in fetching SHA 256 hash value."));
		return CRYPT_ERROR_GET_HASH_VALUE;
	}

	*sHashVal = pbHash;
	HashLength = dwHashLen;

	if (hHash)
	{
		CryptDestroyHash(hHash);
	}

	if (hProv)
	{
		CryptReleaseContext(hProv, 0);
	}

	//Delete memory allocated to pbBuffer
	if (pbBuffer)
	{
		free(pbBuffer);
	}

	return iResult;
}

/*-------------------------------------------------------------------------
Function Name    :    CompareHashValues()
Description      :    Function checks if two hash values are equal.
-------------------------------------------------------------------------*/
bool CWMApp::CompareHashValues(const BYTE* Hash1, const BYTE* Hash2, size_t Hashlen)
{
	return !memcmp(Hash1, Hash2, Hashlen);
}

bool CWMApp::IsPrevInstance( const UINT uiId, bool bCreate )
{	
	CString csMutexName;

	csMutexName.LoadString(uiId);

	if(bCreate)	
	{
		m_hMutex = CreateMutex(NULL, TRUE, csMutexName);

		DWORD dwError = GetLastError();

		if( dwError==ERROR_ALREADY_EXISTS)	
		{
			if ( m_hMutex )	
			{	
				CloseHandle( m_hMutex );	

				m_hMutex = NULL;
			}

			return true;
		}
	} 
	else	
	{
		HANDLE hMutex = ::OpenMutex(MUTEX_ALL_ACCESS, TRUE, csMutexName);
	
		if( hMutex )
		{	
			CloseHandle( hMutex );

			hMutex = NULL;

			return true;
		}
	}

	return false;
}

bool CWMApp::StartLog(void)
{
	m_dLog.InitLog();

	m_dLog.CreateLogEntriesMenu();

	ASSERT_VALID(m_vLog);
	if(m_vLog)
	{
		m_vLog->DrawLogEntries();
	}

	m_dChart.InitChart();

	m_dChart.CreateChartEntriesMenu();

	if(m_vChart)
	{
		m_vChart->DrawChartEntries();
	}

	m_dReview.GetCurrentLogPage();

	ASSERT_VALID(m_vReview);
	if(m_vReview)
	{
		m_vReview->InvalidateView();
	}

	m_dPrevReview.GetCurrentLogPage();

	ASSERT_VALID(m_vPrevReview);
	if(m_vPrevReview)
	{
		m_vPrevReview->InvalidateView();
	}

	ASSERT_VALID(m_vATMMap);
	if(m_vATMMap)	
	{	
		GetSession();
		m_MainBar.SetDrugIcon();

		if(m_fMapping)
		{ 
			m_fMapping->SetCaption();
		}
	}

	return true;	
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::ExitWorkMate()

	Description	:	This function exits the application into the shell by closing
						all the windows, serial communication, network communication,
						printing and logging the application information. It saves the 
						database views to the file.

	Returns		:	None

	Setup			:	1. Open the review screen.
		CRYO_CATH:
						1. Connect the CryoCath CryoConsole ablation generator unit 
						to the WorkMate through the serial cable.
						2. Set the registry flag to the Cryo Cath setting value of 9.
						3. Open the ablation window.
		DB VIEWS		:
						1.	Open the database window.

	Testing		:	1. Left mouse press on the 'Exit' button on the mainbar window.
						Verify the application displays the shell.
						2. Verify the event viewer file logs the system information.
		CRYO_CATH:
						1. Start an injection cycle, verify the ablation data is displayed
						on the temperature graph of the Cryo Tab on the RF screen.
						2. Left mouse press on the 'Exit' button while injection is in 
						progress. Verify the WorkMate application stops the injection process
						and the closes the serial communication port without any errors.

		DB VIEWS	:
						1. Left mouse click on the 'Views' button. Verify the 
						database view list dialog displays.
						2. Left mouse click on the second list item. Verify the
						item is selected.
						3. Left mouse click on the 'Edit' button. Verify the Edit
						database view dialog displays.
						4. Left mouse click on the 'PRE' check box cotnrol. Verify 
						the control is unchecked.
						5. Left mouse click on the 'POST' check box cotnrol. Verify 
						the control is unchecked.
						6. Left mouse click on the 'Save' button. Verify the dialog
						box closes.
						7. Left mouse click on the 'Select' button. Verify the 'PRE'
						and 'POST' database tab window does not display.
						8. Press the 'Exit' button on the MainBar. Verify the 'Are you
						sure you want to leave' prompt window displays.
						9. Left mouse click on the 'Yes' button. Verify the shell displays.
						10. Left mouse click on the 'Begin/Review Study' button. Verify
						the opening screen displays.
						11. Press the 'Database' button on the MainBar. Verify the database
						window displays. Verify the selected view displays. Verify the 'PRE'
						and 'POST' database tab window does not display.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::ExitWorkMate(const bool bDontAskFirst) 
{
	const long lLogDirNumber = m_dProcedure.m_Procedure.log_dir_number;
	const DWORD dwDHR = m_dProcedure.m_Procedure.dwDHR;

	CRegistry::Instance()->SetString(_T("REPORTS\\CURLOGDIR"), _T(""));

   if(!bDontAskFirst)
	{
		if(CMessage::YesNo(WMFILELINE, 142)!=IDYES)
		{
			m_MainBar.m_btnExitCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
			return;	
		}
	}

	m_fChart->StopAutoChartMeasurements();

	// Close the Frequency Review window, if open.
	if(m_vFreqReview->IsWindowVisible())
	{
		m_fReview->Toggle(false);
	}

	// Close the Cine 
#ifdef WM_VERSION_I50_HSN
	m_dCine.Stop();
#else
	const WORD wCineDeviceIndex = (m_INIfile.m_iCineMaximumDevices>1) ? CINE_CTL_1: 0;
	::SendNotifyMessage(	HWND_BROADCAST, m_arMessage[WM2CINE_STOP].uiId, MAKEWPARAM(wCineDeviceIndex,0), (LPARAM)1);
#endif

	if(CWMLibrary::IsSafeWindow(m_fPrint) && m_cgPage.IsPrinting())
	{
		m_MainBar.m_pPrintPreView->Close(true);
	} 

#ifndef PHILIPS_VIEWER
	// Close the measurement save dialog.
	if(CWMLibrary::IsSafeWindow(m_vCathMap) &&  
		CWMLibrary::IsSafeWindow(m_vCathMap->m_pConfigScreen) && 
		m_bConfigScrnActive)	
	{	
		m_vCathMap->m_pConfigScreen->SaveAndExit();
	}
#endif

	if( CWMLibrary::IsSafeWindow(m_pChartSuppliesDialog) &&  m_bChartSuppliesDialogCreated)
	{	
		m_pChartSuppliesDialog->OnButtonClose();
	}

	// Close the measurement save dialog.
	/*if( CWMLibrary::IsSafeWindow(m_dMeas.m_pMeasSaveDialog) &&  IsCreated(IDD_DIALOG_MEAS_SAVE))	
	{	
		m_dMeas.m_pMeasSaveDialog->CloseDialog();
	}*/

#ifndef PHILIPS_VIEWER

	CMessage::m_erLog.ReportError(_T("Before m_Stim.Terminate"));
	m_Stim.Terminate();

	m_Stim.Show(false);	//	Force it, so that Hotkeys do not interfere the closing dialogs.

	CMessage::m_erLog.ReportError(_T("After m_Stim.Terminate"));
#endif

   if(m_INIfile.m_iAskStoreCathmap)
   {
      m_dCathMap.SaveCatheterMapChanges();
   }

#ifdef ALLURA_TSM
		m_bPrimaryEdited		=	false;
		m_bReferringEdited	=	false;
#endif

	CMessage::m_erLog.ReportError(_T("Before m_vDB->CloseAndExit"));
	if(m_vDB->CloseAndExit())
	{
#ifndef PHILIPS_VIEWER
#ifdef ALLURA_TSM
		m_TSM.ClearSession();
#endif
#endif

		if(m_dPatient.m_Access.m_usRecordNumber && m_dProcedure.m_Access.m_usRecordNumber)
		{
			m_dLog.NewLogDirNumber();
		}

		m_dChart.CloseChartFiles();
		m_dLog.CloseLogFiles();

		// clear the master record number
		m_INIfile.PutPrevRunAll(0, m_dCathMap.m_Access.m_usRecordNumber, 0,  false, 0 );
	}
	
	CMessage::m_erLog.ReportError(_T("After m_vDB->CloseAndExit"));

	SaveDBViews();

   if(m_vRF)
   {
	   if( CWMLibrary::IsSafeWindow(m_vRF->m_pViewDataDialog) )	
		{	
		   m_vRF->m_pViewDataDialog->CloseDialog();
	   }

	   if( CWMLibrary::IsSafeWindow(m_vRF->m_pRFSummaryDialog) )	
		{	
		   m_vRF->m_pRFSummaryDialog->CloseDialog();
	   }
   }

	m_fMapping->CloseAll();

#ifndef PHILIPS_VIEWER
	// This does not delete the CathMapView Object !
	if( CWMLibrary::IsSafeWindow(m_vCathMap) )
	{
		m_vCathMap->Kill();
	}
#endif

	// Close the monitor change dialogs on monitor & realtime views.
	if(CWMLibrary::IsSafeWindow(m_fMonitor->m_vMonitor.m_pMonitorChangeDialog) && 
		m_fMonitor->m_vMonitor.m_bMonitorChangeDialogOpen )
	{
		m_fMonitor->m_vMonitor.m_pMonitorChangeDialog->CloseDialog();
	}

	if(CWMLibrary::IsSafeWindow(m_fRealTime->m_mtMonitor.m_vMonitor.m_pMonitorChangeDialog) &&
		m_fRealTime->m_mtMonitor.m_vMonitor.m_bMonitorChangeDialogOpen)
	{
		m_fRealTime->m_mtMonitor.m_vMonitor.m_pMonitorChangeDialog->CloseDialog();
	}

	// Close the review change dialogs on review & prevreview views.
	if(CWMLibrary::IsSafeWindow(m_vReview->m_pReviewChangeDialog) && 
		m_vReview->m_bReviewChangeDialogOpen )
	{
		m_vReview->m_pReviewChangeDialog->CloseDialog();
	}

	if(CWMLibrary::IsSafeWindow(m_vPrevReview->m_pReviewChangeDialog) && 
		m_vPrevReview->m_bReviewChangeDialogOpen )
	{
		m_vPrevReview->m_pReviewChangeDialog->CloseDialog();
	}

	// Stop the StopWatch and hide it.
	if( CWMLibrary::IsSafeWindow(m_MainBar.m_pStopWatchDialog) )
	{
		m_MainBar.m_pStopWatchDialog->OnButtonStop();

		m_MainBar.m_pStopWatchDialog->OnButtonReset(); 

		if(m_MainBar.m_pStopWatchDialog->IsWindowVisible())
		{
			m_MainBar.m_pStopWatchDialog->OnButtonClose();
		}
	}
	
	switch(m_INIfile.m_usMappingSystemInstalled)
	{
		case MAPPING_SYSTEM_NONE	:
		case MAPPING_SYSTEM_CARTO	:
		case MAPPING_SYSTEM_ENSITE	:
		default:
		{		
			m_dMapping->m_bMapMate = false;
		}
		break;
	}	

	#if defined(DEMO_CD_ROM)

	#else								// Server
#ifndef PHILIPS_VIEWER
		if(m_INIfile.m_bNurseMateInstalled)
		{
			m_sNM.ShutDown();
		}
#endif
	#endif

	StopMasterTimers();

#ifndef PHILIPS_VIEWER
#ifdef ALLURA_TSM
	if(m_INIfile.m_bTSMInstalled)
	{
		m_TSM.Terminate();
	}
#endif
#endif

	if(CMessage::m_pWMPopup)
	{
		CMessage::m_pWMPopup->Hide();
	}

	m_bProcessData = false;

#ifndef PHILIPS_VIEWER
	if(m_INIfile.m_iRFGeneratorInstalled==RF_CRYO_CATH)
	{
		m_dRF.Terminate();
	}
	else
	{
		m_dRF.CloseRFPort();
	}

	if(CWMLibrary::IsSafeWindow(m_pTrace))
	{
		m_pTrace->Save(lLogDirNumber, dwDHR);
		m_pTrace->ShowWindow(SW_HIDE);
	}
#endif

	register short iIndex=0;
	for(iIndex=0; iIndex<2; ++iIndex)
	{
		m_TriggerCtl[iIndex].Reset();
		m_TriggerModeCtl[iIndex].Reset();
	}

	// Prompt user before closing ALL LibreOffice documents and saving them AS-IS
	// Since ExitWorkMate() is called from within Logout() when LEAVE_ALONE < 0, this check:
	//		1. Helps display the confirmation prompt
	//		2. Avoids calling LibreOffice cleanup code twice in the case when LEAVE_ALONE > 0
	if (m_INIfile.m_iDBAccessMode == DISABLE_PASSWORDS) {
		HWND hWndMain = ::AfxGetMainWnd()->GetSafeHwnd();
		if (CReport::FindLibreOfficeWriter(hWndMain)) {
			if (CMessage::YesNo(WMFILELINE, 3181) == IDNO) {
				return;
			}
			try
			{
				AFX_THREADPROC ExitLoFunc = [](LPVOID pParam)->UINT {
					CLibreOfficeWriter::Instance()->FreeApp();
					return EXIT_SUCCESS;
				};
				::AfxBeginThread(ExitLoFunc, NULL);
			}
			catch (const _com_error& e)
			{
				CMessage::m_erLog.ReportError(e.ErrorMessage());
			}
		}
	}

	//Logout();

	HideAllWindows();

#ifndef _DEBUG
	if(!IsArgument(_T("DISABLE_PROG_BURST")))
	{
		UnregisterHotKey(m_pMainWnd->m_hWnd, 1);
	}
#endif

	m_INIfile.PutConfig();

	LogInfo();

#ifndef PHILIPS_VIEWER
	if(m_pShell && m_INIfile.m_iRunArchiveOnExit)	
	{
		m_pShell->OnButtonArchive();
	}	
	else	
	{
		ShowShell();
	}
#endif

	if( CWMLibrary::IsSafeWindow(m_fMain) )	
	{	
		m_fMain->SetReverse(m_INIfile.m_bMouseRight?true:false);
		m_fMain->DrawScreenHeader();
	}

	switch(m_INIfile.m_usMappingSystemInstalled)
	{
		case MAPPING_SYSTEM_NONE	:
		default							:
		{
		}
		break;

#ifdef ENABLE_CARTO
		case MAPPING_SYSTEM_CARTO	:
		{
			CCartoMappingDoc* pCarto = CCartoMappingDoc::Instance();
			pCarto->ReleaseCommunication();
		}
		break;
#endif
		case MAPPING_SYSTEM_ENSITE	:
		{		
			//m_pMapping->ReleaseCommunication();			
		}
		break;
	}

#ifdef PHILIPS_VIEWER
	ShutDown(false, true);
	if( CWMLibrary::IsSafeWindow(m_fMain) )	
	{
		m_fMain->SendMessage(WM_CLOSE);
	}
	
#endif

	this->GetDatabaseLock().DetachLock();
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::LogInfo()

	Description	:	This function logs all the systems specific information
						to the event log file.

	Returns		:	None

	Setup			:	1. Launch the WorkMate.
						2. Record few electrograms.
						3. Burn few ablation cycles if possible.
						4. Play and Save few Cine Images if possible.

	Testing		:	1. Close the WorkMate. Verify the last event log file logs 
							the system specific information.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::LogInfo(void)
{
	MEMORYSTATUS	memStatus = {0};
	memStatus.dwLength = sizeof(MEMORYSTATUS);
	::GlobalMemoryStatus(&memStatus);

	CString csEventLog;

	csEventLog.Format(_T("Exit To Shell"));
	CMessage::m_erLog.ReportError(csEventLog);

	switch (m_INIfile.m_iEP4Installed)
	{
	case STIMULATOR_NONE:
	{
		CMessage::m_erLog.ReportError(GETMESSAGE(1783));
	}
		break;

	case STIMULATOR_EP4:
	{
#ifndef PHILIPS_VIEWER
		if (CWMLibrary::IsSafeWindow(m_Stim.m_pEP4))
		{
			if (CWMLibrary::IsSafeWindow(m_Stim.m_pEP4->m_pDefine))
			{
				CString csTemp; m_Stim.m_pEP4->m_pDefine->GetCommErrorResults(csTemp);
				csEventLog.Format(GETMESSAGE(1781), csTemp);

				CMessage::m_erLog.ReportError(csEventLog);
			}
		}
#endif
	}
		break;
	}

	if (m_INIfile.m_iRFGeneratorInstalled > 0)
	{
		CString csTemp; m_dRF.GetCommErrorResults(csTemp);
		csEventLog.Format(GETMESSAGE(1780), csTemp);
		CMessage::m_erLog.ReportError(csEventLog);
	}

	if (m_INIfile.m_bCineInstalled)
	{
		csEventLog.Format(GETMESSAGE(1779),
						  m_dCine.m_ulTotalPlayTime,
						  m_dCine.m_dwTotalFileSaves);
		CMessage::m_erLog.ReportError(csEventLog);
	}

	csEventLog.Format(GETMESSAGE(1778),
					  memStatus.dwMemoryLoad,
					  memStatus.dwTotalPhys,
					  memStatus.dwAvailPhys,
					  memStatus.dwTotalVirtual,
					  memStatus.dwAvailVirtual);
	CMessage::m_erLog.ReportError(csEventLog);

	LogAmplifierStats(false);
}
void CWMApp::LogAmplifierStats(bool doStudyStats)
{
	CString csEventLog;

	if(m_INIfile.m_szAmpAdapterIP[0] == 0)
	{
		csEventLog = GETMESSAGE(1777);
	}
	else
	{
#ifndef PHILIPS_VIEWER
		const UINT MillisecondsPerSecond = static_cast<UINT>(1000);
		const UINT SecondsPerMinute = static_cast<UINT>(60);
		const UINT MinutesPerHour = static_cast<UINT>(60);
		const IAmplifierStatus* pAmplifierStatus = 0;
		UINT nTotalTimeInMilliseconds = 0;
		UINT nTotalTimeInSeconds = 0;
		UINT nPacketCountReceived = 0;
		UINT nPacketCountDropped = 0;
		UINT nPauseCount = 0;

		pAmplifierStatus = IAmplifierStatus::Instance();

		if (doStudyStats)
		{
		   nTotalTimeInMilliseconds = pAmplifierStatus->GetStudyLastPacketTimeReceived() - pAmplifierStatus->GetStudyFirstPacketTimeReceived();
		   nPacketCountReceived = pAmplifierStatus->GetStudyTotalPackets();
		   nPacketCountDropped = pAmplifierStatus->GetStudyDroppedPacketCount();
		   nPauseCount = pAmplifierStatus->GetStudyCommPauseCount();
		}
		else
		{
		   nTotalTimeInMilliseconds = pAmplifierStatus->GetLastPacketTimeReceived() - pAmplifierStatus->GetFirstPacketTimeReceived();
		   nPacketCountReceived = pAmplifierStatus->GetTotalPackets();
		   nPacketCountDropped = pAmplifierStatus->GetDroppedPacketCount();
		   nPauseCount = pAmplifierStatus->GetCommPauseCount();
		}

        nTotalTimeInSeconds = nTotalTimeInMilliseconds / MillisecondsPerSecond;
		double dPacketsPerSecond = 0.0;
		if (nTotalTimeInMilliseconds) {
			// [hkc:02.19.2013]: do not use nTotalTimeInSeconds here (loss of precision).
			dPacketsPerSecond =
				static_cast<double>(nPacketCountReceived) *
				static_cast<double>(MillisecondsPerSecond) /
				static_cast<double>(nTotalTimeInMilliseconds);
		}
		
		const double dProjectedErrorCountProjectionAmount = 1000000.0;
		
		double dProjectedErrorCount = 0.0;
		if (nPacketCountReceived) {
			dProjectedErrorCount =
				static_cast<double>(nPacketCountDropped) *
				dProjectedErrorCountProjectionAmount /
				static_cast<double>(nPacketCountReceived);
		}
		
		CString csString(_T(""));
		
		if (doStudyStats)
			csString = _T("Study: ");
		csString += GETMESSAGE(1776);

		csEventLog.Format(
			csString,
			nPacketCountReceived,
			nTotalTimeInSeconds / (SecondsPerMinute * MinutesPerHour),
			(nTotalTimeInSeconds / SecondsPerMinute) % MinutesPerHour,
			nTotalTimeInSeconds % SecondsPerMinute,
			dPacketsPerSecond,
			nPacketCountDropped,
			dProjectedErrorCount,
			nPauseCount);
#endif
	}

	CMessage::m_erLog.ReportError(csEventLog);
}

void CWMApp::HideAllWindows(void)
{
	if(CWMLibrary::IsSafeWindow(m_fPrint))
	{
		m_fPrint->ShowWindow(SW_HIDE);
	}
	m_MainBar.ShowWindow(SW_HIDE);
#ifndef PHILIPS_VIEWER
	m_Stim.ShowWindow(SW_HIDE);
#endif
	m_bDBScrnActive=false;
	m_fDB->ShowWindow(SW_HIDE);
	m_MainBar.m_btnDBCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	
	m_fMapping->ShowWindow(SW_HIDE);
	m_fPrevReview->ShowWindow(SW_HIDE);
	m_fHolter->ShowWindow(SW_HIDE);
	m_fRF->ShowWindow(SW_HIDE);
	m_fCine->ShowWindow(SW_HIDE);
	m_fLog->ShowWindow(SW_HIDE);
	m_fChart->ShowWindow(SW_HIDE);
	m_fReview->ShowWindow(SW_HIDE);
	if( !IsArgument(_T("NO_MONITOR_SCREEN")) )
	{
		m_fMonitor->ShowWindow(SW_HIDE);
	}

	m_fRealTime->ShowWindow(SW_HIDE);
	m_fRealTimeBar->ShowWindow(SW_HIDE);
	m_fMeasurement->ShowWindow(SW_HIDE);
}

void CWMApp::ExitDataBase(void)
{
	m_dPatient.ExitDB();

	m_dbPhysician.ExitDB();

	m_dbPSpec.ExitDB();

	m_dbLSpec.ExitDB();

	m_dbICD.ExitDB();

	m_dCathMap.ExitDB();

	m_dbLogin.ExitDB();
}

int CWMApp::ExitInstance() 
{
	if(m_hDown)			{	::DestroyIcon(m_hDown);			m_hDown=NULL;			}
	if(m_hDownDisable){	::DestroyIcon(m_hDownDisable);m_hDownDisable=NULL;	}
	if(m_hUp)			{	::DestroyIcon(m_hUp);			m_hUp=NULL;				}
	if(m_hUpDisable)	{	::DestroyIcon(m_hUpDisable);	m_hUpDisable=NULL;	}
	if(m_hLock)			{	::DestroyIcon(m_hLock);			m_hLock=NULL;			}
	if(m_hLockDisable){	::DestroyIcon(m_hLockDisable);m_hLockDisable=NULL;	}

	m_hDefaultCursor	=	NULL;
	m_hNullCursor		=	NULL;
	m_hHandCursor		=	NULL;

	if(m_hPruckaHorz)	{	::DestroyIcon(m_hPruckaHorz);	m_hPruckaHorz	=	NULL;	}
	if(m_hEastWest)	{	::DestroyIcon(m_hEastWest);	m_hEastWest		=	NULL;	}
	if(m_hNorthSouth)	{	::DestroyIcon(m_hNorthSouth);	m_hNorthSouth	=	NULL;	}
	if(m_hSouthEast)	{	::DestroyIcon(m_hSouthEast);	m_hSouthEast	=	NULL;	}
	if(m_hSouthWest)	{	::DestroyIcon(m_hSouthWest);	m_hSouthWest	=	NULL;	}

	if(m_hMutex)	{	CloseHandle(m_hMutex);	}
	m_hMutex = NULL;

	CMessage::m_erLog.ReportError(_T("EP-WorkMate Exited"));

	CMessage::CleanUp();

	if(m_osInfo.dwPlatformId==VER_PLATFORM_WIN32_NT)
	{
		if(m_osInfo.dwMajorVersion==5 && m_osInfo.dwMinorVersion==1)	// WinXP
		{
			//CImage::CleanUp();
		}
	}

	CImage::CleanUp();

	::SetErrorMode( 0 );

#ifndef PHILIPS_VIEWER
	m_SoundManager.Terminate();
#endif	

	return CWinApp::ExitInstance();
}

#ifdef PHILIPS_VIEWER

LPCTSTR CWMApp::GetArgumentValue(const CString& csArg, CString& csValue)
{
	int iLen = csArg.GetLength();
	int iPos = csArg.Find('[');

	int iCount = iLen-(iPos+1)-1;

	if(iPos>-1 && (iPos+1)<iLen && iCount>0)
	{
		csValue = csArg.Mid(iPos+1, iCount);
	}

	return csValue;
}

LPCTSTR CWMApp::IsArgument(LPCTSTR szArgument)	const
{
	const int iMaxArgs = m_saCommands.size();

	if(iMaxArgs<=0)
	{
		return NULL;
	}

	for( register int iIndex=0; iIndex<iMaxArgs; ++iIndex)	
	{
		const CString& csTemp = m_saCommands[iIndex];

		if(csTemp.Find(szArgument)!=-1)
		{
			return csTemp;
		}
	}

	return NULL;
}

#else

bool CWMApp::IsArgument(LPCTSTR szArgument)	const
{
	const int iMaxArgs = m_saCommands.size();

	if(iMaxArgs<=0)
	{
		return false;
	}

	for( register int iIndex=0; iIndex<iMaxArgs; ++iIndex)	
	{
		const CString& csTemp = m_saCommands[iIndex];

		if(csTemp.Compare(szArgument)==0)
		{
			return true;
		}
	}

	return false;
}

#endif

void CWMApp::ParseCommandLine(void)
{
#ifdef PHILIPS_VIEWER
	for( register short iArgIndex=1; iArgIndex<__argc; ++iArgIndex)	
	{
		CString csEachArgument( __targv[iArgIndex] );
		
		if(csEachArgument.IsEmpty() )	{	continue;	}

		const int iLen = csEachArgument.GetLength();

		if(iLen<1)	
		{
			continue;
		}

		AfxTrace(_T("%s\n"), csEachArgument);

		if(!csEachArgument.IsEmpty() )	
		{
			m_saCommands.push_back( csEachArgument );
		}
	}
#else

	for( register short iArgIndex=1; iArgIndex<__argc; ++iArgIndex)	
	{
		CString csEachArgument( __targv[iArgIndex] );
		
		if(csEachArgument.IsEmpty() )	{	continue;	}

		const int iLen = csEachArgument.GetLength();

		if(iLen<1)	{	continue;	}

		if( csEachArgument.GetAt(iLen-1)==',')	
		{	
			CString csTempArgument = csEachArgument.Left(iLen-1);

			AfxTrace(_T("%s\n"), csTempArgument);

			if(!csTempArgument.IsEmpty() )	
			{
				m_saCommands.push_back( csTempArgument );
			}

			continue;
		}

		AfxTrace(_T("%s\n"), csEachArgument);

		if(!csEachArgument.IsEmpty() )	
		{
			m_saCommands.push_back( csEachArgument );
		}
	}
#endif
}

void CWMApp::SplitOneWindow(CWnd* const pWnd, const bool bLeft, const bool bSplit)
{
	CWMLibrary::AdjustWindow(pWnd, bLeft, bSplit);

	pWnd->ShowWindow(SW_SHOW);
	pWnd->BringWindowToTop();
}

void CWMApp::ResizeAllReviewWindows(eWMWindow eType)
{
	m_bResizing = true; // don't let checkallviews hide things

	CRect crMainBar(m_MainBar.m_crArea);
	
   const int iWidth = CWMLibrary::GetDesktopWidth();

	int iAbsBottom = ::GetSystemMetrics(SM_CYSCREEN);

#ifndef PHILIPS_VIEWER
	if( IsStimActive() )
	{
		int iStimBarHeight, iStimWindowHeight;
		m_Stim.GetStimWindowHeight(iStimBarHeight, iStimWindowHeight);

		if( m_Stim.IsShrunk() )
		{
			iAbsBottom -= iStimBarHeight;
		}
		else
		{
			iAbsBottom -= iStimWindowHeight;
		}
	}
#endif

	WINDOWPLACEMENT wpWnd={sizeof(wpWnd)};

   if(eType==eReview || eType==eNoWindow) 
   {
	   if(m_fReview && m_fReview->IsWindowVisible())
      {
		   m_fReview->GetWindowPlacement(&wpWnd);
		   wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
		   wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fReview->SetWindowPlacement(&wpWnd);
	   }
   }

	if(eType==ePrevReview || eType==eNoWindow) 
   {
      if(m_fPrevReview && m_fPrevReview->IsWindowVisible())
      {
		   m_fPrevReview->GetWindowPlacement(&wpWnd);
		   wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
		   wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fPrevReview->SetWindowPlacement(&wpWnd);
      }
	}

	if(eType==eHolter || eType==eNoWindow) 
   {
	   if(m_fHolter && m_fHolter->IsWindowVisible())
      {
		   m_fHolter->GetWindowPlacement(&wpWnd);
		   wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
		   wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fHolter->SetWindowPlacement(&wpWnd);
	   }
   }

	if(eType==eRF || eType==eNoWindow) 
   {
	   if(m_fRF && m_fRF->IsWindowVisible())
      {
		   m_fRF->GetWindowPlacement(&wpWnd);
		   wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
		   wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fRF->SetWindowPlacement(&wpWnd);
	   }
   }

	if(eType==eCine || eType==eNoWindow) 
   {
	   if(m_fCine && m_fCine->IsWindowVisible())
      {
		   m_fCine->GetWindowPlacement(&wpWnd);
		   wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
		   wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fCine->SetWindowPlacement(&wpWnd);
	   }
   }

	if(eType==eLog || eType==eNoWindow) 
   {
      if(m_fLog && m_fLog->IsWindowVisible())
		{
   		m_fLog->GetWindowPlacement(&wpWnd);
	   	wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
		   wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fLog->SetWindowPlacement(&wpWnd);
      }
   }

	if(eType==eChart || eType==eNoWindow) 
   {
      if(m_fChart && m_fChart->IsWindowVisible())
		{
   		m_fChart->GetWindowPlacement(&wpWnd);
	   	wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
		   wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fChart->SetWindowPlacement(&wpWnd);
      }
   }

	if(eType==eMapping || eType==eNoWindow) 
   {
      if(m_fMapping && m_fMapping->IsWindowVisible())
		{
   		m_fMapping->GetWindowPlacement(&wpWnd);
	   	wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
		   wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fMapping->SetWindowPlacement(&wpWnd);
      }
   }

	if(eType==eCathMap || eType==eNoWindow) 
   {
#ifndef PHILIPS_VIEWER
      if(m_fCathMap && m_fCathMap->IsWindowVisible())
		{
   		m_fCathMap->GetWindowPlacement(&wpWnd);
	   	wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
         if (wpWnd.rcNormalPosition.top>iAbsBottom-100) wpWnd.rcNormalPosition.top=iAbsBottom-100;
         wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fCathMap->SetWindowPlacement(&wpWnd);
      }
#endif
   }

	if(eType==eDB || eType==eNoWindow) 
   {
      if(m_fDB && m_fDB->IsWindowVisible())
		{
   		m_fDB->GetWindowPlacement(&wpWnd);
	   	wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
			if (wpWnd.rcNormalPosition.top>iAbsBottom-100) wpWnd.rcNormalPosition.top=iAbsBottom-100;
         wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fDB->SetWindowPlacement(&wpWnd);
      }
   }

	if(eType==eMonitor || eType==eNoWindow) 
   {
      if(m_fMonitor && m_fMonitor->IsWindowVisible())
		{
		   m_fMonitor->GetWindowPlacement(&wpWnd);
		   wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
		   wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fMonitor->SetWindowPlacement(&wpWnd);
	   }
   }

	if((CWMLibrary::IsDualMonitor()		|| 
		(!CWMLibrary::IsDualMonitor()))&& 
		(eType==eRealTime || eType==eNoWindow) )
   {
      if(m_fRealTime && m_fRealTime->IsWindowVisible())
		{
		   m_fRealTime->GetWindowPlacement(&wpWnd);
		   wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
			if (wpWnd.rcNormalPosition.top>iAbsBottom-100) wpWnd.rcNormalPosition.top=iAbsBottom-100;
         wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fRealTime->SetWindowPlacement(&wpWnd);
	   }
	   
      if(m_fRealTimeBar && m_fRealTimeBar->IsWindowVisible())
		{
		   m_fRealTimeBar->GetWindowPlacement(&wpWnd);
		   wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
			if (wpWnd.rcNormalPosition.top>iAbsBottom-100) wpWnd.rcNormalPosition.top=iAbsBottom-100;
         wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fRealTimeBar->SetWindowPlacement(&wpWnd);
	   }	   
   }

	if( CWMLibrary::IsSafeWindow(m_fPrint) )
	{
      if(m_fPrint->IsWindowVisible())	
		{
		   m_fPrint->GetWindowPlacement(&wpWnd);
		   wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
			if (wpWnd.rcNormalPosition.top>iAbsBottom-100) wpWnd.rcNormalPosition.top=iAbsBottom-100;
		   wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fPrint->SetWindowPlacement(&wpWnd);
	   }
	}

	if(eType==eMeasurement || eType==eNoWindow) 
   {
	   if(m_fMeasurement && m_fMeasurement->IsWindowVisible())
      {
		   m_fMeasurement->GetWindowPlacement(&wpWnd);
		   wpWnd.rcNormalPosition.top=max(crMainBar.bottom, wpWnd.rcNormalPosition.top);
		   wpWnd.rcNormalPosition.bottom= min(iAbsBottom, wpWnd.rcNormalPosition.bottom);
		   m_fMeasurement->SetWindowPlacement(&wpWnd);
	   }
   }

	m_bResizing = false; // don't let checkallviews hide things
}

void CWMApp::AdjustOneWindowHeight(	CWnd* pWnd, 
												double dExpansionRatio, 
												int iScreenTop, 
												int iAbsBottom, 
												short eTransition, 
												long lStimTop)
{
   WINDOWPLACEMENT wpWnd={sizeof(wpWnd)};

   if(pWnd && pWnd->IsWindowVisible())
   {
		pWnd->GetWindowPlacement(&wpWnd);
		
		bool bResize = true;
		
		if(eTransition==EP3_OFF_TO_ON)
		{
			bResize = (wpWnd.rcNormalPosition.bottom>lStimTop);
		}
		else
		{
			bResize = true;
		}
		
		/*bool bResize = (((eTransition==EP3_OFF_TO_ON) && (wpWnd.rcNormalPosition.bottom>iAbsBottom)) || 
										(eTransition==EP3_ON_TO_OFF) );*/
		
		//if(bResize)
		{   			
			wpWnd.rcNormalPosition.bottom -= wpWnd.rcNormalPosition.top; // subtract off the top for now 
			wpWnd.rcNormalPosition.bottom = (int)(wpWnd.rcNormalPosition.bottom * dExpansionRatio + .5);

			wpWnd.rcNormalPosition.top -= iScreenTop; // now adjust the top window position
			wpWnd.rcNormalPosition.top = (int)((wpWnd.rcNormalPosition.top) * dExpansionRatio + .5);
			wpWnd.rcNormalPosition.top += iScreenTop;

			wpWnd.rcNormalPosition.bottom += wpWnd.rcNormalPosition.top; // add the top back in

			pWnd->SetWindowPlacement(&wpWnd);
		}
	}
}

void CWMApp::AdjustReviewWindowHeight(	const double dExpansionRatio, 
													int	iScreenTop, 
													int	iAbsBottom, 
													short eTransition, 
													long	lStimTop)
{
	m_bResizing = true; // don't let CheckAllViews() hide the window in the middle of this   

	AdjustOneWindowHeight(m_fReview,		dExpansionRatio, iScreenTop, iAbsBottom, eTransition, lStimTop);   
   AdjustOneWindowHeight(m_fPrevReview,dExpansionRatio, iScreenTop, iAbsBottom, eTransition, lStimTop);
	AdjustOneWindowHeight(m_fHolter,		dExpansionRatio, iScreenTop, iAbsBottom, eTransition, lStimTop); 
	AdjustOneWindowHeight(m_fRF,			dExpansionRatio, iScreenTop, iAbsBottom, eTransition, lStimTop);	
	AdjustOneWindowHeight(m_fCine,		dExpansionRatio, iScreenTop, iAbsBottom, eTransition, lStimTop);	
	AdjustOneWindowHeight(m_fLog,			dExpansionRatio, iScreenTop, iAbsBottom, eTransition, lStimTop);	
	AdjustOneWindowHeight(m_fChart,		dExpansionRatio, iScreenTop, iAbsBottom, eTransition, lStimTop);	
	AdjustOneWindowHeight(m_fMapping,	dExpansionRatio, iScreenTop, iAbsBottom, eTransition, lStimTop);		
	AdjustOneWindowHeight(m_fMonitor,	dExpansionRatio, iScreenTop, iAbsBottom, eTransition, lStimTop);	
	AdjustOneWindowHeight(m_fPrint,		dExpansionRatio, iScreenTop, iAbsBottom, eTransition, lStimTop);	
	AdjustOneWindowHeight(m_fMeasurement,dExpansionRatio, iScreenTop, iAbsBottom, eTransition, lStimTop);	
	
	m_bResizing = false; // don't let CheckAllViews() hide the window in the middle of this
}

void CWMApp::AdjustAllReviewWindowsForEP3(short eTransition)
// EP3_OFF_TO_ON
// EP3_ON_TO_OFF
// EP3_MAX_TO_MIN
// EP3_MIN_TO_MAX
{
#ifndef PHILIPS_VIEWER
	// find the maximum height we are going into
	CRect crArea(m_MainBar.m_crArea);

	int iHeight = ::GetSystemMetrics(SM_CYSCREEN);
	iHeight -= crArea.bottom;
	if (iHeight <= 0) return;

	// first find the size of the EP-3 that is closing
	int iEP3MinHeight = 0;
	int iEP3MaxHeight = 0;

   m_Stim.GetStimWindowHeight(iEP3MinHeight, iEP3MaxHeight);
	
	double dAdjustHeight=1.0;

	int iAbsBottom = ::GetSystemMetrics(SM_CYSCREEN);

	if( IsStimActive() )
	{
		if( m_Stim.IsShrunk() )
		{
			iAbsBottom -= iEP3MinHeight;
		}
		else
		{
			iAbsBottom -= iEP3MaxHeight;
		}
	}

	long lStimTop = m_Stim.GetStimTop();
		
	switch (eTransition)
	{
	case EP3_OFF_TO_ON:
		// so (iHeight-iEP3MaxHeight)/iHeight is the ratio we are shrinking all windows
		if (m_Stim.IsShrunk())
		{ 
			dAdjustHeight = (double)(iHeight-iEP3MinHeight)/iHeight; // shrink by this much
		} 
		else 
		{
			dAdjustHeight = (double)(iHeight-iEP3MaxHeight)/iHeight; // shrink by this much
		}
		break;
	case EP3_ON_TO_OFF:
		// so iHeight/(iHeight-iEP3MaxHeight) is the ratio we are expanding all windows
		if (m_Stim.IsShrunk())
		{ 
			dAdjustHeight = (double)iHeight/(iHeight-iEP3MinHeight); // expand by this much
		} 
		else 
		{
			dAdjustHeight = (double)iHeight/(iHeight-iEP3MaxHeight); // expand by this much
		}
		break;
	case EP3_MAX_TO_MIN:
		// so (iHeight-iEP3MinHeight)/(iHeight-iEP3MaxHeight) is the ratio we are expanding all windows
		dAdjustHeight = (double)(iHeight-iEP3MinHeight)/(iHeight-iEP3MaxHeight); // expand by this much
		break;
	case EP3_MIN_TO_MAX:
		// so (iHeight-iEP3MaxHeight)/(iHeight-iEP3MinHeight) is the ratio we are shrinking all windows
		dAdjustHeight = (double)(iHeight-iEP3MaxHeight)/(iHeight-iEP3MinHeight); // shrink by this much
		break;
	default:
		WMASSERT(0);
		break;
	}

	AdjustReviewWindowHeight(dAdjustHeight, crArea.bottom, iAbsBottom, eTransition, lStimTop);

	ResizeAllReviewWindows();
#endif
}

void CWMApp::SetDemoMode(void)
{
	if(!IsCreated(IDD_DIALOG_MESSAGE_BOX))
	{
		if (CMessage::YesNo(WMFILELINE, 143)==IDYES) 
		{
			if(m_dMonitor.m_iDemoMode==DEMO_MODE_REPLAY)	// turn it off
			{	   
				m_vReview->ReplayButton( m_fReview->m_pSignalBar);
			}

			m_dMonitor.SetDemoMode(DEMO_MODE_CONT);

			m_dMonitor.LoadDemoEcg();
		} 
		else 
		{
			m_dMonitor.SetDemoMode(0);
		}

		m_dRF.m_bDemoMode=false;
 		
		m_dCathMap.StartCathMap();

		m_dMonitor.m_bZeroDisplay[0]=m_dMonitor.m_bZeroDisplay[1]=true;
		SetDemoIndicator();
	}
}

void CWMApp::SetDemoMode(const bool bDemoMode)
{
	if(bDemoMode) 
	{
		m_dMonitor.SetDemoMode(DEMO_MODE_CONT);

      m_dMonitor.LoadDemoEcg();
   }
	else 
	{
      m_dMonitor.SetDemoMode(0);
   }
 	
	m_dCathMap.StartCathMap();

	m_dMonitor.m_bZeroDisplay[0]=m_dMonitor.m_bZeroDisplay[1]=true;
	SetDemoIndicator();
}

void CWMApp::SetDemoIndicator(void)
{
	if(m_vRealTimeBar)
	{
		m_vRealTimeBar->SetDemoIndicator();
	}
}

bool CWMApp::CreateMainFrame(void)
{
	m_fMain = new CMainFrame;

	WMASSERT(m_fMain);
	if(m_fMain==NULL)
	{
		return false;
	}

	const UINT uiClassStyle = CS_HREDRAW | CS_VREDRAW;

	LPCTSTR szWndClass 
	 = AfxRegisterWndClass( uiClassStyle, 
									LoadStandardCursor(IDC_ARROW), 
									(HBRUSH)::GetStockObject(BLACK_BRUSH), 
									LoadIcon(IDR_WORKMATE) );
	WMASSERT(szWndClass);

	bool bCreated = false;

	if(szWndClass)
	{
		bCreated = true;
	}

	const DWORD dwStyle = /*WS_VISIBLE |*/ WS_CAPTION;

	bCreated = bCreated && ( m_fMain->Create(szWndClass, GETMESSAGE(855), dwStyle)==TRUE);

	if(!bCreated)
	{
		return false;
	}

	m_pMainWnd = m_fMain;

	ASSERT_VALID(m_pMainWnd);

	m_fMain->SetReverse(m_INIfile.m_bMouseRight?true:false);
	m_fMain->DrawScreenHeader();

	CWnd* pDesktopWnd = m_fMain->GetDesktopWindow();
	ASSERT_VALID(pDesktopWnd);
	if( pDesktopWnd)	
	{	
		CRect crFullScreen(0,0,0,0);
		pDesktopWnd->GetClientRect( &crFullScreen);	

#ifdef PHILIPS_VIEWER

		if(crFullScreen.Width()>2000)
		{
			crFullScreen.SetRect( PHILIPS_VIEWER_LEFT, PHILIPS_VIEWER_TOP, PHILIPS_VIEWER_RIGHT, PHILIPS_VIEWER_BOTTOM);
		}
		else
		{
			crFullScreen.SetRect( 0,	PHILIPS_VIEWER_TOP, CWMLibrary::GetDesktopWidth(), PHILIPS_VIEWER_BOTTOM	);
		}
	
#else

		/*if(!m_INIfile.m_bMouseRight)
		{
			crFullScreen.right=CWMLibrary::GetDesktopWidth();
		}
		else
		{
			crFullScreen.left=CWMLibrary::GetDesktopWidth();
		}*/
		
#endif

		m_fMain->MoveWindow(&crFullScreen);
	}

	m_fMain->Load();

	// The main window has been initialized, so show and update it.
	m_fMain->ShowWindow(SW_SHOW);
	m_fMain->UpdateWindow();

	return true;
}

void CWMApp::RestoreAllWindows(void)
{
	// Close All Windows No Matter what, including CathMap & DataBase
#ifndef PHILIPS_VIEWER
	m_fCathMap->ShowWindow(SW_HIDE);	
#endif

	if (this->m_fDB->IsWindowVisible()) {
		this->m_vDB->OnButtonClose();
		this->m_MainBar.m_btnDBCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	}
	this->GetDatabaseLock().DetachLock();
	
	m_fReview->ShowWindow(SW_HIDE);
	m_fPrevReview->ShowWindow(SW_HIDE);
	m_fRF->ShowWindow(SW_HIDE);
	m_fCine->ShowWindow(SW_HIDE);
	m_fMonitor->ShowWindow(SW_HIDE);
	m_fHolter->ShowWindow(SW_HIDE);
	m_fLog->ShowWindow(SW_HIDE);
	m_fChart->ShowWindow(SW_HIDE);
	m_fMapping->ShowWindow(SW_HIDE);
	m_fMeasurement->ShowWindow(SW_HIDE);
	
	bool bReview=false, bPrevReview=false, bMonitor=false;

	CRect crArea(0,0,0,0);

	for( register short iIndex=0; iIndex<eTotalWindows; ++iIndex)	
	{
		switch(iIndex)	
		{
			case	ePrevReview	:
			{	
				m_fPrevReview->ShowWindow(SW_HIDE);
				crArea = m_sAVIWndPos.crPrevReview;
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fPrevReview->MoveWindow(&crArea);
					m_fPrevReview->ShowWindow(SW_SHOW);
					bPrevReview=true;
				}
			}
			break;
			
			case	eHolter	:	
			{	
				crArea = m_sAVIWndPos.crHolter;
				m_fHolter->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fHolter->MoveWindow(&crArea);
					m_fHolter->ShowWindow(SW_SHOW);
				}
			}
			break;
			case	eMonitor	:
			{
				crArea = m_sAVIWndPos.crMonitor;
				m_fMonitor->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fMonitor->MoveWindow(&crArea);
					m_fMonitor->ShowWindow(SW_SHOW);

					if(m_INIfile.m_iAmplifierType==JUNCTION_BOX_24)
					{
						m_fMonitor->SetAmpBar();
					}
					bMonitor=true;
				}
			}
			break;

			case	eRealTime	:
			{
#ifdef WHY_DO_WE_NEED_THIS			
				crArea = m_sAVIWndPos.crRealTime;
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fRealTime->MoveWindow(&crArea);
					m_fRealTime->ShowWindow(SW_SHOW);
				}
#endif				
			}
			break;

			case	eRF		:
			{
				crArea = m_sAVIWndPos.crRF;
				m_fRF->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fRF->MoveWindow(&crArea);
					m_fRF->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eCine		:
			{
				crArea = m_sAVIWndPos.crCine;
				m_fCine->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fCine->MoveWindow(&crArea);
					m_fCine->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eMeasurement	:
			{
				crArea = m_sAVIWndPos2;
				m_fMeasurement->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fMeasurement->MoveWindow(&crArea);
					m_fMeasurement->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eLog		:
			{
				crArea = m_sAVIWndPos.crLog;
				m_fLog->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fLog->MoveWindow(&crArea);
					m_fLog->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eChart		:
			{
				crArea = m_sAVIWndPos.crLog;
				m_fChart->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fChart->MoveWindow(&crArea);
					m_fChart->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eMapping		:
			{
				crArea = m_sAVIWndPos.crMap;
				m_fMapping->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fMapping->MoveWindow(&crArea);
					m_fMapping->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eReview	:
			{
				crArea = m_sAVIWndPos.crReview;
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fReview->MoveWindow(&crArea);
					m_fReview->ShowWindow(SW_SHOW);
					bReview=true;
				}
			}
			break;
		}
	}

	ResizeAllReviewWindows();
	
	// set the two buttons for split
	m_MainBar.m_btnSplitCtl.SetBkColor((bReview && bPrevReview) ? NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND_HIGHLIGHT : NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnMonitorCtl.SetBkColor(bMonitor ? NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND_HIGHLIGHT : NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::RestoreWindowInfo()

	Description		:	This function restores all the frame windows in the 
							application from the cathmap database.

	Returns			:	None.

	Setup				:	None.

	Testing			:	1. Left mouse press on the 'Views' button on the MainBar.
							Verify the Views window displays.
							2. Select 'Review', 'Prev Review', 'Holter', 'RF' and 
							'Imaging' items from the list box. Verify the above mentioned 
							items are highlighted.
							3. Left mouse press on the 'OK' button. Verify the Views window
							closes. Verify all the selected windows display.
							4. Left mouse press on the 'Save' button on the MainBar. Verify 
							the 'Save Preferences' window displays. Verify the first item is
							selected.
							5. Left mouse press on the 'OK' button. Verify the 'Save Preferences' 
							window closes.
							6. Left mouse press on the 'Setup' button on the MainBar. Verify 
							the cathmap settings window displays.
							7. Left mouse press on the 'Save' button on the cathmap window. 
							Verify the 'Catheter Map Saved' message displays.
							8. Left mouse press on the 'Close Setup' button on the cathmap window. 
							Verify the 'cathmap window closes.
							9. Left mouse press on the maximize button on the Review screen. Verify 
							the full review screen displays. Verify all the other open windows close.
							10. Left mouse press on the 'Recall' button on the MainBar. Verify 
							the 'Recall Preferences' window displays.
							11. Left mouse press on the first item in the list box control. 
							Verify the 'Recall Preferences' window closes. Verify the 'Review', 
							'Prev Review', 'Holter', 'RF' and 'Imaging' windows display.


Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::RestoreWindowInfo(const short iPreference)
{
	// Close All Windows No Matter what, including CathMap & DataBase
#ifndef PHILIPS_VIEWER
	m_fCathMap->ShowWindow(SW_HIDE);
#endif

	if (this->m_fDB->IsWindowVisible()) {
		this->m_vDB->OnButtonClose();
		this->m_MainBar.m_btnDBCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	}
	this->GetDatabaseLock().DetachLock();
	
	m_fReview->ShowWindow(SW_HIDE);
	m_fPrevReview->ShowWindow(SW_HIDE);
	m_fRF->ShowWindow(SW_HIDE);
	m_fCine->ShowWindow(SW_HIDE);
	m_fMonitor->ShowWindow(SW_HIDE);
	m_fHolter->ShowWindow(SW_HIDE);
	m_fLog->ShowWindow(SW_HIDE);
	m_fChart->ShowWindow(SW_HIDE);
	m_fMapping->ShowWindow(SW_HIDE);
	m_fMeasurement->ShowWindow(SW_HIDE);
	
	bool bReview=false, bPrevReview=false, bMonitor=false;

	CRect crArea(0,0,0,0);

	for( register short iIndex=0; iIndex<eTotalWindows; ++iIndex)	
	{
		switch(iIndex)	
		{
			case	ePrevReview	:
			{	
				m_fPrevReview->ShowWindow(SW_HIDE);
				crArea = m_dCathMap.m_CathMap.arPreferences[iPreference].crPrevReview;
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fPrevReview->MoveWindow(&crArea);
					m_fPrevReview->ShowWindow(SW_SHOW);
					bPrevReview=true;
				}
			}
			break;
			
			case	eHolter	:	
			{	
				crArea = m_dCathMap.m_CathMap.arPreferences[iPreference].crHolter;
				m_fHolter->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fHolter->MoveWindow(&crArea);
					m_fHolter->ShowWindow(SW_SHOW);
				}
			}
			break;
			case	eMonitor	:
			{
				crArea = m_dCathMap.m_CathMap.arPreferences[iPreference].crMonitor;
				m_fMonitor->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fMonitor->MoveWindow(&crArea);
					m_fMonitor->ShowWindow(SW_SHOW);

					if(m_INIfile.m_iAmplifierType==JUNCTION_BOX_24)
					{
						m_fMonitor->SetAmpBar();
					}
					bMonitor=true;
				}
			}
			break;

			case	eRealTime	:
			{
#ifdef WHY_DO_WE_NEED_THIS			
				crArea = m_dCathMap.m_CathMap.arPreferences[iPreference].crRealTime;
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fRealTime->MoveWindow(&crArea);
					m_fRealTime->ShowWindow(SW_SHOW);
				}
#endif				
			}
			break;

			case	eRF		:
			{
				crArea = m_dCathMap.m_CathMap.arPreferences[iPreference].crRF;
				m_fRF->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fRF->MoveWindow(&crArea);
					m_fRF->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eCine		:
			{
				crArea = m_dCathMap.m_CathMap.arPreferences[iPreference].crCine;
				m_fCine->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fCine->MoveWindow(&crArea);
					m_fCine->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eMeasurement		:
			{
				crArea = m_dCathMap.m_CathMap.arPreferences[iPreference].crMeasure;
				m_fMeasurement->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fMeasurement->MoveWindow(&crArea);
					m_fMeasurement->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eLog		:
			{
				crArea = m_dCathMap.m_CathMap.arPreferences[iPreference].crLog;
				m_fLog->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fLog->MoveWindow(&crArea);
					m_fLog->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eChart		:
			{
				crArea = m_dCathMap.m_CathMap.arPreferences[iPreference].crChart;
				m_fChart->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fChart->MoveWindow(&crArea);
					m_fChart->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eMapping		:
			{
				crArea = m_dCathMap.m_CathMap.arPreferences[iPreference].crMap;
				m_fMapping->ShowWindow(SW_HIDE);
				if(!crArea.IsRectEmpty() )	
				{
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fMapping->MoveWindow(&crArea);
					m_fMapping->ShowWindow(SW_SHOW);
				}
			}
			break;

			case	eReview	:
			{
				crArea = m_dCathMap.m_CathMap.arPreferences[iPreference].crReview;
				if(!crArea.IsRectEmpty() )	
				{	
					if(m_INIfile.m_bMouseRight)
					{
						crArea.left+=m_iTotalScreenWidth;
						crArea.right+=m_iTotalScreenWidth;
					}
					m_fMain->ScreenToClient(&crArea);
					m_fReview->MoveWindow(&crArea);
					m_fReview->ShowWindow(SW_SHOW);
					bReview=true;
				}
			}
			break;
		}
	}

	ResizeAllReviewWindows();
	
	// set the two buttons for split
	m_MainBar.m_btnSplitCtl.SetBkColor((bReview && bPrevReview) ? NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND_HIGHLIGHT : NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnMonitorCtl.SetBkColor(bMonitor ? NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND_HIGHLIGHT : NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::SaveAllWindows()

	Description		:	This function saves the current positions all the frame 
							windows in the application.

	Returns			:	None.

	Setup				:	1. Open the Review, PrevReview, Holter, Abaltion and LOG 
							windows from the Views button on the MainBar.

	Testing			:	1. Left mouse button press on the 'Print' button on the 
							MainBar. Verify the printing window displays.
							2. Left mouse button press on the 'Preview' radio button. 
							Verify the control is marked. Verify the 'Review' item in
							the list box is selected.
							3. Left mouse button press on the 'Print' button. Verify 
							the print preview window displays. 
							4. Left mouse button press on the 'Close' button. Verify the
							print preview window closes. Verify the Review, PrevReview, 
							Holter, Abaltion and LOG windows are in the original position.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::SaveAllWindows(void)
{
	ZEROSET(m_sAVIWndPos);

	for(register short iIndex=0; iIndex<eTotalWindows; ++iIndex)	
	{
		PRECT				pArea	=	NULL;
		CMDIChildWnd*	pFrame=	NULL;

		switch(iIndex)	
		{
			case	ePrevReview	:
			{	
				pArea = &m_sAVIWndPos.crPrevReview;
				pFrame = m_fPrevReview;
			}
			break;
			
			case	eHolter	:	
			{	
				pArea = &m_sAVIWndPos.crHolter;
				pFrame = m_fHolter;
			}
			break;
			case	eMonitor	:
			{
				pArea = &m_sAVIWndPos.crMonitor;
				pFrame = m_fMonitor;
			}
			break;

			case	eRealTime	:
			{
#ifdef WHY_DO_WE_NEED_THIS
				pArea = &m_sAVIWndPos.crRealTime;
				pFrame = m_fRealTime;
#else
				pArea = NULL;
				pFrame= NULL;
#endif				
			}
			break;

			case	eRF		:
			{
				pArea = &m_sAVIWndPos.crRF;
				pFrame = m_fRF;
			}
			break;

			case	eCine		:
			{
				pArea = &m_sAVIWndPos.crCine;
				pFrame = m_fCine;
			}
			break;

			case	eMeasurement		:
			{
				pArea = &m_sAVIWndPos2;
				pFrame = m_fMeasurement;
			}
			break;

			case	eLog		:
			{
				pArea = &m_sAVIWndPos.crLog;
				pFrame = m_fLog;
			}
			break;

			case	eChart		:
			{
				//pArea = &m_sAVIWndPos.crChart;
				//pFrame = m_fChart;
			}
			break;

			case	eMapping	:
			{
				pArea = &m_sAVIWndPos.crMap;
				pFrame = m_fMapping;
			}
			break;

			case	eReview	:
			{
				pArea = &m_sAVIWndPos.crReview;
				pFrame = m_fReview;
			}
			break;
		}
	
		if(pFrame && pArea)
		{
			if( pFrame->IsWindowVisible() )	
			{
				pFrame->GetWindowRect(pArea);	
				if(m_INIfile.m_bMouseRight)
				{
					pArea->left-=m_iTotalScreenWidth;
					pArea->right-=m_iTotalScreenWidth;
				}
			}	
			else	
			{
				::SetRectEmpty(pArea);
			}
		}
	}
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::SaveWindowInfo()

	Description	:	This function saves the frame window positions into the cathmap.

	Returns		:	None

	Setup			:	1. Press the Views button on the Mainbar.
						2. Choose a few windows.
						3. After the windows are placed in a certain format, Press the Save button 
							and the preference.
						4. Close all the possible windows.

	Testing		:	1.	Press the Recall button and choose the saved preference. Verify all the 
							windows display in the saved format.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::SaveWindowInfo(const short iPreference)
{
	for(register short iIndex=0; iIndex<eTotalWindows; ++iIndex)	
	{
		PRECT				pArea	= NULL;
		CMDIChildWnd*	pFrame= NULL;

		switch(iIndex)	
		{
			case	ePrevReview	:
			{	
				pArea = &m_dCathMap.m_CathMap.arPreferences[iPreference].crPrevReview;
				pFrame = m_fPrevReview;
			}
			break;
			
			case	eHolter	:	
			{	
				pArea = &m_dCathMap.m_CathMap.arPreferences[iPreference].crHolter;
				pFrame = m_fHolter;
			}
			break;
			case	eMonitor	:
			{
				pArea = &m_dCathMap.m_CathMap.arPreferences[iPreference].crMonitor;
				pFrame = m_fMonitor;
			}
			break;

			case	eRealTime	:
			{
#ifdef WHY_DO_WE_NEED_THIS
				pArea = &m_dCathMap.m_CathMap.arPreferences[iPreference].crRealTime;
				pFrame= m_fRealTime;
#else
				pArea = NULL;
				pFrame= NULL;
#endif				
			}
			break;

			case	eRF		:
			{
				pArea = &m_dCathMap.m_CathMap.arPreferences[iPreference].crRF;
				pFrame = m_fRF;
			}
			break;

			case	eCine		:
			{
				pArea = &m_dCathMap.m_CathMap.arPreferences[iPreference].crCine;
				pFrame = m_fCine;
			}
			break;

			case	eMeasurement	:
			{
				pArea = &m_dCathMap.m_CathMap.arPreferences[iPreference].crMeasure;
				pFrame = m_fMeasurement;
			}
			break;

			case	eLog		:
			{
				pArea = &m_dCathMap.m_CathMap.arPreferences[iPreference].crLog;
				pFrame = m_fLog;
			}
			break;

			case	eChart		:
			{
				pArea = &m_dCathMap.m_CathMap.arPreferences[iPreference].crChart;
				pFrame = m_fChart;
			}
			break;

			case	eMapping	:
			{
				pArea = &m_dCathMap.m_CathMap.arPreferences[iPreference].crMap;
				pFrame = m_fMapping;
			}
			break;

			case	eReview	:
			{
				pArea = &m_dCathMap.m_CathMap.arPreferences[iPreference].crReview;
				pFrame = m_fReview;
			}
			break;
		}

		if(pArea && pFrame)
		{	
			if( pFrame->IsWindowVisible() )	
			{
				pFrame->GetWindowRect(pArea);	
				if(m_INIfile.m_bMouseRight)
				{
					pArea->left-=m_iTotalScreenWidth;
					pArea->right-=m_iTotalScreenWidth;
				}
			}
			else
			{
				::SetRectEmpty(pArea);
			}
		}
	}

	m_dCathMap.m_bCatheterMapChanges=true;
}

void CWMApp::ConvertSession(void)
{
#if 0
	m_dbSession.InitRecord();

	long TotalN=m_dbSession.CountAllRecords();

	if ( TotalN<1 ) return; // nothing to do

	short get_mode=GET_FIRST_RECN;
	long N;

	for( N=1, m_dbSession.m_usRecordNumber=0; N<=TotalN; N++) 
	{	
		// read in the next cathmap record
		m_dbSession.FreeRecord();

		USHORT i;
		// if this returns 0, its time to get out
		while ((i= m_dbSession.GetRecord(get_mode, LOCK_EDIT, 2637))!=0) 
		{
			if (i==DB_EOF) goto End;
			get_mode=GET_NEXT_RECN; // if it is set to GET_FROM_OFFSET, recN is set to 0 on failure
		}
		get_mode=GET_NEXT_RECN;

		// this is 3.1.X or DOS format and needs to be converted
		if ( m_dbSession.m_rhHeader.data_length<=63784 )
		{
			SSession140 sSession140={0};

			memcpy(&sSession140, &m_Session, sizeof(sSession140));

			memset(&m_Session, 0, sizeof(m_Session));

			memcpy(&m_Session, &sSession140, sizeof(sSession140));

			m_dbSession.PutRecord();
		}
	}

End:
	m_dbSession.SetVersion(SESSION_VERSION);

	CMessage::PopupMessage(WMFILELINE, 948);

	m_dbSession.InitRecord();
	m_dbSession.FreeRecord();
#endif
}

void CWMApp::InitDataBase(const bool bFirstTime)
{
	m_dPatient.InitDB();

	long lVersion = m_dProcedure.m_Access.InitDB(&m_dPatient.m_Access, 
																&m_dProcedure.m_Procedure, 
																sizeof(m_dProcedure.m_Procedure), 
																m_INIfile.m_szProcFileName, 
																0, 
																0, 
																NULL, 
																_T("Studies"), 
																PROCEDURE_VERSION);

	if(lVersion!=PROCEDURE_VERSION)
	{
		m_dProcedure.m_Access.SetVersion(PROCEDURE_VERSION);
		
		CString csMesg; csMesg.Format(_T("%s - %s"), m_INIfile.m_szProcFileName, GETMESSAGE(948));
		if(!bFirstTime)
		{
			CMessage::PopupMessage(WMFILELINE, csMesg);
		}
		else
		{
			CMessage::StartupMessage(WMFILELINE, 0, csMesg, true, true);
		}
	}

	lVersion = m_dbSession.InitDB(&m_dProcedure.m_Access, 
											&m_Session, 
											sizeof(m_Session), 
											m_INIfile.m_szSessionFileName, 
											0, 
											0, 
											NULL, 
											_T("RF Cycles"), 
											SESSION_VERSION);
	if(lVersion!=SESSION_VERSION)
	{
		m_dbSession.SetVersion(SESSION_VERSION);
		
		CString csMesg; csMesg.Format(_T("%s - %s"), m_INIfile.m_szSessionFileName, GETMESSAGE(948));
		if(!bFirstTime)
		{
			CMessage::PopupMessage(WMFILELINE, csMesg);
		}
		else
		{
			CMessage::StartupMessage(WMFILELINE, 0, csMesg, true, true);
		}
	}

	lVersion = m_dbProcedure2.InitDB(&m_dProcedure.m_Access, 
												&m_dProcedure.m_Procedure2, 
												sizeof(m_dProcedure.m_Procedure2), 
												m_INIfile.m_szOpnoteFileName, 
												0, 
												0, 
												NULL, 
												NULL, 
												PTDATA_VERSION);

	if(lVersion!=PTDATA_VERSION)
	{
		m_dbProcedure2.SetVersion(PTDATA_VERSION);
		
		CString csMesg; csMesg.Format(_T("%s - %s"), m_INIfile.m_szOpnoteFileName, GETMESSAGE(948));
		if(!bFirstTime)
		{
			CMessage::PopupMessage(WMFILELINE, csMesg);
		}
		else
		{
			CMessage::StartupMessage(WMFILELINE, 0, csMesg, true, true);
		}
	}

	lVersion = m_dMeas.m_Access.InitDB(&m_dProcedure.m_Access, 
													&m_dMeas.m_Measurement, 
													sizeof(m_dMeas.m_Measurement), 
													m_INIfile.m_szMeasFileName, 
													0, 
													0, 
													NULL, 
													NULL, 
													PTDATA_VERSION);

	if(lVersion!=PTDATA_VERSION)
	{
		m_dMeas.m_Access.SetVersion(PTDATA_VERSION);
		
		CString csMesg; csMesg.Format(_T("%s - %s"), m_INIfile.m_szMeasFileName, GETMESSAGE(948));
		if(!bFirstTime)
		{
			CMessage::PopupMessage(WMFILELINE, csMesg);
		}
		else
		{
			CMessage::StartupMessage(WMFILELINE, 0, csMesg, true, true);
		}
	}

#ifdef ALLURA_TSM
	lVersion = m_dbAllura.InitDB(&m_dProcedure.m_Access, 
											&m_sAllura, 
											sizeof(m_sAllura), 
											m_INIfile.m_szAlluraFileName, 
											0, 
											0, 
											NULL, 
											NULL, 
											PTDATA_VERSION);;

	if(lVersion!=PTDATA_VERSION)
	{
		m_dbAllura.SetVersion(PTDATA_VERSION);
		
		CString csMesg; csMesg.Format(_T("%s - %s"), m_INIfile.m_szAlluraFileName, GETMESSAGE(948));
		if(!bFirstTime)
		{
			CMessage::PopupMessage(WMFILELINE, csMesg);
		}
		else
		{
			CMessage::StartupMessage(WMFILELINE, 0, csMesg, true, true);
		}
	}
#endif

	lVersion = m_dbPrePost.InitDB(&m_dProcedure.m_Access, 
											&m_dProcedure.m_PrePost, 
											sizeof(m_dProcedure.m_PrePost), 
											m_INIfile.m_szPrePostFileName, 
											0, 
											0, 
											NULL, 
											NULL, 
											PTDATA_VERSION);

	if(lVersion!=PTDATA_VERSION)
	{
		m_dbPrePost.SetVersion(PTDATA_VERSION);
		
		CString csMesg; csMesg.Format(_T("%s - %s"), m_INIfile.m_szPrePostFileName, GETMESSAGE(948));
		if(!bFirstTime)
		{
			CMessage::PopupMessage(WMFILELINE, csMesg);
		}
		else
		{
			CMessage::StartupMessage(WMFILELINE, 0, csMesg, true, true);
		}
	}

	m_dPatient.m_Access.InitRecord();

	m_dMeas.m_Access.InitRecord();

	m_dCathMap.InitDB(bFirstTime);

	m_dbPhysician.InitDB(NULL, 
								&m_Doctor, 
								sizeof(m_Doctor), 
								m_INIfile.m_szDoctorFileName, 
								DOC_KEY1_LENGTH, 
								0, 
								_T("Physician"), 
								NULL, 
								DOCTOR_VERSION);

	m_dbPSpec.InitDB(	NULL, 
							&m_PacerSpec, 
							sizeof(m_PacerSpec), 
							m_INIfile.m_szPacerSpecFileName, 
							MFR_SIZE, 
							MODEL_SIZE, 
							_T("Pacemaker"), 
							NULL, 
							PSPEC_VERSION);

	m_dbLSpec.InitDB(	NULL, 
							&m_LeadSpec, 
							sizeof(m_LeadSpec), 
							m_INIfile.m_szLeadSpecFileName, 
							MFR_SIZE, 
							MODEL_SIZE, 
							_T("Lead"), 
							NULL, 
							LSPEC_VERSION);

	m_dbICD.InitDB(NULL, 
						&m_ICDSpec, 
						sizeof(m_ICDSpec), 
						m_INIfile.m_szICDSpecFileName, 
						MFR_SIZE, 
						MODEL_SIZE, 
						_T("ICD"), 
						NULL, 
						ICD_VERSION);

	m_dbLogin.InitDB(	NULL, 
							&m_sLogin, 
							sizeof(m_sLogin), 
							m_INIfile.m_szSecurityFileName, 
							LOGIN_USER_NAME_LENGTH, 
							0, 
							_T("Login"), 
							NULL, 
							LOGIN_VERSION);

	//m_dbDBView.InitDB(NULL, &m_sDBView, sizeof(m_sDBView), m_INIfile.m_szDBViewsPath, DBVIEW_NAME_LENGTH, 0, _T("DBVIEWS"), NULL, DBVIEWS_VERSION);
	//m_dbDBView.InitRecord();

	m_INIfile.m_usSecurityLevel=MAXWORD;
}

bool CWMApp::OpticalCheck(void)
{ 
   // first check the hard drive and exit if it is there

   ::WMStrnCpy(m_INIfile.m_szLogDirName, m_INIfile.m_szLogDirNameCpy, sizeof(m_INIfile.m_szLogDirName));
	
	TCHAR szFullPath[MAX_PATH]={0};	
   for(register short iDriveN=0; iDriveN<m_INIfile.m_iNumberHardDrives; ++iDriveN)
	{
      if( CFileDB::IsExists(m_dLog.MakeLogName(m_szBaseLogName, szFullPath, sizeof(szFullPath)))) 
		{
			return true;
		}

      m_INIfile.m_szLogDirName[0]++;
   }

	for(register short iIndex=0; iIndex<MAX_ARCHIVE_PATH; ++iIndex)
	{
		if(m_INIfile.m_szArchivePath[iIndex][0])
		{
			// not check all the opticals and exit if it is there
			::WMStrnCpy(m_INIfile.m_szLogDirName, m_INIfile.m_szArchivePath[iIndex], sizeof(m_INIfile.m_szLogDirName));

			TCHAR	szPath[MAX_PATH]={0};
			_stprintf(	szPath, 
						_T("%s\\LOG_DHR%lu_%8.8lx"),
						m_INIfile.m_szLogDirName, 
						m_dLog.m_dwCurDHR,
						m_dLog.m_lCurrentLogDirNumber);
			
			CFileDB::MakeFileName(szPath, m_szBaseLogName, szFullPath, sizeof(szFullPath));
			
			if(CFileDB::IsExists(szFullPath)) 
			{
				return true;
			}
		}
   }

	// why keep looking if it has never been archived
	if( !m_dProcedure.m_Procedure.tape_name[0]) 
	{
		::WMStrnCpy(m_INIfile.m_szLogDirName, 
						m_INIfile.m_szLogDirNameCpy, 
						sizeof(m_INIfile.m_szLogDirName));

		return false; // from the while loop after resetting the m_INIfile.m_szLogDirName
	}

	while( CMessage::YesNo(WMFILELINE, 218, CA2T((PCHAR)m_dProcedure.m_Procedure.tape_name))==IDYES) 
	{
		for(register short iIndex=0; iIndex<MAX_ARCHIVE_PATH; ++iIndex)
		{
			if(m_INIfile.m_szArchivePath[iIndex][0])
			{
				// not check all the opticals and exit if it is there
				::WMStrnCpy(m_INIfile.m_szLogDirName, 
								m_INIfile.m_szArchivePath[iIndex], 
								sizeof(m_INIfile.m_szLogDirName));

				TCHAR	szPath[MAX_PATH]={0}; 
				m_dLog.MakeLogName(szPath, sizeof(szPath));

				if(CFileDB::IsExists(CFileDB::MakeFileName(szPath, m_szBaseLogName, szFullPath, sizeof(szFullPath)))) 
				{
					return true;
				}
			}
		}
	}

   ::WMStrnCpy(m_INIfile.m_szLogDirName, 
					m_INIfile.m_szLogDirNameCpy, 
					sizeof(m_INIfile.m_szLogDirName));

   return false;
}

void CWMApp::CheckDate(void)
{
	CFileStatus fsStatus;
	
	CFile::GetStatus( m_dPatient.m_Access.m_szDataFileName, fsStatus);
    CTime curTime = CDateTime::GetLocalTime();
	//CString s = fsStatus.m_ctime.Format( "%Y/%m/%d, %H:%M:%S --%x" );
	//CString cur = curTime.Format("%Y/%m/%d, %H:%M:%S --%x" );

	if( fsStatus.m_mtime>curTime ) 
	{
		SetDateTime();
	}
}

bool CWMApp::SetDateTime(void)
{
	CDateTimePickDialog dtpDialog(AfxGetMainWnd());

	if(dtpDialog.DoModal()!=IDOK)
	{
		return false;
	}

	CTime& ctDate = dtpDialog.m_ctDate;

	CTime& ctTime = dtpDialog.m_ctTime;

	CString csTime = ctTime.Format(_T("%H:%M:%S"));

	AfxTrace( csTime );

	CDateTime::SetSystemTime(ctDate.GetMonth(), 
									 ctDate.GetDay(), 
									 ctDate.GetYear(), 
									 ctTime.GetHour(), 
									 ctTime.GetMinute(), 
									 ctTime.GetSecond() );

	return true;
}

//	This function inputs the procedure from the PROC file in the LOG directory passed.  It stores the patient to the database using PutRecord().
void CWMApp::ImportProcFromLog( LPCTSTR szPath )
{
	TCHAR szFullPath[MAX_PATH]={0};
	short iVersion = CWMLibrary::GetRecordVersionFromLog(CFileDB::MakeFileName(szPath, 
																										m_szImportProcName, 
																										szFullPath, 
																										sizeof(szFullPath)));

	if( iVersion > -1 ) 
	{
      m_dProcedure.m_Access.FreeRecord();
		m_dProcedure.m_Access.InitRecord();
		CWMLibrary::GetRecordFromLog( CFileDB::MakeFileName(szPath, m_szImportProcName, szFullPath, sizeof(szFullPath)),	
												&m_dProcedure.m_Procedure, 
												sizeof(m_dProcedure.m_Procedure));
		CWMLibrary::GetRecordFromLog( CFileDB::MakeFileName(szPath, m_szImportOpnoteName, szFullPath, sizeof(szFullPath)),
												&m_dProcedure.m_Procedure2, 
												sizeof(m_dProcedure.m_Procedure2));
#ifdef ALLURA_TSM
		CWMLibrary::GetRecordFromLog( CFileDB::MakeFileName(szPath, m_szImportAlluraName, szFullPath, sizeof(szFullPath)),
												&m_sAllura, 
												sizeof(m_sAllura));
#endif
		CWMLibrary::GetRecordFromLog( CFileDB::MakeFileName(szPath, m_szImportMeasName,	szFullPath, sizeof(szFullPath)),	
												&m_dMeas.m_Measurement, 
												sizeof(m_dMeas.m_Measurement));
		CWMLibrary::GetRecordFromLog( CFileDB::MakeFileName(szPath, m_szImportPrePostName, szFullPath, sizeof(szFullPath)),
												&m_dProcedure.m_PrePost, 
												sizeof(m_dProcedure.m_PrePost));

		m_dProcedure.m_Access.m_usRecordNumber = 0; // Don't store over someone else.

   	if(iVersion!=PROCEDURE_VERSION)
		{
			m_dProcedure.ConvertProcedure(iVersion);

			// now it wont have to be converted again below
			CWMLibrary::StoreRecordToLog( CFileDB::MakeFileName(szPath, m_szImportProcName, szFullPath, sizeof(szFullPath)), 
													&m_dProcedure.m_Procedure, 
													sizeof(m_dProcedure.m_Procedure),
													PROCEDURE_VERSION);
			CWMLibrary::StoreRecordToLog( CFileDB::MakeFileName(szPath, m_szImportOpnoteName, szFullPath, sizeof(szFullPath)), 
													&m_dProcedure.m_Procedure2, 
													sizeof(m_dProcedure.m_Procedure2),
													PTDATA_VERSION);
#ifdef ALLURA_TSM
			CWMLibrary::StoreRecordToLog( CFileDB::MakeFileName(szPath, m_szImportAlluraName, szFullPath, sizeof(szFullPath)), 
													&m_sAllura, 
													sizeof(m_sAllura),
													PTDATA_VERSION);
#endif
			CWMLibrary::StoreRecordToLog( CFileDB::MakeFileName(szPath, m_szImportMeasName, szFullPath, sizeof(szFullPath)), 
													&m_dMeas.m_Measurement, 
													sizeof(m_dMeas.m_Measurement),
													PTDATA_VERSION);
			CWMLibrary::StoreRecordToLog( CFileDB::MakeFileName(szPath, m_szImportPrePostName, szFullPath, sizeof(szFullPath)), 
													&m_dProcedure.m_PrePost, 
													sizeof(m_dProcedure.m_PrePost),
													PTDATA_VERSION);
		}

		TCHAR	szProcedureDate[DATE_SIZE]={0};	
		CDateTime::ConvDate(szProcedureDate, DD_MMM_YYYY, CA2T((PCHAR)m_dProcedure.m_Procedure.date), 0.0);

		// search the current patient for a procedure date and log dir that match
		long lProcLogDir = m_dProcedure.m_Procedure.log_dir_number;

		TCHAR	szTapeName[_countof(m_dProcedure.m_Procedure.tape_name)] = { 0 };
		::WMStrnCpy(szTapeName, CA2T((PCHAR)m_dProcedure.m_Procedure.tape_name), sizeof(szTapeName));

		for( register short iIndex = 1; iIndex <= m_dProcedure.m_Access.m_pList->total_recN; iIndex++ ) 
		{
			m_dProcedure.m_Access.m_pList->temp_recN = iIndex;

			TCHAR	szDate[DATE_SIZE]={0};
			CDateTime::ConvDate(szDate, DD_MMM_YYYY, CA2T((PCHAR)m_dProcedure.m_Access.m_pList->date2[iIndex]), 0.0);

			// if same date
			if(memcmp(szDate, szProcedureDate, sizeof(szProcedureDate))==0)
			{
				m_dProcedure.m_Access.m_usRecordNumber = m_dProcedure.m_Access.m_pList->perm_recs[iIndex];

				m_dProcedure.m_Access.GetRecord(GET_FROM_RECN, 0, 9999);

				if(m_dProcedure.m_Procedure.log_dir_number==lProcLogDir)
				{
         		m_dbProcedure2.GetRecord(GET_FROM_PARENT, 0, 9999);

         		m_dMeas.m_Access.GetRecord(GET_FROM_PARENT, 0, 9999);

#ifdef ALLURA_TSM
					m_dbAllura.GetRecord(GET_FROM_PARENT, 0, 9999);
#endif
					m_dbPrePost.GetRecord(GET_FROM_PARENT, 0, 9999);

					break;
				}
				else
				{
					// its not the right one but reload as the data is gone now
					m_dProcedure.m_Access.m_usRecordNumber = 0;
				}
			}
		}

		CWMLibrary::GetRecordFromLog( CFileDB::MakeFileName(szPath, m_szImportProcName, szFullPath, sizeof(szFullPath)), 
												&m_dProcedure.m_Procedure, 
												sizeof(m_dProcedure.m_Procedure));

		memcpy(m_dProcedure.m_Access.m_rhHeader.date, 
				 m_dProcedure.m_Procedure.date, 
				 sizeof(m_dProcedure.m_Access.m_rhHeader.date));

		m_dProcedure.m_Access.m_rhHeader.master_record = m_dPatient.m_Access.m_usRecordNumber;

		::strncpy((PCHAR)m_dProcedure.m_Procedure.tape_name,
						CT2A(szTapeName), 
						ARRAY_SIZE(m_dProcedure.m_Procedure.tape_name));

		m_dProcedure.m_Access.PutRecord(); // this initializes all subordinates

		CWMLibrary::GetRecordFromLog( CFileDB::MakeFileName(szPath, m_szImportOpnoteName, szFullPath, sizeof(szFullPath)), 
												&m_dProcedure.m_Procedure2, 
												sizeof(m_dProcedure.m_Procedure2));
		m_dbProcedure2.PutRecord();

		CWMLibrary::GetRecordFromLog( CFileDB::MakeFileName(szPath, m_szImportMeasName, szFullPath, sizeof(szFullPath)), 
												&m_dMeas.m_Measurement, 
												sizeof(m_dMeas.m_Measurement));
		m_dMeas.m_Access.PutRecord();

#ifdef ALLURA_TSM
		CWMLibrary::GetRecordFromLog( CFileDB::MakeFileName(szPath, m_szImportAlluraName, szFullPath, sizeof(szFullPath)), 
												&m_sAllura, 
												sizeof(m_sAllura));

		m_dbAllura.PutRecord();
#endif

		CWMLibrary::GetRecordFromLog( CFileDB::MakeFileName(szPath, m_szImportPrePostName, szFullPath, sizeof(szFullPath)), 
												&m_dProcedure.m_PrePost, 
												sizeof(m_dProcedure.m_PrePost));
		m_dbPrePost.PutRecord();

		ImportSessionFromLog( szPath ); // this stores it to the DB as well
	}
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::ImportSessionFromLog()

	Description	:	This function reads the session file from the current log 
						directory. It checks for the version and converts the session 
						structure to the current one. Once the session is read it 
						stores it to the current database.

	Returns		:	None

	Setup			:	1. Create a new study.
						2. Create a few RF ablations cycles.
						3. Close the study.

	Testing		:	1. Load the study again and verify the RF ablation cycles are 
							loaded.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::ImportSessionFromLog( LPCTSTR szPath )
{
	// don't bother bringing in sessions if they are already defined for the current procedure
	if(m_dbSession.m_pList->total_recN!=0)
	{
		return;
	}

#ifdef PHILIPS_VIEWER
	m_dbSession.m_pList->temp_recN = 1;
#endif

	CFileDB	cfdFile;

	try	
	{	
		TCHAR szFullPath[MAX_PATH]={0};
		if( !cfdFile.Open( CFileDB::MakeFileName(	szPath, 
																m_szImportSessionName, 
																szFullPath, 
																sizeof(szFullPath)), 
								OPF_READ, 
								9999, 
								ON_ERROR_RETURN )) 
		{
			CString csErrorMessage; csErrorMessage.Format(_T("%s\\%s"), szPath, m_szImportSessionName);
			CMessage::PopupMessage(WMFILELINE, 7, 2000, csErrorMessage );
			return;
		}

		short	iVersion=0;
		cfdFile.Read( &iVersion, sizeof(iVersion) );

		m_dbSession.InitRecord();

		if(iVersion!=SESSION_VERSION)
		{
			switch(iVersion)
			{
				case 140	:
				{
					SSession140 sSession140={0};

					while( cfdFile.Read( &sSession140, sizeof(sSession140) )==sizeof(sSession140) )
					{
						memcpy(&m_Session, &sSession140, sizeof(sSession140));

						m_dbSession.m_usRecordNumber = 0; // don't store over someone else

						m_dbSession.m_rhHeader.master_record = m_dPatient.m_Access.m_usRecordNumber;

						m_dbSession.PutRecord();

#ifdef PHILIPS_VIEWER
						++m_dbSession.m_pList->total_recN;
#endif
					}
				}
				break;

				case 150:
				{
					SSession150 sSession150={0};

					while( cfdFile.Read( &sSession150, sizeof(sSession150) )==sizeof(sSession150) )
					{
						memcpy(&m_Session, &sSession150, sizeof(sSession150));

						m_dbSession.m_usRecordNumber = 0; // don't store over someone else

						m_dbSession.m_rhHeader.master_record = m_dPatient.m_Access.m_usRecordNumber;

						m_dbSession.PutRecord();
#ifdef PHILIPS_VIEWER
						++m_dbSession.m_pList->total_recN;
#endif

					}
				}
				break;
				
				case 160:
				{
					SSession160 sSession160={0};

					while( cfdFile.Read( &sSession160, sizeof(sSession160) )==sizeof(sSession160) )
					{
						m_Session.entry_count					= sSession160.entry_count;
						m_Session.total_session_time			= sSession160.total_session_time;
						m_Session.power_avg				= sSession160.power_avg;
						m_Session.power_max				= sSession160.power_max;
						m_Session.distaltemp_avg		= sSession160.temp_avg;
						m_Session.distaltemp_max		= sSession160.temp_max;
						m_Session.imp_avg				= sSession160.imp_avg;
						m_Session.imp_max				= sSession160.imp_max;
						m_Session.time					= sSession160.time; 
						::strncpy((PCHAR)m_Session.comment, (PCHAR)sSession160.comment, ARRAY_SIZE(m_Session.comment));
						m_Session.comm_error			= sSession160.comm_error;
						m_Session.result_calc			= sSession160.result_calc;
						::strncpy((PCHAR)m_Session.site, (PCHAR)sSession160.site, ARRAY_SIZE(m_Session.site));
						m_Session.success				= sSession160.success;
						m_Session.rf_generator			= sSession160.rf_generator;
						m_Session.file_number			= sSession160.file_number;
						m_Session.ecg_file_position	= sSession160.ecg_file_position;
						m_Session.log_time				= sSession160.log_time;
						m_Session.proximaltemp_avg	= sSession160.entry2.temp_avg2;
						m_Session.proximaltemp_max	= sSession160.entry2.temp_max2;
						m_Session.cryo_count			= sSession160.entry2.cryo_count;
										
						for(short iEntry=0; iEntry<sSession160.entry_count;++iEntry)
						{
							m_Session.entry[iEntry].time = sSession160.entry[iEntry].time;
							m_Session.entry[iEntry].power= sSession160.entry[iEntry].power;
							m_Session.entry[iEntry].distaltemp= sSession160.entry[iEntry].temp;		
							m_Session.entry[iEntry].current = sSession160.entry[iEntry].current;
							m_Session.entry[iEntry].volts = sSession160.entry[iEntry].volts;		
							m_Session.entry[iEntry].imp = sSession160.entry[iEntry].imp;								
							m_Session.entry[iEntry].proximaltemp= sSession160.entry2.temp[iEntry];																												
						}
												
						m_Session.energy = m_dRF.CalcEnergy();						

						m_dbSession.m_usRecordNumber = 0; // don't store over someone else

						m_dbSession.m_rhHeader.master_record = m_dPatient.m_Access.m_usRecordNumber;

						m_dbSession.PutRecord();
#ifdef PHILIPS_VIEWER
						++m_dbSession.m_pList->total_recN;
#endif

					}
				}
				break;
				
				case 170:
				{
					SSession170 sSession170={0};

					while( cfdFile.Read( &sSession170, sizeof(sSession170) )==sizeof(sSession170) )
					{
						m_Session.entry_count			= sSession170.entry_count;
						m_Session.total_session_time	= sSession170.total_session_time;
						m_Session.power_avg				= sSession170.power_avg;
						m_Session.power_max				= sSession170.power_max;
						m_Session.distaltemp_avg		= sSession170.distaltemp_avg;
						m_Session.distaltemp_max		= sSession170.distaltemp_max;
						m_Session.imp_avg					= sSession170.imp_avg;
						m_Session.imp_max					= sSession170.imp_max;
						m_Session.time						= sSession170.time; 
						::strncpy((PCHAR)m_Session.comment, (PCHAR)sSession170.comment, ARRAY_SIZE(m_Session.comment));
						m_Session.comm_error				= sSession170.comm_error;
						m_Session.result_calc			= sSession170.result_calc;
						::strncpy((PCHAR)m_Session.site, (PCHAR)sSession170.site, ARRAY_SIZE(m_Session.site));
						m_Session.success					= sSession170.success;
						m_Session.rf_generator			= sSession170.rf_generator;
						m_Session.file_number			= sSession170.file_number;
						m_Session.ecg_file_position	= sSession170.ecg_file_position;
						m_Session.log_time				= sSession170.log_time;
						m_Session.proximaltemp_avg		= sSession170.proximaltemp_avg;
						m_Session.proximaltemp_max		= sSession170.proximaltemp_max;
						m_Session.cryo_count				= sSession170.cryo_count;

						for(short iEntry=0; iEntry<sSession170.entry_count;++iEntry)
						{
							m_Session.entry[iEntry].time	= sSession170.entry[iEntry].time;
							m_Session.entry[iEntry].power	= sSession170.entry[iEntry].power;
							m_Session.entry[iEntry].distaltemp= sSession170.entry[iEntry].distaltemp;
							m_Session.entry[iEntry].current	= sSession170.entry[iEntry].current;
							m_Session.entry[iEntry].volts		= sSession170.entry[iEntry].volts;		
							m_Session.entry[iEntry].imp		= sSession170.entry[iEntry].imp;								
							m_Session.entry[iEntry].proximaltemp= sSession170.entry[iEntry].proximaltemp;																																		
						}
																		
						m_Session.energy = m_dRF.CalcEnergy();

						m_dbSession.m_usRecordNumber = 0; // don't store over someone else

						m_dbSession.m_rhHeader.master_record = m_dPatient.m_Access.m_usRecordNumber;

						m_dbSession.PutRecord();
#ifdef PHILIPS_VIEWER
						++m_dbSession.m_pList->total_recN;
#endif
					}
				}
				break;				
			}
		}
		else 
		{
			while( cfdFile.Read( &m_Session, sizeof(m_Session) )==sizeof(m_Session) ) 
			{
				m_dbSession.m_usRecordNumber = 0; // don't store over someone else

				m_dbSession.m_rhHeader.master_record = m_dPatient.m_Access.m_usRecordNumber;

				m_dbSession.PutRecord();

#ifdef PHILIPS_VIEWER
				++m_dbSession.m_pList->total_recN;
#endif
			}
		}

		cfdFile.Close();

	}
	catch(CFileException* pErr)
	{
		CWMLibrary::ReportError(pErr); 
		cfdFile.Close();
	}
}

int CWMApp::LogDir(PTCHAR szFullPath, 
				   SLogDir* const parldLogDir, 
				   const int iMaxLogDirN, 
				   const short iNumberDrives, 
				   const short iPathN,
				   bool bContinueCaseFilter)
{ 
	TCHAR szPath[MAX_PATH]={0};
	CWMLibrary::FindPath(szFullPath, 
		szPath, 
		sizeof(szPath));

	CFileFind cffFind;

	int iLogDirN=0;
	int iLogDirFill=0;
	SLogDir tempLogDir;
    CDateTime::Comparator timeComparator;

	for(register short iDriveN=0; iDriveN<iNumberDrives; ++iDriveN) 
	{
		::memset(&tempLogDir, 0, sizeof(SLogDir));
		szPath[0]=(TCHAR)(iDriveN+szFullPath[0]);

		TCHAR szLogPattern[MAX_PATH]={0};
		if( cffFind.FindFile( CFileDB::MakeFileName(	szPath, 
			_T("LOG*."),
			szLogPattern, 
			sizeof(szLogPattern)) ) )
		{
			BOOL find_file=TRUE;

			while (find_file && iLogDirN<iMaxLogDirN)
			{
				find_file=cffFind.FindNextFile();

				::strncpy((PCHAR)tempLogDir.file_name,
					CT2A(cffFind.GetFileName()), 
					ARRAY_SIZE(parldLogDir[0].file_name));

				TCHAR szLogDirPath[MAX_PATH] = { 0 };
				CFileDB::MakeFileName(szPath, 
					CA2T((PCHAR)tempLogDir.file_name), 
					szLogDirPath,
					sizeof(szLogDirPath));

				WMStrnCpy((PCHAR)tempLogDir.dir_name, CT2A(szLogDirPath), sizeof(tempLogDir.dir_name));

				tempLogDir.iPathN = iPathN + iDriveN;

				TCHAR szMasterPath[MAX_PATH]={0};
				CFileDB::MakeFileName(CA2T((PCHAR)tempLogDir.dir_name),
					_T("MASTER"), 
					szMasterPath, 
					sizeof(szMasterPath));

				// if there are no signal files and no master, delete the dir
				if (CWMLibrary::CanDeleteLogFolder(CA2T((PCHAR)tempLogDir.dir_name)))
				{
					CFileDB::DeleteDirectory(CA2T((PCHAR)tempLogDir.dir_name));
				} 
				else
				{
					if( CFileDB::IsExists( szMasterPath ) ) 
					{
						short iVersion=0;

						CFileStream cfsFile;

						TCHAR szDirPath[MAX_PATH]={0};
						CFileDB::MakeFileName(CA2T((PCHAR)tempLogDir.dir_name),
							m_szImportMasterName, 
							szDirPath, 
							sizeof(szDirPath));
						if( cfsFile.Open(szDirPath, _T("rb")) )
						{
							cfsFile.Read(&iVersion, sizeof(short));

							SPatient sPatient={0};
							cfsFile.Read(&sPatient, sizeof(sPatient));
							cfsFile.Close();

							CWMArchive::ConvertMaster(iVersion, sPatient);

							if(::strlen((PCHAR)sPatient.name)) // Support for icelandic characters
							{
								::strncpy((PCHAR)tempLogDir.name, (PCHAR)sPatient.name, ARRAY_SIZE(tempLogDir.name));
								::strncpy((PCHAR)tempLogDir.id  , (PCHAR)sPatient.id  , ARRAY_SIZE(tempLogDir.id  ));

								SProcedure sProcedure={0};
								TCHAR szProcedurePath[MAX_PATH]={0};
								CFileDB::MakeFileName(CA2T((PCHAR)tempLogDir.dir_name),
									m_szImportProcName, 
									szProcedurePath, 
									sizeof(szProcedurePath));

								tempLogDir.date[0]=0;
								tempLogDir.time=0;
								bool bKeep=true;
								if( cfsFile.Open(szProcedurePath, _T("rb")) )
								{
									cfsFile.Read(&iVersion, sizeof(short));
									cfsFile.Read(&sProcedure, sizeof(sProcedure));
									cfsFile.Close();
									bKeep = !bContinueCaseFilter || 
                                            timeComparator.IsWithinPast(sProcedure, 24, 0, 0);
									TCHAR szDate[DATE_SIZE] = { 0 };
									CDateTime::ConvDate(szDate, MM_DD_YYYY, CA2T((PCHAR)sProcedure.date), 0.0);
									::strncpy((PCHAR)tempLogDir.date, CT2A(szDate), ARRAY_SIZE(tempLogDir.date));
									tempLogDir.time=sProcedure.time;
								} 
								if ( bKeep )// copy to output list
								{
									parldLogDir[iLogDirFill++] = tempLogDir;
								}
								iLogDirN++;
							}
							else	// There is no patient in the MASTER 
							{
								// Check for the signals

								if( CWMLibrary::CanDeleteLogFolder(CA2T((PCHAR)tempLogDir.dir_name)) )
								{
									CFileDB::DeleteDirectory(CA2T((PCHAR)tempLogDir.dir_name));
								}
							}
						}
					}
				}
			}
		}
	}

	if(iLogDirFill)
	{
		QuickPatientNameSort(parldLogDir, iLogDirFill, sizeof(SLogDir), KEY1_LENGTH);
	}

	return iLogDirFill;
}

int CWMApp::LogDirHD(SLogDir* const parldLogDir, const int iMaxLogDirN, bool bContinueCaseFilter)
{
	int log_dirN = 0;

	//CWMPopupWindow* pMessage = new CWMPopupWindow;
//	if(pMessage)	{	pMessage->ShowMessage(GETMESSAGE(221), 5000, false);	}

	log_dirN += LogDir(m_INIfile.m_szLogDirNameCpy, 
							 parldLogDir, 
							 iMaxLogDirN, 
							 m_INIfile.m_iNumberHardDrives, 
							 1000, 
							 bContinueCaseFilter);

	//if(pMessage)	{	pMessage->Hide(pMessage);	}

	return log_dirN;
}

void CWMApp::FixOpticals(void)
{ 
	SLogDir ldLogDir[MAX_LOG_DIR_ITEMS]={0};

	int log_dirN = LogDirHD(ldLogDir, MAX_LOG_DIR_ITEMS, false);

	int log_dirN2 = CWMArchive::RetrievePatientsFromArchive(&ldLogDir[log_dirN], MAX_LOG_DIR_ITEMS-log_dirN);

	log_dirN += log_dirN2;

	if (log_dirN2<=0)
	{
		return;
	}

	SPatient	sPatient	=	{0};
	SProcedure	sProcedure	=	{0};
	SProcedure2	sProcedure2	=	{0};
	SMeasure	sMeasure	=	{0};
	SPrePost	sPrePost	=	{0};

	int iTotalFixed = 0;

	for (int i=0; i < log_dirN; i++)
	{
		CFileDB		cfdLogFile;
		bool			bLogHeader = false;
		SLogHeader	sLogHeader = {0};
		TCHAR			szLogPath[MAX_PATH]={0};

		CFileDB::MakeFileName(CA2T((PCHAR)ldLogDir[i].dir_name), _T("entries.log"), szLogPath, sizeof(szLogPath));

		if( cfdLogFile.Open( szLogPath, OPF_READ, 9999, ON_ERROR_RETURN) ) 
		{
			if (cfdLogFile.Read( &sLogHeader, sizeof(sLogHeader) ) == sizeof(sLogHeader)) bLogHeader=true;
			cfdLogFile.Close();
		}

		TCHAR		szMasterPath[MAX_PATH]={0};
		short iVersion;
		CFileDB::MakeFileName(CA2T((PCHAR)ldLogDir[i].dir_name), m_szImportMasterName, szMasterPath, sizeof(szMasterPath));
		iVersion = CWMLibrary::GetRecordFromLog( szMasterPath, &sPatient, sizeof(sPatient) );

		TCHAR szProcedurePath[MAX_PATH]={0};
		short iVersion2;
		CFileDB::MakeFileName(CA2T((PCHAR)ldLogDir[i].dir_name), m_szImportProcName, szProcedurePath, sizeof(szProcedurePath));
		iVersion2 = CWMLibrary::GetRecordFromLog( szProcedurePath, &sProcedure, sizeof(sProcedure) );

		TCHAR szOpnotePath[MAX_PATH]={0};
		short iVersion3;
		CFileDB::MakeFileName(CA2T((PCHAR)ldLogDir[i].dir_name), m_szImportOpnoteName, szOpnotePath, sizeof(szOpnotePath));
		iVersion3 = CWMLibrary::GetRecordFromLog( szOpnotePath, &sProcedure2, sizeof(sProcedure2) );

		TCHAR szMeasPath[MAX_PATH]={0};
		short iVersion4;
		CFileDB::MakeFileName(CA2T((PCHAR)ldLogDir[i].dir_name), m_szImportMeasName, szMeasPath, sizeof(szMeasPath));
		iVersion4 = CWMLibrary::GetRecordFromLog( szMeasPath, &sMeasure, sizeof(sMeasure) );

		TCHAR szPrePostPath[MAX_PATH]={0};
		short iVersion5;
		CFileDB::MakeFileName(CA2T((PCHAR)ldLogDir[i].dir_name), m_szImportPrePostName, szPrePostPath, sizeof(szPrePostPath));
		iVersion5 = CWMLibrary::GetRecordFromLog( szPrePostPath, &sPrePost, sizeof(sPrePost) );

		CWMArchive::ConvertMaster(iVersion, sPatient);
		m_dProcedure.ConvertProcedure(iVersion2, sProcedure, sProcedure2, sMeasure, sPrePost);

		TCHAR szDate1[DATE_SIZE] = {0}, szDate2[DATE_SIZE] = {0};
		CDateTime::ConvDate(szDate1, DD_MMM_YYYY, CA2T((PCHAR)sLogHeader.szDate), 0.0f);
		CDateTime::ConvDate(szDate2, DD_MMM_YYYY, CA2T((PCHAR)sProcedure.date), 0.0f);
		long lLogDirNumber = 0;
		_stscanf(CA2T((PCHAR)ldLogDir[i].file_name+3), _T("%x"), &lLogDirNumber);

		if ( !sProcedure.date[0] ||
			  lLogDirNumber != sProcedure.log_dir_number ||
			  !sProcedure.time )
		{
			iTotalFixed++;

			TCHAR szMOPath[MAX_PATH]={0};
			CWMLibrary::FindPath(CA2T((PCHAR)ldLogDir[i].dir_name), szMOPath, sizeof(szMOPath));

			CFileDB cfdLogFile;
			TCHAR szFullPath[MAX_PATH]={0};

			if(cfdLogFile.Open(CFileDB::MakeFileName(szMOPath, _T("EPWMoptical.log"), szFullPath, sizeof(szFullPath)), 
									 OPF_RW, 
									 9999, 
									 ON_ERROR_RETURN ) )
			{
				cfdLogFile.SeekToEnd();
				
				TCHAR szTemp[MAX_PATH] = {0};
				_stprintf(	szTemp, 
							_T("%.24s %.11s LOG%8.8lx is LOG%8.8lx\r\n"), 
							CString(sPatient.name).GetBuffer(), 
							szDate1, 
							sProcedure.log_dir_number, 
							lLogDirNumber);
				cfdLogFile.PutString(szTemp);
				cfdLogFile.Close();
			}

			if (bLogHeader) 
				::strncpy((PCHAR)sProcedure.date, CT2A(szDate1), ARRAY_SIZE(sProcedure.date));
			
			sProcedure.time = (long)(sLogHeader.lTime_ms/1000);

			if (lLogDirNumber) 
			{
				sProcedure.log_dir_number = lLogDirNumber;
			}

			CWMLibrary::StoreRecordToLog( szMasterPath, &sPatient, sizeof(sPatient), PTDATA_VERSION);
			CWMLibrary::StoreRecordToLog( szProcedurePath, &sProcedure, sizeof(sProcedure), PROCEDURE_VERSION);
			CWMLibrary::StoreRecordToLog( szOpnotePath, &sProcedure2, sizeof(sProcedure2), PTDATA_VERSION);
			CWMLibrary::StoreRecordToLog( szMeasPath, &sMeasure, sizeof(sMeasure), PTDATA_VERSION);
			CWMLibrary::StoreRecordToLog( szPrePostPath, &sPrePost, sizeof(sPrePost), PTDATA_VERSION);
		}
	}

	TCHAR szTemp[MAX_PATH]={0};
	_stprintf(szTemp, GETMESSAGE(1775), iTotalFixed, log_dirN);
   CMessage::PopupMessage(WMFILELINE, szTemp, 5000);
}

bool CWMApp::SetLanguage(void)
{
	// This function is called even before the GetConfig() is called.
	// Get the language config settings explicitly
	
	m_INIfile.GetLanguage();
	
	// LANG_DANISH			6
	// LANG_GERMAN			7
	// LANG_ENGLISH		9
	// LANG_SPANISH		10
	// LANG_FINNISH		11
	// LANG_FRENCH			12
	// LANG_ITALIAN		16
	// LANG_DUTCH			19
	// LANG_PORTUGUESE	22
	// LANG_SWEDISH		29
	if( !CMessage::GetMessages(m_INIfile.m_iLanguageNumber) )
	{
		CString csMesg;
		csMesg.Format(_T("Cannot open Message.%u file. Please install the message file before running"), 
							m_INIfile.m_iLanguageNumber);
		CMessage::StartupMessage(WMFILELINE, 0, csMesg, false, true);
		// revert back to engligh
		m_INIfile.m_iLanguageNumber = LANG_ENGLISH;
		if( !CMessage::GetMessages(m_INIfile.m_iLanguageNumber) ) return false;
	}

	return true;
}

#ifdef DEMO_CD_ROM
bool CWMApp::CopyDemoFiles(void)
{
	try	
	{
		// Now Copy the Contents from Source demo dir to Target demo dir.
		TCHAR szSource[MAX_PATH]; 
		::WMStrnCpy(szSource, m_INIfile.m_szMsiDirName, sizeof(szSource));
		szSource[0] = m_INIfile.m_szMoDriveDirName[0];
		return CFileDB::CopyDirectory(szSource, m_INIfile.m_szMsiDirName, _T("*.*"), FALSE);
	}
	catch(CFileException* pErr) 
	{	
		pErr->Delete();
		return false;	
	}

	return true;
}
#endif

LPCTSTR CWMApp::MakePath(LPCTSTR szFile, PTCHAR szFullName, size_t uiSize)
{
	return CFileDB::MakeFileName(m_INIfile.m_szMsiDirName, szFile, szFullName, uiSize);
}

LPCTSTR CWMApp::MakePath(const long lLogDir, const DWORD dwDHR, PTCHAR szFullName, size_t uiSize)
{
	memset(szFullName, 0, uiSize);

	m_dLog.MakeLogName(lLogDir, dwDHR, szFullName, uiSize);	

	return szFullName;
}

LPCTSTR CWMApp::MakeCabinetPath(const long lLogDir, const DWORD dwDHR, PTCHAR szFullName, size_t uiSize)
{
	// 1. This creates D:\\EPWM2000\\CABINET sub folder.
	TCHAR szCabinetPath[MAX_PATH] = {0};
	MakePath(_T("CABINET"), szCabinetPath, sizeof(szCabinetPath));

	if( !CFileDB::IsExists(szCabinetPath) )
	{
		CWMLibrary::CreateDirectory(szCabinetPath);
	}
	
	// 2. This makes LOG0004d name.
	TCHAR szLog[MAX_PATH] = {0};
	_stprintf(szLog, _T("LOG_DHR%lu_%8.8lx"), dwDHR, lLogDir);

	// 3. D:\\EPWM2000\\CABINET\\LOG0004d
	CFileDB::MakeFileName(szCabinetPath, szLog, szFullName, uiSize);

	if( !CFileDB::IsExists(szFullName) )
	{
		CWMLibrary::CreateDirectory(szFullName);
	}

	return szFullName;
}

CString CWMApp::MakeDICOMPath()
{
	TCHAR szPath[MAX_PATH] = {0};
	theApp.MakePath(_T("DICOM"), szPath, sizeof(szPath));

	if( !CFileDB::IsExists(szPath) )
	{
		CWMLibrary::CreateDirectory(szPath);
	}
	
	return szPath;
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::MakeMenuPath()

	Description	:	This function assigns the file name to the menus path. It
						checks for the path and creates it if not present.

	Returns		:	None

	Setup			:	None.

	Testing		:	1. Delete the MENUS path from the windows explorer, specified 
							in the registry and run the WorkMate. Verify the MENUS folder
							is created.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
LPCTSTR CWMApp::MakeMenuPath(const int iMenuN, PTCHAR szFullName, size_t uiSize)
{
	if( !CFileDB::IsExists(m_INIfile.m_szChartMenuPath) )
	{
		CWMLibrary::CreateDirectory(m_INIfile.m_szChartMenuPath);
	}

	return CFileDB::MakeFileName(	m_INIfile.m_szChartMenuPath, 
											CWMLibrary::GetMenuName(iMenuN), 
											szFullName, 
											uiSize);
}

HGLOBAL& CWMApp::GetDeviceMode(void)
{
	return m_hDevMode;
}

LPCTSTR CWMApp::m_arszDrugUnit[] = //MENU_DRUG_UNITS
{ 
	GETMESSAGE(1474),
	GETMESSAGE(1475),
	GETMESSAGE(1476),
	GETMESSAGE(1478),
	GETMESSAGE(1479),
	GETMESSAGE(1480),
	GETMESSAGE(1481) 
};

LPCTSTR CWMApp::m_arszSedationUnit[9] = //MENU_SEDATION_UNITS
{ 
	GETMESSAGE(1474),
	GETMESSAGE(1475),
	GETMESSAGE(1476),
	GETMESSAGE(1478),
	GETMESSAGE(1479),
	GETMESSAGE(1482),
	GETMESSAGE(1483),
	GETMESSAGE(1484),
	GETMESSAGE(1486)
};

LPCTSTR CWMApp::m_arszBolusUnit[5] =	//MENU_BOLUS_UNITS
{ 
	GETMESSAGE(1482),
	GETMESSAGE(1483),
	GETMESSAGE(1484),
	GETMESSAGE(1485),
	GETMESSAGE(1486)
};


void CWMApp::CreateDrugUnitsMenu(void)
{
	for(register short iMenu=MENU_PROTOCOL; iMenu<MAX_MENU_N; ++iMenu)
	{
		ConvertMenu2Tree(iMenu);
	}
	
	CopyMenuFile(MENU_STUDY_MEDS, MENU_STUDY_MEDS_BOLUS);
	CopyMenuFile(MENU_SEDATIONS, MENU_SEDATIONS_BOLUS);

	TCHAR	szFilename[MAX_PATH]={0};
	for (int i=0; i<3; i++)
	{
		_stprintf(szFilename, m_INIfile.m_szMenuFileName, i);
		DeleteFile(szFilename);
	}
}

void CWMApp::CopyMenuFile(const int iFromMenuNumber, const int iToMenuNumber)
{
	TCHAR szTree[MAX_PATH]={0};
	MakeMenuPath(iToMenuNumber, szTree, sizeof(szTree));
	
	if(!CFileDB::IsExists(szTree))
	{
		TCHAR szFromTree[MAX_PATH]={0};
		MakeMenuPath(iFromMenuNumber, szFromTree, sizeof(szFromTree));
		CFileDB::FileCopy(szFromTree, szTree);
	}
}

void CWMApp::ConvertMenu2Tree(const int iMenu)
{
	TCHAR szTree[MAX_PATH]={0};
	MakeMenuPath(iMenu, szTree, sizeof(szTree));

	CEditMenu emMenu;
	emMenu.GetDBMenu(DATABASE_MENUS, iMenu);

	bool bNull	=	(emMenu.m_szMenuData[0][0]==0);
	bool bSpace =	(emMenu.m_szMenuData[0][0]==VK_SPACE);
	int iLen		=	_tcslen(emMenu.m_szMenuData[0]);

	if( !bNull && !bSpace && (iLen>0) )	
	{
		CString csMesg; csMesg.Format(_T("Converting Menu: %s"), CWMLibrary::GetMenuName(iMenu));		
		CMessage::StartupMessage(WMFILELINE, 0, csMesg, true, false);
		
		CEditMenu emAltMenu;
		emAltMenu.GetDBMenu(FORM_MENUS, iMenu);

		try
		{
			CFile cfSave(szTree, CFile::modeCreate|CFile::modeReadWrite);

			CArchive caSave(&cfSave, CArchive::store);

			for(register short jIndex=0; jIndex<MAX_MENU_ITEMS; ++jIndex)
			{
				bNull = (emMenu.m_szMenuData[jIndex][0]==0);
				bSpace = (emMenu.m_szMenuData[jIndex][0]==VK_SPACE);
				iLen = _tcslen(emMenu.m_szMenuData[jIndex]);

				if( !bNull && !bSpace && (iLen>0) )	
				{
					if(jIndex!=0)
					{
						CString csIndent; csIndent.Format(_T("%c"), TREE_FILE_INDENT);
						caSave.WriteString( csIndent );
					}

					TCHAR szValue[(2*MAX_FORM_MENU_CHARS)+4]={0};
					::WMStrnCpy(szValue, emMenu.m_szMenuData[jIndex], sizeof(szValue) );

					if(_tcslen(szValue)>=MAX_MENU_CHARS)
					{
						szValue[MAX_MENU_CHARS-1]=0;
					}

					caSave.WriteString( szValue );
					caSave.WriteString( TREE_FILE_SEPERATOR );

					::WMStrnCpy(szValue, emAltMenu.m_szMenuData[jIndex], sizeof(szValue) );

					if(_tcslen(szValue)>=MAX_FORM_MENU_CHARS)
					{
						szValue[MAX_FORM_MENU_CHARS-1] = 0;
					}

					caSave.WriteString( szValue );
					caSave.WriteString( _T("\r\n") );
				}		
			}

			caSave.Close();
		}
		catch(CFileException* pErr) 
		{	
			CWMLibrary::ReportError(pErr);
		}

		MEMSET(emMenu.m_szMenuData);
		emMenu.StoreDBMenu(MAX_MENU_CHARS);

		MEMSET(emAltMenu.m_szMenuData);
		emAltMenu.StoreDBMenu(MAX_FORM_MENU_CHARS);
	}
}

#ifndef PHILIPS_VIEWER
struct SWMSocketInit
{
	SWMSocketInit(void)
	{
		// we need at least version 1.1
		WORD wVersionRequested = WINSOCK_VERSION;
		
		WSAData wsaData={0};	
		const int iErr = ::WSAStartup(wVersionRequested, &wsaData);

		switch(iErr)
		{
			case	WSASYSNOTREADY		:
				AfxTrace(_T("The underlying network subsystem is not ready for network communication."));	
			break;
			case	WSAVERNOTSUPPORTED:
				AfxTrace(_T("The version of Windows Sockets support requested is not provided by this particular Windows Sockets implementation.")); 
			break;
			case	WSAEINPROGRESS		:
				AfxTrace(_T("A blocking Windows Sockets 1.1 operation is in progress."));
			break;
			case	WSAEPROCLIM			:
				AfxTrace(_T("Limit on the number of tasks supported by the Windows Sockets implementation has been reached."));
			break;
			case	WSAEFAULT			:
				AfxTrace(_T("The WSAData is not a valid pointer."));
			break;

			case	0						:
			break;
		}
	}

	virtual ~SWMSocketInit(void)
	{
		::WSACleanup();
	}
};

SWMSocketInit m_sSocketInit;

#endif

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::InitInstance()

	Description		:	This function creates all the windows and initializes all
							components required to run the application. It validates 
							the licensing options of the EP-WorkMate.

	Returns			:	Boolean: TRUE on success and FALSE on Failure.

	Setup				:	1.	Set the Mapping system registry configuation to Carto
							in the INI.exe application.
							2. Launch the Unlicensed EP-WorkMate application.

	Testing			:	1. Open the Review window with recorded signals. Open the
							Frequency Review window. Verify the Invalid License message
							on the frequency window.
							2. Open the mapping window. Verify the window displays the
							non mapping system window.
							3. Run the WMOptions.exe application and register the FFT and 
							Carto Options.
							4. Repeat Step 1. Verify the frequency window displays the 
							spectrum.
							5. Repeat Step 2. Verify the mapping window displays the 
							dialog bar controls for the Carto system.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/

LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) 
{
   BOOL fEatKeystroke = FALSE;

   if (nCode == HC_ACTION) 
	{
      switch (wParam) 
		{
			case WM_KEYDOWN	:  
			case WM_SYSKEYDOWN:
			case WM_KEYUP		:    
			case WM_SYSKEYUP	: 
			{
				PKBDLLHOOKSTRUCT p = (PKBDLLHOOKSTRUCT) lParam;
				if( (p->vkCode==VK_LWIN) || ((p->vkCode==VK_RWIN)) )
				{
					fEatKeystroke = TRUE;
				}
				else
				{
					if(p->vkCode==VK_ESCAPE)
					{
						const SHORT iControlState	=	::GetKeyState(VK_CONTROL);
						
						if(iControlState<0 && p->vkCode!=VK_CONTROL)
						{
							fEatKeystroke = TRUE;
						}
					}
				}
			}
         break;
      }
   }

   return(fEatKeystroke ? 1 : CallNextHookEx(NULL, nCode, wParam, lParam));
}

#ifdef PHILIPS_VIEWER
bool CWMApp::ParseLogDirFromCommandLine(void)
{
	// LOG_FOLDER[E:\\ARCHIVE1\\LOG0004d] 
	LPCTSTR szArg = IsArgument(_T("LOG_FOLDER"));

	if(szArg)
	{
		CString csArg( szArg );
			
		AfxTrace(_T("%s\n"), csArg);

		CString csValue;
		GetArgumentValue(csArg, csValue);

		TCHAR szPath[MAX_PATH]={0};
		::WMStrnCpy( szPath, csValue, sizeof(szPath));
		
		TCHAR szLogDirName[MAX_PATH]={0};
		
		PTCHAR szFound = _tcsrchr(szPath, '\\');

		if(szFound==NULL)
		{
			szPath[0]=0;
		}
		else
		{
			::WMStrnCpy(szLogDirName, szFound+1, sizeof(szLogDirName));				
			
			if(szFound[-1]!=':')	{	szFound[0]=0;	}
			else						{	szFound[1]=0;	}
		}			
		
		if(szPath[0] && szLogDirName[0])
		{
			::WMStrnCpy( m_INIfile.m_szLogDirName, szPath, sizeof(m_INIfile.m_szLogDirName));
			::WMStrnCpy(m_INIfile.m_szLogDirNameCpy, m_INIfile.m_szLogDirName, sizeof(m_INIfile.m_szLogDirNameCpy));					
			return (_stscanf(szLogDirName, 
								_T("LOG_DHR%lu_%x"), 
								&m_INIfile.m_dwDHR, 
								&m_INIfile.m_lLogDirNumber)==2);
		}
	}
	
	return false;
}
#endif

BOOL CWMApp::InitInstance(void)
{
#ifdef _DEBUG
	CVMException::InitExceptionHandler();
#endif

	try
	{
		SetCurrentDirectory(_T("C:\\EP-WorkMate"));
		::SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

		CMessage::m_bPumpStarted = false;

		m_hDefaultCursor	=	LoadCursor(IDC_CURSOR_DEFAULT);
		m_hNullCursor		=	LoadStandardCursor(IDC_SIZE);
		m_hHandCursor		=	LoadCursor(IDC_CURSOR_HAND);

		m_hEastWest			=	LoadCursor(IDC_CURSOR_SIZE_EW);
		m_hNorthSouth		=	LoadCursor(IDC_CURSOR_SIZE_NS);
		m_hSouthEast		=	LoadCursor(IDC_CURSOR_SIZE_NW_SE);
		m_hSouthWest		=	LoadCursor(IDC_CURSOR_SIZE_NE_SW);
		m_hPruckaHorz		=	LoadCursor(IDC_CURSOR_PRUCKA_HORZ);


		m_hDown			=	(HICON)::LoadImage( m_hInstance, MAKEINTRESOURCE(IDI_DOWN), IMAGE_ICON, 32, 24, 0);
		m_hDownDisable	=	(HICON)::LoadImage( m_hInstance, MAKEINTRESOURCE(IDI_DOWN_DISABLED ), IMAGE_ICON, 32, 24, 0);
		m_hUp				=	(HICON)::LoadImage( m_hInstance, MAKEINTRESOURCE(IDI_UP), IMAGE_ICON, 32, 24, 0);
		m_hUpDisable	=	(HICON)::LoadImage( m_hInstance, MAKEINTRESOURCE(IDI_UP_DISABLED), IMAGE_ICON, 32, 24, 0);
		
		m_hLock			=	(HICON)::LoadImage( m_hInstance, MAKEINTRESOURCE(IDI_LOCK), IMAGE_ICON, 32, 24, 0);
		m_hLockDisable	=	(HICON)::LoadImage( m_hInstance, MAKEINTRESOURCE(IDI_LOCK_DISABLED), IMAGE_ICON, 32, 24, 0);

		ParseCommandLine();

		if(!AfxOleInit())	
		{	
			CMessage::StartupMessage(WMFILELINE, 117, NULL, false, true);
		}

		if( !SetLanguage() )	
		{	
			return FALSE;	
		}

		// This Code Should Hide the Famous "Server Busy" OLE Dialog.
		COleMessageFilter* pOleMessageFilter = AfxOleGetMessageFilter();
		ASSERT_VALID(pOleMessageFilter);
		if(pOleMessageFilter)	
		{	
			pOleMessageFilter->EnableNotRespondingDialog(FALSE);	
		}

		{
			/*CString cs; 
			cs.Format(	"_timezone: %d _tzname[0]:%s _tzname[1]:%s _dstbias:%d _daylight:%d", 
						_timezone,
						_tzname[0],
						_tzname[1],
						_dstbias,
						_daylight);
			CMessage::StartupMessage(WMFILELINE, 0, cs, true);				*/

			_tputenv(_T("TZ="));
			_tzset();
			
			/*Sleep(1000);
			cs.Format(	"_timezone: %d _tzname[0]:%s _tzname[1]:%s _dstbias:%d _daylight:%d", 
						_timezone,
						_tzname[0],
						_tzname[1],
						_dstbias,
						_daylight);
			CMessage::StartupMessage(WMFILELINE, 0, cs, true);				*/
	
			m_ctTime = CDateTime::GetLocalTime();
		}

		m_piInfo.Init();

		ZEROSET(m_osInfo);
		m_osInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
		//EJB: for claris v1.1.0, cheating for now 
		// fix this in the next release
#pragma warning( push )
#pragma warning( disable: 4996 )
		if (::GetVersionEx(&m_osInfo))
#pragma warning( pop )
		{
			InitAppDirectory();
			CMessage::m_erLog.Initialize();

			CString csMessage; csMessage.Format(GETMESSAGE(1771), VERSION);
			CMessage::m_erLog.ReportError(csMessage);
		}
		else
		{
			CMessage::StartupMessage(WMFILELINE, 0, GETMESSAGE(1770), true, true);
			return FALSE;
		}

		// install minidump crash handler
		TCHAR szPath[MAX_PATH]={0};
		MakePath(_T("EventLog"), szPath, sizeof(szPath));
		if ( installMiniDumpHandler(szPath) )
		{
			CMessage::m_erLog.ReportError(_T("MiniDumpHandler installed"));
		}
		else
		{
			CMessage::m_erLog.ReportError(_T("MiniDumpHandler installation failed"));
		}



#ifndef PHILIPS_VIEWER
		// keep this around just for code that needs simple beeps
		m_SoundManager.Initialize();

		// this is the new sound manager that allows sound mixing
		CDirectSoundManager& directSoundManager = CDirectSoundManager::GetInstance();

		try {
			directSoundManager.Initialize(::AfxGetMainWnd()->GetSafeHwnd());

			for (int i = 0; i < ARRAY_SIZE(m_SoundManager.m_arSoundResource); ++i) {
				directSoundManager.AddSoundResource(m_SoundManager.m_arSoundResource[i].uiId);
			}
		}
		catch (...) {
			// might want to log this, we couldn't initialize the DirectSound subsystem.
			// this isn't a critical error as this means sounds will be automatically
			// routed to the old sound manager.
		}
#endif		
		
		// Initialize GDI+.
		CImage::StartUp();
		if(IsPrevInstance(IDS_STRING_MUTEX_NAME, true))		
		{	
			CMessage::StartupMessage(WMFILELINE, 145, NULL, false, true);
			return FALSE;	
		}
		
		if(IsPrevInstance(IDS_STRING_UPGRADE_MUTEX_NAME, false))
		{	
			CMessage::StartupMessage(WMFILELINE, 133, NULL, false, true);
			return FALSE;	
		}

		/*if(!AfxSocketInit()) 
		{ 
			CMessage::StartupMessage(WMFILELINE, 146);	
			return FALSE;	
		}*/

		AfxEnableControlContainer();

		AfxInitRichEdit();

/*		#ifdef _AFXDLL
			Enable3dControls();			// Call this when using MFC in a shared DLL
		#else
			Enable3dControlsStatic();	// Call this when linking to MFC statically
		#endif
*/

		// InitCommonControlsEx() is required on Windows XP if an application
		// manifest specifies use of ComCtl32.dll version 6 or later to enable
		// visual styles.  Otherwise, any window creation will fail.
		INITCOMMONCONTROLSEX sInitCtrls={0};
		sInitCtrls.dwSize = sizeof(sInitCtrls);
		// Set this to include all the common control classes you want to use
		// in your application.
		sInitCtrls.dwICC	=	ICC_ANIMATE_CLASS			| 
									ICC_BAR_CLASSES			| 
									ICC_COOL_CLASSES			|
									ICC_DATE_CLASSES			| 
									ICC_HOTKEY_CLASS			| 
									ICC_INTERNET_CLASSES		| 
									ICC_LISTVIEW_CLASSES		| 
									ICC_NATIVEFNTCTL_CLASS	| 
									ICC_PAGESCROLLER_CLASS	| 
									ICC_PROGRESS_CLASS		| 
									ICC_TAB_CLASSES			|
									ICC_TREEVIEW_CLASSES		| 
									ICC_UPDOWN_CLASS			| 
									ICC_USEREX_CLASSES		| 
									ICC_WIN95_CLASSES;
		BOOL B = ::InitCommonControlsEx(&sInitCtrls);

		if(m_osInfo.dwPlatformId==VER_PLATFORM_WIN32_NT)
		{
			if(m_osInfo.dwMajorVersion==5 && m_osInfo.dwMinorVersion==1)	// WinXP
			{
				//CImage::StartUp();
			}
		}
	

		if( !m_INIfile.GetConfig() )
		{
			CMessage::StartupMessage(WMFILELINE, 147, NULL, false, true);
			return FALSE;
		}

		//Claris-7680
		InitDataBase(true);
		InitServiceLogin();
		m_INIfile.InitAdminLogin();

		if (!m_INIfile.m_iWorkNet
#ifdef _DEBUG
			&& !theApp.IsArgument(_T("RUN_AS_DEV"))
#endif
		)
		{
			// Disable the Task Manager 
			if (!CRegistry::SetTaskManagerOff(true))
			{
				CMessage::m_erLog.ReportError(_T("Failed to disable TaskManager."));
			}
			else
			{
				CMessage::m_erLog.ReportError(_T("Disabled TaskManager."));
			}

			// Hide the Windows tray and start button.
			if ( HWND hTrayWnd = ::FindWindow(_T("Shell_TrayWnd"), NULL) )
				::ShowWindow(hTrayWnd, SW_HIDE);
			if ( HWND hStartWnd = ::FindWindowEx(::GetDesktopWindow(), NULL, _T("Button"), _T("Start")) )
				::ShowWindow(hStartWnd, SW_HIDE);
		}

		CMessage::m_erLog.FormatError(_T("Optical Disk Directory = %s"), m_INIfile.m_szMoDriveDirName);
		for (int i = 0; i < MAX_ARCHIVE_PATH; i++)
			CMessage::m_erLog.FormatError(_T("Archive Path %d = %s"), i + 1, m_INIfile.m_szArchivePath[i]);
		
		// This is used for report to find current log dir
		m_INIfile.m_lLastOpenedLogNumber =   m_INIfile.m_lLogDirNumber;
		m_INIfile.PutLastLogDirectoryNumber();

		_sntprintf(m_pdfReaderPath, sizeof(m_pdfReaderPath), _T("%s\\Utilities\\PDF Reader.lnk"), theApp.m_INIfile.m_szMsiDirName);

		if (m_INIfile.m_dwDHR <= 0)
		{
			m_INIfile.PromptDHR();
		}

		// Reset Admin password to Default Manufacture Password
		if (theApp.m_INIfile.m_bManufactureReset)
		{
			if (!ResetAdminAccount())
			{
				//Record for Manufacture default not found, show error message.
				CString csErr = _T("");
				csErr.Format(GETMESSAGE(11), MANUFACTURE_DEFAULT);
				CMessage::PopupMessage(WMFILELINE, csErr);
			}
		}

		// make sure not to do this until AFTER the INI has been read
		m_dMapping = CMappingBaseDoc::Instance();

		if(m_INIfile.m_bDisableWindowsMenuKey)
		{
			m_hhkLowLevelKybd  =::SetWindowsHookEx(WH_KEYBOARD_LL, 
																LowLevelKeyboardProc, 
																m_hInstance, 
																0);
		}

#ifdef PHILIPS_VIEWER

		// Figure out if this is a Viewer.
		if(IsArgument(_T("ENABLE_VIEWER")))
		{
			m_INIfile.m_bNurseMateInstalled	=	FALSE;		
			m_INIfile.m_iWorkNet		=	1;
			m_INIfile.m_iDBAccessMode	=	0;
			m_sLogin.uiPrivilege			=	USER_PRIVILEGE_VIEW | USER_PRIVILEGE_APPROVE_REPORT | USER_PRIVILEGE_CONFIG;
			m_INIfile.m_iEP4Installed	=	STIMULATOR_NONE;
			m_INIfile.m_usMappingSystemInstalled = MAPPING_SYSTEM_NONE;
			
			m_INIfile.m_szMoDriveDirName[0]	=	m_INIfile.m_szMsiDirName[0] +1;
			m_INIfile.m_szArchivePath[0][0]	=	m_INIfile.m_szMoDriveDirName[0];
			
			m_bViewerMode = true;
		}

		if(!ParseLogDirFromCommandLine())
		{
			CMessage::StartupMessage(WMFILELINE, 0, GETMESSAGE(1769), true, true);
			return FALSE;
		}
	
		m_INIfile.m_bMouseRight=FALSE;
#endif

		#if defined(DEMO_CD_ROM)

			// Check to see how many monitors are installed. 
			// If single monitor is installed and m_bMouseRight=TRUE then reset the m_bMouseRight=FALSE.

			m_INIfile.m_bMouseRight=FALSE;	

			// 1. Make sure there is at least 20MB free on C: Drive
			INT64 iFree = CFileDB::DiskFree(m_INIfile.m_szMsiDirName[0]);
			#define	FREE_20_MB	(1000*1000*20I64)
			if(iFree<FREE_20_MB)
			{
				CMessage::StartupMessage(WMFILELINE, 921, NULL, true);

				return FALSE;
			}
		
			// 2.	Check for Video Resolution at least 1280 x 1024.
			const int iHorRes = ::GetSystemMetrics(SM_CXSCREEN);
			const int iVerRes = ::GetSystemMetrics(SM_CYSCREEN);
			
			if(iHorRes<1024 || iVerRes<768)
			{
				CMessage::StartupMessage(WMFILELINE, 922, NULL, true);

				return FALSE;
			}

			// 3. Copy all files from CD ROM to C:\\EPWMDemo dir.
			CopyDemoFiles();

		#else
			long lWidth = ::GetSystemMetrics(SM_CXSCREEN);

			CString csLog; 
			csLog.Format(_T("GetSystemMetrics(SM_CXSCREEN)= %d"), lWidth); 
			CMessage::m_erLog.ReportError(csLog); 

			if(CWMLibrary::IsDualMonitor())
			{
				//lWidth *= 2;

				csLog.Format(_T("m_bDualMonitorInstalled ? %d"), lWidth); 
				CMessage::m_erLog.ReportError(csLog); 
			}

			if( lWidth <= 2000)
			{
				m_INIfile.m_bMouseRight=FALSE;	
			}
		#endif

		CDateTime::ConvDate(m_szTodaysDate,DD_MMM_YYYY,_T(""),0.0);
		CDateTime::LocalizedDate(m_szTodaysDate, m_szTodaysDate2, DATE_SIZE);

		// these must be initialized after getting the configuration
		CWMLibrary::ChangeDotPen(m_cpClipPen, m_INIfile.m_sColor[m_INIfile.m_iClipLineColor].clColor);

		CWMLibrary::ChangeDotPen(m_cpReviewClipPen, m_INIfile.m_sColor[m_INIfile.m_iClipLineColor].clColor);

		m_cpPrinterPen.CreatePen(PS_SOLID, m_INIfile.m_iLineThickness, BLACK);

		//	Write the Reports Fields Registry Settings here.	
		CRegistry::Instance()->SetString(_T("REPORTS\\FIELDSPATH"), m_INIfile.m_szMenuDirName);
		CRegistry::Instance()->SetString(_T("REPORTS\\CURLOGDIR"), _T(""));

		#if defined(DEMO_CD_ROM)
			m_dCathMap.m_CathMap.iAutoRecordMode=AUTO_REC_OFF;
		#else
			#ifdef PHILIPS_VIEWER
				m_dCathMap.m_CathMap.iAutoRecordMode=AUTO_REC_OFF;
			#else
				//m_dCathMap.m_CathMap.iAutoRecordMode=m_INIfile.m_iAutoRecordDefault;
			#endif
		#endif

		m_iTotalScreenWidth=CWMLibrary::GetDesktopWidth();

		csLog.Format(_T("CWMLibrary::GetDesktopWidth= %d"), m_iTotalScreenWidth); 
		CMessage::m_erLog.ReportError(csLog); 

		if (m_iTotalScreenWidth<1200) 
		{
			CMessage::StartupMessage(WMFILELINE, 148, NULL, true, true);
			return FALSE;
		}

#ifndef WM_CONVERT_DATABASE

		m_dMonitor.Reset();

		for(register int iMesg=0; iMesg<WM2CINE_MAX_MESSAGES; ++iMesg)
		{
			m_arMessage[iMesg].uiId = ::RegisterWindowMessage(m_arMessage[iMesg].szMesg);

			//csLog.Format("RegisterWindowMessage %d\n", m_arMessage[iMesg].uiId); 
			//CMessage::m_erLog.ReportError(csLog); 
		}

		if( !CreateMainFrame() ) 
		{
			CMessage::StartupMessage(WMFILELINE, 149, NULL, true, true);
			return FALSE;
		}

		if( !IsArgument(_T("NO_SHOW_SPLASH")) )	
		{
			m_pWMSplashScreen = new CWMSplashScreen(true);
			m_bSplash=m_pWMSplashScreen->Splash(m_fMain);
		}

#else

		CMessage::StartupMessage(WMFILELINE, 1860, NULL, true);

		InitDataBase(true);

		ExitDataBase();

		return FALSE;

#endif

		ValidateLicensing();
		CReport::DetectSupportingApplications();
		
		//InstallPrinter();

		if( !m_MainBar.Create(IDD_MAIN_DIALOGBAR, m_fMain) )
		{
			CMessage::DisplayError(WMFILELINE, 150);	
			return FALSE;
		}

		m_MainBar.ShowWindow(SW_HIDE);

		//CMessage::m_erLog.ReportError("m_MainBar.Create"); 

		/*if (!m_hDevMode)	
		{
			#ifndef _DEBUG
			CMessage::StartupMessage(WMFILELINE, 151);
			m_MainBar.m_btnPrintCtl.EnableWindow(FALSE);
			#endif
		}*/

#ifndef PHILIPS_VIEWER
		if(!m_Stim.Create())
		{ 
			CMessage::StartupMessage(WMFILELINE, 152, NULL, true, true);
			return FALSE;	
		}

		m_pTrace = new CTraceDialog(m_fMain);
		m_pTrace->Create(IDD_DIALOG_TRACE, m_fMain);
#endif

		CMessage::m_erLog.ReportError(_T("Stim Done"));

		if( !CreateReviewWindows() )
		{
			CMessage::StartupMessage(WMFILELINE, 154, NULL, true, true);
			return FALSE;	
		}
		
		CMessage::m_erLog.ReportError(_T("CreateReviewWindows Done"));

		if(!m_DirectDraw.Create())
		{
			CMessage::StartupMessage(WMFILELINE, 155, NULL, true, true);
			return FALSE;
		}

#ifndef PHILIPS_VIEWER
		if (m_INIfile.m_szAmpAdapterIP[0])
		{
			if (!IAmplifierSession::Instance()->StartMonitoring(m_INIfile.m_szAmpAdapterIP))
			{
				CMessage::StartupMessage(WMFILELINE, 51, m_INIfile.m_szAmpAdapterIP, true, true);
			}
			else
			{
				CMessage::m_erLog.ReportError(_T("Amplifier Communications: Monitoring Started"));
			}
		}
		else
		{
			CMessage::m_erLog.ReportError(_T("Amplifier Communications: Connection not configured"));
		}
#endif

		// first check to make sure all windows are created - abort if something is missing
		if(!CWMLibrary::IsSafeWindow(m_fMain)			||
			!CWMLibrary::IsSafeWindow(m_fReview)		||
			!CWMLibrary::IsSafeWindow(m_vReview)		||
			!CWMLibrary::IsSafeWindow(m_fPrevReview)	||
			!CWMLibrary::IsSafeWindow(m_vPrevReview)	||
			!CWMLibrary::IsSafeWindow(m_fHolter)		||
			!CWMLibrary::IsSafeWindow(m_vHolter)		||
			!CWMLibrary::IsSafeWindow(m_fMonitor)		||
			!CWMLibrary::IsSafeWindow(m_fRealTime)		||
			!CWMLibrary::IsSafeWindow(m_fRealTimeBar)	||
			!CWMLibrary::IsSafeWindow(m_vRealTimeBar)	||
			!CWMLibrary::IsSafeWindow(m_fRF)				||
			!CWMLibrary::IsSafeWindow(m_vRF)				||
			!CWMLibrary::IsSafeWindow(m_fCine)			||
#ifndef PHILIPS_VIEWER
			!CWMLibrary::IsSafeWindow(m_fCathMap)		||
			!CWMLibrary::IsSafeWindow(m_vCathMap)		||
			!m_Stim.IsSafeWindow()							||
#endif
			!CWMLibrary::IsSafeWindow(m_vDB)				||
			!CWMLibrary::IsSafeWindow(m_fDB)				||
			!CWMLibrary::IsSafeWindow(m_vCine)			||
			!CWMLibrary::IsSafeWindow(m_fLog)			||
			!CWMLibrary::IsSafeWindow(m_fChart)			||
			!CWMLibrary::IsSafeWindow(m_vLog)			||
			!CWMLibrary::IsSafeWindow(m_vChart)			||
			!CWMLibrary::IsSafeWindow(m_vChartEvent)	||
			!CWMLibrary::IsSafeWindow(m_fMapping)		||
			!CWMLibrary::IsSafeWindow(m_vATMMap)		||
#ifdef OTHER_MAP_TYPES
			!CWMLibrary::IsSafeWindow(m_vAFLMap)		||
			!CWMLibrary::IsSafeWindow(m_vSMMMap)		||
			!CWMLibrary::IsSafeWindow(m_vDPMMap)		||
#endif
			!CWMLibrary::IsSafeWindow(m_fMeasurement) ||
			!CWMLibrary::IsSafeWindow(m_vMeasurement) ||
			!CWMLibrary::IsSafeWindow(m_MainBar) )
		{
			CMessage::StartupMessage(WMFILELINE, 156, NULL, true, true);
			ExitWorkMate(true); 
			return FALSE;
		}
		
		::ShowCursor(TRUE);
		
#ifndef PHILIPS_VIEWER
		if (m_bSplash && CWMLibrary::IsSafeWindow(m_pWMSplashScreen) )	
		{
#ifndef MESSAGE_TEST
			Sleep(5000); // 5 second splash window
#endif
		}
		
		SetCurrentLogDirectoryNumber();

		CreateDrugUnitsMenu();

		CWMLibrary::ConvertInsertTemplates(m_INIfile.m_szFormsDirName, _T("INSERT.*"));

		BOOL bRet = ShowShell();	

		if ( m_bSplash )
			HideSplashScreen();
		
		return bRet;
#else		
		CreateDrugUnitsMenu();

		CWMLibrary::ConvertInsertTemplates(m_INIfile.m_szFormsDirName, _T("INSERT.*"));

		ShowShell();
		
		m_bShellActive=false;

		return BeginNewStudy();
#endif
	}
	catch(CVMException& v)
	{
		CMessage::m_erLog.ReportError( v.Translate() );
	}

	return FALSE;
}

bool CWMApp::ResetAdminAccount()
{
	bool bRet = false;
	//get the record from DB
	theApp.m_dbLogin.FreeRecord();
	ZEROSET(theApp.m_sLogin);
	theApp.m_dbLogin.InitRecord();

	::strncpy((PCHAR)theApp.m_dbLogin.m_pIndex->key1, CT2A(MANUFACTURE_DEFAULT), theApp.m_dbLogin.m_pIndex->key1_length);
	if (theApp.m_dbLogin.GetRecord(GET_FROM_INDEX, LOCK_EDIT, 9999) == DB_OK)
	{
		// Get record from DB file to Variable MfrDefault
		SLogin MfrDefault;
		MfrDefault.sHashPassword = theApp.m_sLogin.sHashPassword;
		MfrDefault.uiPrivilege = theApp.m_sLogin.uiPrivilege;
		::strncpy((PCHAR)MfrDefault.szUserName, (PCHAR)theApp.m_sLogin.szUserName, ARRAY_SIZE(MfrDefault.szUserName));
		::strncpy((PCHAR)MfrDefault.szInitial, (PCHAR)theApp.m_sLogin.szInitial, ARRAY_SIZE(MfrDefault.szInitial));
		// Set Admin to Manufacture Default Password
		SHashPassword& sHashPassword = theApp.m_INIfile.m_sAdminPassword;
		memset(&sHashPassword, 0, sizeof(SHashPassword));
		::memcpy((PTCHAR)sHashPassword.arValue, (LPCTSTR)MfrDefault.sHashPassword.arValue, sizeof(sHashPassword.arValue));
		theApp.m_dbLogin.InitRecord();
		::strncpy((PCHAR)theApp.m_dbLogin.m_pIndex->key1, CT2A(WORKMATE_ADMIN_USER_NAME), theApp.m_dbLogin.m_pIndex->key1_length);
		if (theApp.m_dbLogin.GetRecord(GET_FROM_INDEX, LOCK_EDIT, 9999) == DB_OK)
		{
			::strncpy((PCHAR)theApp.m_sLogin.szUserName, CT2A(WORKMATE_ADMIN_USER_NAME), ARRAY_SIZE(theApp.m_sLogin.szUserName));
			::strncpy((PCHAR)theApp.m_sLogin.szInitial, "WM", ARRAY_SIZE(theApp.m_sLogin.szInitial));
			::memcpy(theApp.m_sLogin.sHashPassword.arValue, MfrDefault.sHashPassword.arValue, sizeof(theApp.m_sLogin.sHashPassword.arValue));
			theApp.m_sLogin.uiPrivilege = USER_PRIVILEGE_NONE | USER_PRIVILEGE_ADD_EDIT | USER_PRIVILEGE_DELETE | USER_PRIVILEGE_VIEW | USER_PRIVILEGE_EDIT_PREVIOUS | USER_PRIVILEGE_APPROVE_REPORT | USER_PRIVILEGE_CONFIG;
			theApp.m_dbLogin.PutRecord();
		}
		theApp.m_INIfile.PutConfig();
		// Reset the flag
		CRegistry::Instance()->SetInt32(_T("CONFIG\\MANUFACTURE RESET(0-NO,1-YES)"), 0);
		bRet = true;
	}
	return bRet;
}

bool CWMApp::ShowShell(void)
{
	HideAllWindows();

	CWnd* pDesktopWnd = m_fMain->GetDesktopWindow();
	ASSERT_VALID(pDesktopWnd);

	CRect crFullScreen(0,0,0,0);

	if( pDesktopWnd)	
	{	
		pDesktopWnd->GetClientRect( &crFullScreen);	


#ifdef PHILIPS_VIEWER

		if(crFullScreen.Width()>2000)
		{
			crFullScreen.SetRect( PHILIPS_VIEWER_LEFT, PHILIPS_VIEWER_TOP, PHILIPS_VIEWER_RIGHT, PHILIPS_VIEWER_BOTTOM);
		}
		else
		{
			crFullScreen.SetRect( 0,	PHILIPS_VIEWER_TOP, CWMLibrary::GetDesktopWidth(), PHILIPS_VIEWER_BOTTOM	);
		}
	
#else

		/*if(!m_INIfile.m_bMouseRight)
		{
			crFullScreen.right=CWMLibrary::GetDesktopWidth();
		}	
		else	
		{
			crFullScreen.left=CWMLibrary::GetDesktopWidth();
		}*/
#endif

		m_fMain->MoveWindow(&crFullScreen);
	}

#ifndef PHILIPS_VIEWER
	if(!m_pShell)	
	{	
		m_pShell = new CShell(m_fMain);		
		m_pShell->Create(IDD_DIALOGBAR_SHELL, m_fMain);
	}
#endif

	m_fMain->GetClientRect(&crFullScreen);
	m_fMain->ClientToScreen(&crFullScreen);

#ifndef PHILIPS_VIEWER

	if(!m_INIfile.m_bMouseRight)
	{
		crFullScreen.right=CWMLibrary::GetDesktopWidth();
	}	
	else	
	{
		crFullScreen.left=CWMLibrary::GetDesktopWidth();
		crFullScreen.right = crFullScreen.left + CWMLibrary::GetDesktopWidth();
	}

	m_pShell->Show(crFullScreen);
	m_bShellActive=true;

	m_pShell->BeginUserInactivitySession();
#else
	m_bShellActive=true;
#endif

	m_fMain->SetForegroundWindow();

	m_fMain->DrawScreenHeader();

#ifndef PHILIPS_VIEWER
	m_pShell->SetCursorPosition();
#endif

	return true;
}

bool CWMApp::ShowScreenSaver()
{
    bool bActivateScreenSaver = ( !m_pWMSplashScreen );
	if ( bActivateScreenSaver )
	{
		m_pWMSplashScreen = new CWMSplashScreen(false);
		m_pWMSplashScreen->Splash(m_fMain);
	}
    return bActivateScreenSaver;
}

void CWMApp::HideSplashScreen()
{
    if (CWMLibrary::IsSafeWindow(m_pWMSplashScreen))
    {
        m_pWMSplashScreen->Hide();
        m_pWMSplashScreen = nullptr;
    }
}

static bool g_bMoved = false; 

void CWMApp::ClearProcedureData()
{
	EndTriggeredReviewMode(eReview);
	EndTriggeredReviewMode(ePrevReview);	

	m_uiTriggeredReviewMode = TRIGGERED_MODE_NONE;

	m_vReview->EndTriggeredSweep();
	m_fMonitor->m_vMonitor.Reset();	
	m_fRealTime->m_mtMonitor.m_vMonitor.Reset();	
#ifndef PHILIPS_VIEWER
	m_pWMSplashScreen	=	NULL;
#endif
	m_vDB->Reset();
	m_dMonitor.Reset();
	m_MainBar.Reset();
	if(!g_bMoved)	// Dont have to move every time.
	{
		m_MainBar.MoveMainBar();
	}
#ifndef PHILIPS_VIEWER
	m_Stim.Reset();
#endif
	m_dReview.Reset();
	m_dPrevReview.Reset();
	m_dFreqReview.Reset();
	m_dHolter.Reset();
	m_vHolter->Reset();
	m_vReview->Reset();
	m_fReview->m_pSignalBar->Reset();
	m_vPrevReview->Reset();
	m_fPrevReview->m_pSignalBar->Reset();
	m_dRF.Reset();
	m_vRF->Reset();
	m_dCine.Reset();
	m_vCine->Reset();
	m_dLog.Reset();
	m_dChart.Reset();
	m_vLog->Reset();
	m_vChart->Reset();
#ifndef PHILIPS_VIEWER
	m_vCathMap->Reset();
#endif
	m_dMapping->Reset();
	m_vATMMap->Reset();
	m_fMapping->Reset();
	m_dProcedure.Reset();
	ZEROSET(m_dProcedure.m_Procedure2);
	ZEROSET(m_Session);
	ZEROSET(m_Doctor);
	ZEROSET(m_PacerSpec);
	ZEROSET(m_LeadSpec);
	ZEROSET(m_ICDSpec);
	MEMSET(m_arCSAutoMeasurementInterval);
	for(register short iIndex=0; iIndex<CHART_AUTO_MEAS_TOTAL; ++iIndex)
	{
		m_aruiChartAutoMeasurementTime[iIndex] = 10000U;
	}

	m_dPatient.Reset();
	m_dCathMap.Reset();
	m_dMeas.Reset();
	m_cgPage.Reset();
	m_flFilter.Reset();
	m_sScreens.Reset();

	//m_mpDialogMap1.clear();
	
#ifndef PHILIPS_VIEWER
	SetStimActive(false);
#endif

#if defined(DEMO_CD_ROM)
	#ifdef ALLURA_TSM
		//m_dCathMap.m_CathMap.iAutoRecordMode		=	m_INIfile.m_iAutoRecordDefault;
	#else
		m_dCathMap.m_CathMap.iAutoRecordMode		=	AUTO_REC_OFF;
	#endif
#else
	#ifdef PHILIPS_VIEWER
		m_dCathMap.m_CathMap.iAutoRecordMode		=	AUTO_REC_OFF;
	#else
		//m_dCathMap.m_CathMap.iAutoRecordMode		=	m_INIfile.m_iAutoRecordDefault;
	#endif
#endif
	m_iAutoRecordSave		=	AUTO_REC_OFF;	
	m_bCathMapScrnActive	=	false;
	m_bConfigScrnActive	=	false;
	m_bPKeyEditDlgActive	=	false;
	m_bReportWindowActive=	false;
	m_bMapJBoxAlive		=	false;
	m_eCursor				=	eDefaultCursor;
	m_eCaliper				=  eNoneCaliper;
	m_ulAutoRecordTimeRF	=	0;     
	m_ulAutoRecordTimeStim	= 0;   
	m_ulAutoRecordTimeHRate	=	0;  
	m_ulAutoRecordTimeHARate=	0;  
	m_ulAutoRecordTimeHVRate=	0;  
	m_ulAutoRecordTimeLRate	=	0;  
	m_uiMSecTimer			=	0;
	m_iPrintingReview		=	PR_NONE;
	m_bDisplayIntervals	=	true;
	m_eLastCal				=	eHor;
	m_bPrintFromList		=	false;
	m_bDBScrnActive		=	false;
	m_iZeroPressure		=	0;
   m_iTriggeredSweepShow=	0;
	m_bAskPath				=  false;
	m_bReviewFit			=	m_INIfile.m_iReviewFit!=0;
	m_iCathMapDlgs			=	0;
	m_bMute					=	false;
	m_bSaveMeasurements	=	false;
	m_bAutoChartMeasurementsEnabled = false;
	m_bColorPrint			=	false;

#ifdef ALLURA_TSM
	m_bPrimaryEdited		=	false;
	m_bReferringEdited	=	false;
#endif

	ZEROSET(m_sAVIWndPos);
	::SetRectEmpty(&m_sAVIWndPos2);

	ExitDataBase();
	InitDataBase(false);

	this->GetDatabaseLock().DetachLock();
	this->GetDatabaseLock().Initialize();
	
	m_dCathMap.InitCathMap();

    m_bActiveMode = false;
}

void CWMApp::ResetProcedureGUI()
{
    SetDemoIndicator();

	m_MainBar.m_btnTriggerLevelCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnSaveCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnRecallCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnViewsCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnHelpCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnTriggerStimCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
    m_MainBar.m_btnTriggerLevelCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnStartRecCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnShowCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnProtocolCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnPrintCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnNotesCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnEventsCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnSplitCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnRFCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnMonitorCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnLogCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnMapCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnHolterCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnChartCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnCineCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.SetDrugButton(false);
	m_MainBar.m_btnCathmapCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnStimCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnDBCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.m_btnExitCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
	m_MainBar.SetMeasButton(false);
	m_MainBar.SaveDataOff();
	m_MainBar.SetCaliperButton(eHor, false);
	m_MainBar.SetCaliperButton(eVer, false);
	m_MainBar.SetCaliperButton(eLine, false);
	m_MainBar.SetCaliperButton(eFull, false);
	m_MainBar.SetCaliperButton(ePoint, false);
	m_MainBar.SetCaliperButton(eLevel, false);

	m_MainBar.ShowWindow(SW_SHOW);
#ifndef PHILIPS_VIEWER
	m_Stim.ShowWindow(SW_HIDE);
#endif
	m_fDB->ShowWindow(SW_HIDE);
	m_fMapping->ShowWindow(SW_HIDE);

	m_fPrevReview->ShowWindow(SW_HIDE);
	m_fHolter->ShowWindow(SW_HIDE);
	m_fRF->ShowWindow(SW_HIDE);
	m_fCine->ShowWindow(SW_HIDE);
	m_fLog->ShowWindow(SW_HIDE);
	m_fChart->ShowWindow(SW_HIDE);
	m_fReview->ShowWindow(SW_SHOW);
	m_fMeasurement->ShowWindow(SW_HIDE);

	if( !IsArgument(_T("NO_MONITOR_SCREEN")) )	{	m_fMonitor->ShowWindow(SW_HIDE);	}

    m_dMonitor.ClearTigaRF();

	m_fRealTime->ShowWindow(SW_SHOW);
	m_fRealTimeBar->ShowWindow(SW_SHOW);

	m_vRealTimeBar->SetSaveColor();

	m_fChart->m_pChartDialogBar->SetCameraButton(m_bAutoChartMeasurementsEnabled);

	m_fMonitor->m_vMonitor.m_bFreeze=false;
	m_fMonitor->m_dlgBar->Reset();
	
	m_fRealTime->m_mtMonitor.m_vMonitor.m_bFreeze=false;
	m_fRealTime->m_dlgBar->Reset();

	m_fMain->SetForegroundWindow();

    CWMLibrary::AdjustWindow(m_fPrevReview,true,	true);
	CWMLibrary::AdjustWindow(m_fHolter,		false,true);
	CWMLibrary::AdjustWindow(m_fMonitor,	true, true);
	CWMLibrary::AdjustWindow(m_fCine,		false,true);
	CWMLibrary::AdjustWindow(m_fRF,			true, true); 
	CWMLibrary::AdjustWindow(m_fLog,			false,true);
	CWMLibrary::AdjustWindow(m_fChart,		false,true);
	CWMLibrary::AdjustWindow(m_fReview,		false,false);
	CWMLibrary::AdjustWindow(m_fMapping,	true, true);
	CWMLibrary::AdjustWindow(m_fMeasurement,false,true);

	if(!g_bMoved)	
	{	
		m_vRF->SetControls();
		m_vChartEvent->SetControls();
		m_vChartEvent->RemoveFrameScrollBars(m_fChart);
		m_vMeasurement->SetControls();
		m_vMeasurement->RemoveFrameScrollBars(m_fMeasurement);

		g_bMoved=true;	// Dont have to move every time.
	}	

	m_vChartEvent->InitializeTree();
	
	::ShowCursor(TRUE);

	if( CWMLibrary::IsSafeWindow(m_fMain) )	
	{	
		m_fMain->SetReverse(m_INIfile.m_bMouseRight?true:false);
		m_fMain->DrawScreenHeader();	
	}
}

bool CWMApp::BeginNewStudy(void)
{
	// first check to make sure all windows are created - abort if something is missing
	if(!CWMLibrary::IsSafeWindow(m_fMain)	||
		!CWMLibrary::IsSafeWindow(m_fReview)	   ||
		!CWMLibrary::IsSafeWindow(m_vReview)		||
		!CWMLibrary::IsSafeWindow(m_fPrevReview)	||
		!CWMLibrary::IsSafeWindow(m_vPrevReview)	||
		!CWMLibrary::IsSafeWindow(m_fHolter)		||
		!CWMLibrary::IsSafeWindow(m_vHolter)		||
		!CWMLibrary::IsSafeWindow(m_fMonitor)		||
#ifndef PHILIPS_VIEWER
		!CWMLibrary::IsSafeWindow(m_fCathMap)		||
		!CWMLibrary::IsSafeWindow(m_vCathMap)		||
		!m_Stim.IsSafeWindow()							||		
#endif
		!CWMLibrary::IsSafeWindow(m_fDB)				||
		!CWMLibrary::IsSafeWindow(m_fRealTime)		||
		!CWMLibrary::IsSafeWindow(m_fRF)				||
		!CWMLibrary::IsSafeWindow(m_vRF)				||
		!CWMLibrary::IsSafeWindow(m_fCine)			||
		!CWMLibrary::IsSafeWindow(m_vCine)			||
		!CWMLibrary::IsSafeWindow(m_fLog)			||
		!CWMLibrary::IsSafeWindow(m_fChart)			||
		!CWMLibrary::IsSafeWindow(m_vLog)			||
		!CWMLibrary::IsSafeWindow(m_vChart)			||
		!CWMLibrary::IsSafeWindow(m_vChartEvent)	||
		!CWMLibrary::IsSafeWindow(m_vDB)				||
		!CWMLibrary::IsSafeWindow(m_fMapping)		||
		!CWMLibrary::IsSafeWindow(m_vATMMap)		||
		!CWMLibrary::IsSafeWindow(m_fMeasurement) ||
		!CWMLibrary::IsSafeWindow(m_vMeasurement) ||
		!CWMLibrary::IsSafeWindow(m_MainBar) )
	{
		CMessage::DisplayError(WMFILELINE, 156);
		ExitWorkMate(true); 
		return false;
	}

	{ 
		CString csEventLog;
		csEventLog.Format(_T("Begin New Study")); 
		CMessage::m_erLog.ReportError(csEventLog); 
	}

	// inform amplifier that we are starting a new session
	IAmplifierSession::Instance()->ResetSession();

	CWnd* pDesktopWnd = m_fMain->GetDesktopWindow();
	if(pDesktopWnd)
	{
		CRect crFullScreen(0,0,0,0);	pDesktopWnd->GetClientRect(&crFullScreen);	

#ifdef PHILIPS_VIEWER

		if(crFullScreen.Width()>2000)
		{
			crFullScreen.SetRect(PHILIPS_VIEWER_LEFT, PHILIPS_VIEWER_TOP, PHILIPS_VIEWER_RIGHT, PHILIPS_VIEWER_BOTTOM);
		}
		else
		{
			crFullScreen.SetRect(0, PHILIPS_VIEWER_TOP, CWMLibrary::GetDesktopWidth(), PHILIPS_VIEWER_BOTTOM);
		}
#else
		CString csLog; 
		csLog.Format(_T("GetDesktopWindow= %d - %d"), crFullScreen.Width(), crFullScreen.Height()); 
		CMessage::m_erLog.ReportError(csLog); 

		long lWidth = crFullScreen.Width();
		//if(m_INIfile.m_bDualMonitorInstalled)
		//{
			//crFullScreen.right *= 2;
		//}

		csLog.Format(_T("m_bDualMonitorInstalled=%d"), crFullScreen.Width()); 
		CMessage::m_erLog.ReportError(csLog); 
#endif

		m_fMain->MoveWindow(&crFullScreen);
	}

	m_thePrintService.InstallPrinter();

    // Reset the state of application in preparation for 
    // loading or creating a study
    ClearProcedureData(); // this may get repeatedly
    ResetProcedureGUI();

#ifndef PHILIPS_VIEWER
   m_Stim.Restart();
#endif

	m_dRF.InitRFPort();

#ifdef PHILIPS_VIEWER
	m_bProcessData = false;
#else
	m_bProcessData = true;
#endif

	//disable temporarly until case is started
	m_bDisableAutoRec = true;
	InitAutoRecord();
	theApp.m_MainBar.SetAutoRecButtonColor();
	
	ReviewScreenStart();

	if(!m_fMapping->StartTalking())
	{
	    switch(m_INIfile.m_usMappingSystemInstalled)
	    {
			case MAPPING_SYSTEM_ENSITE:
			{
				CMessage::PopupMessage(WMFILELINE, GETMESSAGE(2566));
				break;
			}
		    case MAPPING_SYSTEM_NONE:
		    default:
		    {
			    //TODO: add error message
		        break;
		    }
    #ifdef ENABLE_CARTO
		    case MAPPING_SYSTEM_CARTO	:
		    {
			    CMessage::PopupMessage(WMFILELINE, 1802);
			    break;
		    }
    #endif
	    }
	}

#ifndef _DEBUG
	if(!IsArgument(_T("DISABLE_PROG_BURST")))
	{
		RegisterHotKey(m_pMainWnd->m_hWnd, 1, 0, VK_SNAPSHOT);
	}
#endif

	theApp.m_INIfile.PutPrevRunAll(	
		m_dPatient.m_Access.m_usRecordNumber, 
		theApp.m_dCathMap.m_Access.m_usRecordNumber, 
		theApp.m_dProcedure.m_Access.m_usRecordNumber,
		theApp.IsPassiveMode(), 
		theApp.m_dProcedure.m_Procedure.log_dir_number);

#ifdef PHILIPS_VIEWER
	if (m_bSplash && CWMLibrary::IsSafeWindow(m_pWMSplashScreen) )	
	{
		Sleep(5000); // 5 second splash window
		m_pWMSplashScreen->Hide(m_pWMSplashScreen);	
	}
#endif	

	return true;
}

bool CWMApp::CreateReviewWindows(void)
{
	CMultiDocTemplate* pTemplate = NULL;

	m_fPrevReview = new CSignalChildFrame(ePrevReview);
	ASSERT(m_fPrevReview);	if(!m_fPrevReview)	{	return false;	}
	m_vPrevReview=(CPrevReviewView*)m_fPrevReview->Create(GETMESSAGE(290), m_fMain, RUNTIME_CLASS(CPrevReviewView));
	
	//CMessage::m_erLog.ReportError("m_vPrevReview Done");
	
	pTemplate = new CMultiDocTemplate(IDR_WORKMATE,								NULL,
												 RUNTIME_CLASS(CHolterChildFrame),	RUNTIME_CLASS(CHolterView) );
	ASSERT_VALID(pTemplate);	if(!pTemplate)	{	return false;	}
	AddDocTemplate(pTemplate);
	m_fHolter = (CHolterChildFrame*) pTemplate->CreateNewFrame(NULL, NULL);
	ASSERT_VALID(m_fHolter);	if(!m_fHolter)	{	return false;	}
	pTemplate->InitialUpdateFrame(m_fHolter, NULL, TRUE);
	m_vHolter=(CHolterView*)m_fHolter->GetActiveView();
	ASSERT_VALID(m_vHolter);	if(!m_vHolter)	{	return false;	}
	m_fHolter->SetCaption(GETMESSAGE(291));
	m_fHolter->ShowWindow(SW_HIDE);

	//CMessage::m_erLog.ReportError("Holter Done");

	pTemplate = new CMultiDocTemplate(IDR_WORKMATE,						   NULL,
												 RUNTIME_CLASS(CRFChildFrame),	RUNTIME_CLASS(CRFView) );
	ASSERT_VALID(pTemplate);	if(!pTemplate)	{	return false;	}
	AddDocTemplate(pTemplate);
	m_fRF = (CRFChildFrame*) pTemplate->CreateNewFrame(NULL, NULL);
	ASSERT_VALID(m_fRF);	if(!m_fRF)	{	return false;	}
	pTemplate->InitialUpdateFrame(m_fRF, NULL, TRUE);
	m_vRF=(CRFView*)m_fRF->GetActiveView();
	ASSERT_VALID(m_vRF);	if(!m_vRF)	{	return false;	}
	m_fRF->SetCaption(GETMESSAGE(292));
	m_fRF->ShowWindow(SW_HIDE);

	//CMessage::m_erLog.ReportError("RF Done");

	pTemplate = new CMultiDocTemplate(IDR_WORKMATE,						   NULL,
												 RUNTIME_CLASS(CCineChildFrame),	RUNTIME_CLASS(CCineView) );
	ASSERT_VALID(pTemplate);	if(!pTemplate)	{	return false;	}
	AddDocTemplate(pTemplate);
	m_fCine = (CCineChildFrame*) pTemplate->CreateNewFrame(NULL, NULL);
	ASSERT_VALID(m_fCine);	if(!m_fCine)	{	return false;	}
	pTemplate->InitialUpdateFrame(m_fCine, NULL, TRUE);
	m_vCine=(CCineView*)m_fCine->GetActiveView();
	ASSERT_VALID(m_vCine);	if(!m_vCine)	{	return false;	}
	m_fCine->SetCaption(GETMESSAGE(1968));
	m_fCine->ShowWindow(SW_HIDE);

	//CMessage::m_erLog.ReportError("Cine Done");

	pTemplate = new CMultiDocTemplate(IDR_WORKMATE,							NULL,
												 RUNTIME_CLASS(CLogChildFrame),	RUNTIME_CLASS(CLOGView) );
	ASSERT_VALID(pTemplate);	if(pTemplate==NULL)	{	return false;	}
	AddDocTemplate(pTemplate);
	m_fLog = (CLogChildFrame*) pTemplate->CreateNewFrame(NULL, NULL);
	ASSERT_VALID(m_fLog);	if(!m_fLog)	{	return false;	}
	pTemplate->InitialUpdateFrame(m_fLog, NULL, TRUE);
	m_vLog=(CLOGView*)m_fLog->GetActiveView();
	ASSERT_VALID(m_vLog);	if(!m_vLog)	{	return false;	}
	m_fLog->SetCaption(GETMESSAGE(294));
	m_fLog->ShowWindow(SW_HIDE);

	//CMessage::m_erLog.ReportError("Log Done");

	m_fChart = new CChartChildFrame;
	ASSERT(m_fChart);	if(!m_fChart)	{	return false;	}

	m_fChart->Create(GETMESSAGE(1467), m_fMain, m_vChart, m_vChartEvent);
	m_fChart->SetCaption(GETMESSAGE(1467));
	m_fChart->ShowWindow(SW_HIDE);

	//CMessage::m_erLog.ReportError("Chart Done");
	
	m_fReview = new CReviewChildFrame(eReview);
	ASSERT(m_fReview);	if(!m_fReview)	{	return false;	}

	m_fReview->Create(GETMESSAGE(295), m_fMain, m_vReview, m_vFreqReview);
	
	//CMessage::m_erLog.ReportError("Review Done");

#ifndef PHILIPS_VIEWER
	pTemplate = new CMultiDocTemplate(IDR_WORKMATE,						   NULL,
												 RUNTIME_CLASS(CCathMapFrame),	RUNTIME_CLASS(CCathMapView) );
	ASSERT_VALID(pTemplate);	if(!pTemplate)	{	return false;	}
	AddDocTemplate(pTemplate);
	m_fCathMap = (CCathMapFrame*) pTemplate->CreateNewFrame(NULL, NULL);
	ASSERT_VALID(m_fCathMap);	if(!m_fCathMap)	{	return false;	}
	pTemplate->InitialUpdateFrame(m_fCathMap, NULL, TRUE);
	m_vCathMap=(CCathMapView*)m_fCathMap->GetActiveView();
	ASSERT_VALID(m_vCathMap);	if(!m_vCathMap)	{	return false;	}
	m_fCathMap->ShowWindow(SW_HIDE);
	
	//CMessage::m_erLog.ReportError("Cathmap Done");
#endif

	pTemplate = new CMultiDocTemplate(IDR_WORKMATE,					NULL,
												 RUNTIME_CLASS(CDBFrame),	RUNTIME_CLASS(CDBView) );
	ASSERT_VALID(pTemplate);	if(!pTemplate)	{	return false;	}
	AddDocTemplate(pTemplate);
	m_fDB = (CDBFrame*) pTemplate->CreateNewFrame(NULL, NULL);
	ASSERT_VALID(m_fDB);	if(!m_fDB)	{	return false;	}
	pTemplate->InitialUpdateFrame(m_fDB, NULL, TRUE);
	m_vDB=(CDBView*)m_fDB->GetActiveView();
	ASSERT_VALID(m_vDB);	if(!m_vDB)	{	return false;	}
	m_fDB->ShowWindow(SW_HIDE);
	
	//CMessage::m_erLog.ReportError("DB Done");

	m_fMapping = new CMappingChildFrame();

	ASSERT(m_fMapping);	if(!m_fMapping)	{	return false;	}
	m_fMapping->Create(GETMESSAGE(1067), m_fMain);
	m_fMapping->ShowWindow(SW_HIDE);
	m_fMapping->SetCaption(GETMESSAGE(1067));

	//CMessage::m_erLog.ReportError("Mapping Done");

/*	pTemplate = new CMultiDocTemplate(IDR_WORKMATE,										NULL,
												 RUNTIME_CLASS(CCartoMapNotesChildFrame),	RUNTIME_CLASS(CCartoMapNotesView) );
	ASSERT_VALID(pTemplate);	if(!pTemplate)	{	return false;	}
	AddDocTemplate(pTemplate);
	m_fCartoMapNotes = (CCartoMapNotesChildFrame*) pTemplate->CreateNewFrame(NULL, NULL);
	ASSERT_VALID(m_fCartoMapNotes);	if(!m_fCartoMapNotes)	{	return false;	}
	pTemplate->InitialUpdateFrame(m_fCartoMapNotes, NULL, TRUE);
	m_vCartoMapNotes=(CCartoMapNotesView*)m_fCartoMapNotes->GetActiveView();
	ASSERT_VALID(m_vCartoMapNotes);	if(!m_vCartoMapNotes)	{	return false;	}
	m_fCartoMapNotes->SetCaption(GETMESSAGE(1714));
	m_fCartoMapNotes->ShowWindow(SW_HIDE);
	m_fCartoMapNotes->PositionFrame();*/

	pTemplate = new CMultiDocTemplate(IDR_WORKMATE,						   NULL,
												 RUNTIME_CLASS(CMeasurementChildFrame),	RUNTIME_CLASS(CMeasurementView) );
	ASSERT_VALID(pTemplate);	if(!pTemplate)	{	return false;	}
	AddDocTemplate(pTemplate);
	m_fMeasurement = (CMeasurementChildFrame*) pTemplate->CreateNewFrame(NULL, NULL);
	ASSERT_VALID(m_fMeasurement);	if(!m_fMeasurement)	{	return false;	}
	pTemplate->InitialUpdateFrame(m_fMeasurement, NULL, TRUE);
	m_vMeasurement=(CMeasurementView*)m_fMeasurement->GetActiveView();
	ASSERT_VALID(m_vMeasurement);	if(!m_vMeasurement)	{	return false;	}
	m_fMeasurement->SetCaption(GETMESSAGE(1768));
	m_fMeasurement->ShowWindow(SW_HIDE);

	//CMessage::m_erLog.ReportError("Measurement Done");

	//	NOTE	 : Make Sure the Monitor Screens are Created at the End.
	//	Reason : The First MonitorView Keeps a Pointer to the Level Caliper From the CReviewView.
	if( !IsArgument(_T("NO_MONITOR_SCREEN")) )	
	{
		m_fMonitor = new CMonitorChildFrame;
		ASSERT_VALID(m_fMonitor);	if(!m_fMonitor)	{	return false;	}
		m_fMonitor->Create( GETMESSAGE(296), m_fMain, WM_MONITOR_VIEW);
		m_fMonitor->ShowWindow(SW_HIDE);
		
		//CMessage::m_erLog.ReportError("m_fMonitor Done");
	}

	m_fRealTime = new CRealTimeChildFrame;
	ASSERT_VALID(m_fRealTime);	if(!m_fRealTime)	{	return false;	}
	m_fRealTime->Create( GETMESSAGE(297), m_fMain, WM_REALTIME_VIEW);
	m_fRealTime->ShowWindow(SW_HIDE);

	//CMessage::m_erLog.ReportError("m_fRealTime Done");

	pTemplate = new CMultiDocTemplate(	IDR_WORKMATE,						   
													NULL,
													RUNTIME_CLASS(CRealTimeChildFrameBar),	
													RUNTIME_CLASS(CRealTimeBarView) );
	ASSERT_VALID(pTemplate);	if(!pTemplate)	{	return false;	}
	AddDocTemplate(pTemplate);
	m_fRealTimeBar = (CRealTimeChildFrameBar*) pTemplate->CreateNewFrame(NULL, NULL);
	ASSERT_VALID(m_fRealTimeBar);	if(!m_fRealTimeBar)	{	return false;	}
	pTemplate->InitialUpdateFrame(m_fRealTimeBar, NULL, TRUE);
	m_vRealTimeBar=(CRealTimeBarView*)m_fRealTimeBar->GetActiveView();
	ASSERT_VALID(m_vRealTimeBar);	if(!m_vRealTimeBar)	{	return false;	}
	m_fRealTimeBar->ShowWindow(SW_HIDE);

	//CMessage::m_erLog.ReportError("m_fRealTimeBar Done");

	return true;
}



void CWMApp::DestroyReviewWindows(void)
{
	if(m_fPrevReview!=NULL)
	{
		delete m_fPrevReview;
		m_fPrevReview = NULL;
	}

	if(m_fChart!=NULL)
	{
		delete m_fChart;
		m_fChart = NULL;
	}

	if(m_fReview!=NULL)
	{
		delete m_fReview;
		m_fReview = NULL;
	}

	if(m_fMapping!=NULL)
	{
		delete m_fMapping;
		m_fMapping = NULL;
	}

	if(m_fMonitor!=NULL)
	{
		delete m_fMonitor;
		m_fMonitor = NULL;
	}

	if(m_fRealTime!=NULL)
	{
		delete m_fRealTime;
		m_fRealTime = NULL;
	}
}

BOOL CWMApp::SetDefaultCursor(const UINT uiHitTest)
{
	if(uiHitTest==HTLEFT || uiHitTest==HTRIGHT)
	{
		::SetCursor(m_hEastWest); 
		return TRUE;
	}
		
	if(uiHitTest== HTTOP || uiHitTest==HTBOTTOM)
	{
		::SetCursor(m_hNorthSouth); 
		return TRUE;
	}

	if(uiHitTest==HTTOPLEFT || uiHitTest==HTBOTTOMRIGHT)
	{
		::SetCursor(m_hSouthEast); 
		return TRUE;
	}

	if(uiHitTest==HTTOPRIGHT || uiHitTest==HTBOTTOMLEFT)	
	{
		::SetCursor(m_hSouthWest); 
		return TRUE;
	}

	::SetCursor( m_hDefaultCursor );	return TRUE;	
}

BOOL CWMApp::SetCursor(const UINT uiHitTest)
{
	switch (m_eCursor) 
	{
		case	eDefaultCursor	:	return SetDefaultCursor(uiHitTest);	
		case	eNullCursor		:	::SetCursor( m_hNullCursor );		return TRUE;
		case	eHandCursor		:	::SetCursor( m_hHandCursor );    return TRUE;
	}

	return FALSE;
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::Initialize()

	Description		:	This function initializes the database views read from the
							file.

	Returns			:	true-Success, false-failure.

	Setup				:	1.	Open the database window.

	Testing			:	1. Left mouse click on the 'Views' button. Verify the 
							database view list dialog displays.
							2. Left mouse click on the second list item. Verify the
							item is selected.
							3. Left mouse click on the 'Edit' button. Verify the Edit
							database view dialog displays.
							4. Left mouse click on the 'PRE' check box cotnrol. Verify 
							the control is unchecked.
							5. Left mouse click on the 'POST' check box cotnrol. Verify 
							the control is unchecked.
							6. Left mouse click on the 'Save' button. Verify the dialog
							box closes.
							7. Left mouse click on the 'Select' button. Verify the 'PRE'
							and 'POST' database tab window does not display.
							8. Press the 'Exit' button on the MainBar. Verify the 'Are you
							sure you want to leave' prompt window displays.
							9. Left mouse click on the 'Yes' button. Verify the shell displays.
							10. Left mouse click on the 'Begin/Review Study' button. Verify
							the opening screen displays.
							11. Press the 'Database' button on the MainBar. Verify the database
							window displays. Verify the selected view displays. Verify the 'PRE'
							and 'POST' database tab window does not display.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
bool CWMApp::Initialize(bool /*bNewStudy*/)
{
	#if defined(DEMO_CD_ROM)
		#ifdef ALLURA_TSM
			//m_dCathMap.m_CathMap.iAutoRecordMode= m_INIfile.m_iAutoRecordDefault;
		#else
			m_dCathMap.m_CathMap.iAutoRecordMode= AUTO_RECORD_OFF;
		#endif
	#else
		#ifdef PHILIPS_VIEWER
			m_dCathMap.m_CathMap.iAutoRecordMode= 0;
		#else
			//m_dCathMap.m_CathMap.iAutoRecordMode= m_INIfile.m_iAutoRecordDefault;
		#endif
	#endif

	m_bDisplayIntervals=true; // on by default

	CString csSpeed( m_dCathMap.GetSpeedIndex(m_dCathMap.m_CathMap.cathmap[m_dCathMap.m_iProtocol].sweep_speed) );

	if( CWMLibrary::IsSafeWindow(m_fMonitor)	&&
		 CWMLibrary::IsSafeWindow(m_fMonitor->m_vMonitor))	
	{
		m_fMonitor->SetCaption();
	}

	if( CWMLibrary::IsSafeWindow(m_fRealTime)	&&
		 CWMLibrary::IsSafeWindow(m_fRealTime->m_dlgBar) )	
	{
		m_fRealTime->m_dlgBar->SetSweepIcon( (m_dMonitor.m_shSignalHeader.map.wiper) );
	}

	m_dPrevReview.GetCurrentLogPage();
	m_vPrevReview->InvalidateView();

	m_dReview.GetCurrentLogPage();
	m_vReview->InvalidateView();

	m_dLog.CreateLogEntriesMenu();
	m_vLog->DrawLogEntries();

	m_dChart.CreateChartEntriesMenu();
	m_vChart->DrawChartEntries();

	RecordDisplay();

#ifndef PHILIPS_VIEWER
	m_Stim.ResetStimButtons();
#endif

	// Reset the Holter Here.
	m_dHolter.m_bHolterLoad=true; 
   m_dHolter.HolterLoadInit();
   m_dHolter.m_iInit = 1;	

	m_vHolter->InvalidateView();
	m_fHolter->m_pHolterDialogBar->SetChannel(CA2T((PCHAR)m_dHolter.m_HolterConfig.name));

	// Initialize the Trace mechanism only at the end.
//#ifdef _DEBUG
	m_Trace.Initialize();
//#endif

	m_vRF->SetTab((m_INIfile.m_iRFGeneratorInstalled==RF_CRYO_CATH) ? ePageFour : ePageOne);
	m_vRF->MorphGeneratorData();
	
#ifndef PHILIPS_VIEWER
	#ifdef ALLURA_TSM
	m_TSM.m_bReadyForAllura = true;
	#endif
#endif

	if(m_dCine.m_bInstalled)
	{
		// This is get the Interrupt
		::SendNotifyMessage(HWND_BROADCAST, m_arMessage[WM2CINE_SIGNAL_CINE].uiId, 0, 0);
	}

	DisableOnViewOnly();

	CString csErr;
	switch(LoadDBViews())
	{
		default								:
		case	DB_VIEW_FILE_NOT_FOUND	:
		{
			m_iCurrentDBView = 0;
			for(register short iIndex=0; iIndex<DBVIEW_MAX_VIEWS; ++iIndex)
			{
				m_arDBView[iIndex] = m_sAll;

				if(iIndex>=1)
				{
					_stprintf(m_arDBView[iIndex].szName, GETMESSAGE(1767), iIndex);
				}
			}

			CMessage::PopupMessage(WMFILELINE, 1671);
		}
		break;

		case	DB_VIEW_FILE_VERSION_ERROR	:
		{
			m_iCurrentDBView = 0;
			for(register short iIndex=0; iIndex<DBVIEW_MAX_VIEWS; ++iIndex)
			{
				m_arDBView[iIndex] = m_sAll;

				if(iIndex>=1)
				{
					_stprintf(m_arDBView[iIndex].szName, GETMESSAGE(1767), iIndex);
				}
			}

			CMessage::PopupMessage(WMFILELINE, 1847);
		}
		break;

		case	DB_VIEW_FILE_CORRUPTED		:
		{
			m_iCurrentDBView = 0;
			for(register short iIndex=0; iIndex<DBVIEW_MAX_VIEWS; ++iIndex)
			{
				m_arDBView[iIndex] = m_sAll;

				if(iIndex>=1)
				{
					_stprintf(m_arDBView[iIndex].szName, GETMESSAGE(1767), iIndex);
				}
			}

			CMessage::PopupMessage(WMFILELINE, 1848);
		}
		break;

		case	DB_VIEW_FILE_SUCCESS			:
		{ 
			if((m_arDBView[0].iMaxTabs<=0) || (!m_arDBView[0].szName[0])) 
			{
				m_iCurrentDBView = 0;
				MEMSET(m_arDBView);
				
				for(register short iIndex=0; iIndex<DBVIEW_MAX_VIEWS; ++iIndex)
				{
					m_arDBView[iIndex] = m_sAll;

					if(iIndex>=1)
					{
						_stprintf(m_arDBView[iIndex].szName, GETMESSAGE(1767), iIndex);
					}
				}
			}
		}
		break;
	}

	m_vDB->SetDatabaseWindow();

	#if defined(DEMO_CD_ROM)

	#else								// Server

#ifndef PHILIPS_VIEWER		
	
	if(m_INIfile.m_bNurseMateInstalled)
	{		
		if(!m_sNM.m_bConnected)
		{
			DWORD dwResponseTime = 0;
			if(m_sNM.Ping(WSA_NURSE_MATE_PORT, m_INIfile.m_szWMDataIPAddress, dwResponseTime))
			{
				if(!m_sNM.StartListening(WSA_NURSE_MATE_PORT, m_INIfile.m_szWMDataIPAddress))
				{
					// Message 1766 only takes two parameters which doesn't fit this format
					CString cs(_T("Cannot open IP Address %s, %s, %u"));
					Log(eNMTrace, true, cs, m_INIfile.m_szWMDataIPAddress, m_sNM.m_szError, dwResponseTime);
				}
				else
				{
					// Message 1765 only takes two parameters which doesn't fit this format
					CString cs(_T("Started NurseMate Server at %s, %u"));
					Log(eNMTrace, true, cs, m_INIfile.m_szWMDataIPAddress, dwResponseTime);
				}
			}
			else
			{
				CString cs(_T("Hardware Error at %s, %s, %u"));
				Log(eNMTrace, true, cs, m_INIfile.m_szWMDataIPAddress, m_sNM.m_szError, dwResponseTime);
			}
		}
		else
		{
			Transmit(WM2NM_PATIENT_CHANGE);
		}
	}
#endif
	#endif

#ifdef ENABLE_CARTO
	if(theApp.m_INIfile.m_usMappingSystemInstalled==MAPPING_SYSTEM_CARTO)
	{
		CATMCartoMapDialogBar* pCarto = dynamic_cast<CATMCartoMapDialogBar*>(theApp.m_fMapping->m_pATMMapBar);
		pCarto->SetCLState();
	}
#endif

#ifdef PHILIPS_VIEWER
	CRect crMainBar(m_MainBar.m_crArea);

	const int iWidth = CWMLibrary::GetDesktopWidth();
	int iHeight	=	::GetSystemMetrics(SM_CYSCREEN);
	iHeight		-=	crMainBar.Height();

	CRect crScreen(0, 0,0,0);
	crScreen.left	= crMainBar.left;
	crScreen.top	= crMainBar.bottom;
	crScreen.right	= crScreen.left+iWidth;
	crScreen.bottom= crScreen.top+iHeight;

	m_MainBar.PositionWindow(0, crScreen);

#endif

	return true;
}


/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::LoadDBViews()

	Description		:	This function load the database views from the file.

	Returns			:	None.

	Setup				:	1.	Open the database window.

	Testing			:	1. Left mouse click on the 'Views' button. Verify the 
							database view list dialog displays.
							2. Left mouse click on the second list item. Verify the
							item is selected.
							3. Left mouse click on the 'Edit' button. Verify the Edit
							database view dialog displays.
							4. Left mouse click on the 'PRE' check box cotnrol. Verify 
							the control is unchecked.
							5. Left mouse click on the 'POST' check box cotnrol. Verify 
							the control is unchecked.
							6. Left mouse click on the 'Save' button. Verify the dialog
							box closes.
							7. Left mouse click on the 'Select' button. Verify the 'PRE'
							and 'POST' database tab window does not display.
							8. Press the 'Exit' button on the MainBar. Verify the 'Are you
							sure you want to leave' prompt window displays.
							9. Left mouse click on the 'Yes' button. Verify the shell displays.
							10. Left mouse click on the 'Begin/Review Study' button. Verify
							the opening screen displays.
							11. Press the 'Database' button on the MainBar. Verify the database
							window displays. Verify the selected view displays. Verify the 'PRE'
							and 'POST' database tab window does not display.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/

short CWMApp::LoadDBViews(void)
{
	short iRetVal = DB_VIEW_FILE_SUCCESS;

	m_iCurrentDBView = 0;

	MEMSET(m_arDBView);

	TCHAR szFullPath[MAX_PATH] = {0};

	if(m_INIfile.m_szDBViewsPath[0])
	{
		CFileDB::MakeFileName(m_INIfile.m_szDBViewsPath, DBVIEW_FILE_NAME, szFullPath, sizeof(szFullPath));
	}
	else
	{
		MakePath(DBVIEW_FILE_NAME, szFullPath, sizeof(szFullPath));
	}

	HANDLE hFile = ::CreateFile(szFullPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if( (hFile==NULL) || (hFile==INVALID_HANDLE_VALUE) )
	{
		// Open failed set the current view to the default one.

		CString csMessage;  csMessage.Format(GETMESSAGE(1670), szFullPath);
		CMessage::PopupMessage(WMFILELINE, csMessage);
		iRetVal = DB_VIEW_FILE_NOT_FOUND;
		return iRetVal;
	}

	DWORD dwPos = ::SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

	SDBViewHeader sHeader = {0}; 
	DWORD dwRead	=	0U;
	BOOL	bSuccess =	::ReadFile(hFile, &sHeader, sizeof(sHeader), &dwRead, NULL);
	
	if(bSuccess && (sizeof(sHeader)==dwRead))
	{
		if( (sHeader.usVersion==DBVIEWS_VERSION)												&& 
			 (sHeader.usMaxRecords>0 && sHeader.usMaxRecords<=DBVIEW_MAX_VIEWS)		&&
			 (sHeader.usActiveRecord>=0 && sHeader.usActiveRecord<DBVIEW_MAX_VIEWS	&& 
			  sHeader.usActiveRecord<sHeader.usMaxRecords) )
		{
			dwPos = ::SetFilePointer(hFile, sizeof(sHeader), NULL, FILE_BEGIN);

			for(register short iRecord=0; iRecord<DBVIEW_MAX_VIEWS; ++iRecord)
			{
				SFileRecord<SDBView> sRecord = {0};

				dwRead	=	0U;
				bSuccess =	::ReadFile(hFile, &sRecord, sizeof(sRecord), &dwRead, NULL);

				if(!bSuccess || (dwRead!=sizeof(sRecord)))
				{
					bSuccess = false;
					iRetVal = DB_VIEW_FILE_CORRUPTED;
					break;
				}

				if((sRecord.ucCRC<=0) || 
					(sRecord.ucCRC!=::CheckSum5((PUCHAR)&sRecord.sData, sizeof(sRecord.sData))))
				{
					bSuccess = false;
					iRetVal = DB_VIEW_FILE_CORRUPTED;
					break;
				}

				m_arDBView[iRecord] = sRecord.sData;
			}
		}
		else
		{
			// Force it to be a corrupted file and delete it.
			iRetVal = DB_VIEW_FILE_VERSION_ERROR;
			bSuccess=false;
		}
	}
	else
	{
		// File corrupted
		iRetVal = DB_VIEW_FILE_CORRUPTED;
		bSuccess=false;
	}

	::CloseHandle(hFile);
	hFile=INVALID_HANDLE_VALUE;	

	if(bSuccess)
	{
		m_iCurrentDBView = sHeader.usActiveRecord;
		iRetVal = DB_VIEW_FILE_SUCCESS;
	}
	else
	{
		m_iCurrentDBView = 0;
		MEMSET(m_arDBView);
	}

	return iRetVal;
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::SaveDBViews()

	Description		:	This function saves the database views to the file.

	Returns			:	None.

	Setup				:	1.	Open the database window.

	Testing			:	1. Left mouse click on the 'Views' button. Verify the 
							database view list dialog displays.
							2. Left mouse click on the second list item. Verify the
							item is selected.
							3. Left mouse click on the 'Edit' button. Verify the Edit
							database view dialog displays.
							4. Left mouse click on the 'PRE' check box cotnrol. Verify 
							the control is unchecked.
							5. Left mouse click on the 'POST' check box cotnrol. Verify 
							the control is unchecked.
							6. Left mouse click on the 'Save' button. Verify the dialog
							box closes.
							7. Left mouse click on the 'Select' button. Verify the 'PRE'
							and 'POST' database tab window does not display.
							8. Press the 'Exit' button on the MainBar. Verify the 'Are you
							sure you want to leave' prompt window displays.
							9. Left mouse click on the 'Yes' button. Verify the shell displays.
							10. Left mouse click on the 'Begin/Review Study' button. Verify
							the opening screen displays.
							11. Press the 'Database' button on the MainBar. Verify the database
							window displays. Verify the selected view displays. Verify the 'PRE'
							and 'POST' database tab window does not display.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::SaveDBViews(void)
{
	TCHAR szFullPath[MAX_PATH] = {0};

	if(m_INIfile.m_szDBViewsPath[0])
	{
		CFileDB::MakeFileName(m_INIfile.m_szDBViewsPath, 
									 DBVIEW_FILE_NAME, 
									 szFullPath, 
									 sizeof(szFullPath));
	}
	else
	{
		MakePath(DBVIEW_FILE_NAME, szFullPath, sizeof(szFullPath));
	}

	if((m_arDBView[0].iMaxTabs<=0) || 
		(!m_arDBView[0].szName[0])) 
	{
		m_iCurrentDBView = 0;
		MEMSET(m_arDBView);
		
		for(register short iIndex=0; iIndex<DBVIEW_MAX_VIEWS; ++iIndex)
		{
			m_arDBView[iIndex] = m_sAll;

			if(iIndex>=1)
			{
				_stprintf(m_arDBView[iIndex].szName, GETMESSAGE(1767), iIndex);
			}
		}
	}

	HANDLE hFile = ::CreateFile(szFullPath, 
										 GENERIC_READ|GENERIC_WRITE, 
										 0, 
										 NULL, 
										 CREATE_ALWAYS, 
										 FILE_ATTRIBUTE_NORMAL, 
										 NULL);

	if( (hFile==NULL) || (hFile==INVALID_HANDLE_VALUE) )
	{
		CString csMessage;  csMessage.Format(GETMESSAGE(1670), szFullPath);
		CMessage::PopupMessage(WMFILELINE, csMessage);
		return;
	}

	DWORD dwPos = ::SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

	SDBViewHeader sHeader = { DBVIEWS_VERSION, DBVIEW_MAX_VIEWS, m_iCurrentDBView };

	DWORD dwWrite	=	sizeof(SDBViewHeader);
	DWORD dwWritten=	0;
	BOOL bSuccess = ::WriteFile(hFile, (LPCVOID)&sHeader, dwWrite, &dwWritten, NULL);

	dwPos = ::SetFilePointer(hFile, sizeof(SDBViewHeader), NULL, FILE_BEGIN);
	
	if(bSuccess && (dwWrite==dwWritten))
	{
		for(register short iRecord=0; iRecord<DBVIEW_MAX_VIEWS; ++iRecord)
		{
			SFileRecord<SDBView> sRecord = {0};

			sRecord.sData = m_arDBView[iRecord];
			sRecord.ucCRC = ::CheckSum5((PUCHAR)&sRecord.sData, sizeof(sRecord.sData));

			dwWrite	=	sizeof(sRecord);
			dwWritten=	0;
			bSuccess = ::WriteFile(hFile, (LPCVOID)&sRecord, dwWrite, &dwWritten, NULL);
		}
	}

	::CloseHandle(hFile);
	hFile=INVALID_HANDLE_VALUE;
}

void CWMApp::DisableOnViewOnly(void)
{
	// 1. Mapping Window
	if(m_fMapping)
	{
		m_fMapping->DisableOnViewOnly();
	}

	// 2. Log Window
	if(m_fLog)
	{
		if(m_fLog->m_pLogDialogBar)
		{
			m_fLog->m_pLogDialogBar->DisableOnViewOnly();
		}
	}

	// 3. Chart Window
	if(m_fChart)
	{
		if(m_fChart->m_pChartDialogBar)
		{
			m_fChart->m_pChartDialogBar->DisableOnViewOnly();
		}

		if(m_fChart->m_pChartEventDialogBar)
		{
			m_fChart->m_pChartEventDialogBar->DisableOnViewOnly();
		}
	}

	// 4. CathMap Screen
#ifndef PHILIPS_VIEWER
	if(m_vCathMap)
	{
		m_vCathMap->DisableOnViewOnly();
	}
#endif
	
	//5. MainBar
	m_MainBar.DisableOnViewOnly();
}

void CWMApp::TerminateAllCalipers(bool bRefresh)
{
	m_eCursor	=	eDefaultCursor;
	m_eCaliper	=	eNoneCaliper;

	m_vReview->m_cprPoint.Reset();
	m_vReview->m_cprLine.Reset();
	m_vReview->m_cprFullLine.Reset();
	m_vReview->m_cprHorz.Reset();
	m_vReview->m_cprVert.Reset();
	m_vReview->m_cprLevel.Reset();
		
	m_vPrevReview->m_cprPoint.Reset();
	m_vPrevReview->m_cprLine.Reset();
	m_vPrevReview->m_cprFullLine.Reset();
	m_vPrevReview->m_cprHorz.Reset();
	m_vPrevReview->m_cprVert.Reset();
	m_vPrevReview->m_cprLevel.Reset();
	
	m_vHolter->m_cprPoint.Reset();
	m_vHolter->m_cprLine.Reset();
	m_vHolter->m_cprFullLine.Reset();
	m_vHolter->m_cprHorz.Reset();

	m_fMonitor->m_vMonitor.m_cprPoint.Reset();
	m_fMonitor->m_vMonitor.m_cprHor.Reset(true);
	m_fMonitor->m_vMonitor.m_cprVer.Reset(true);
	m_fMonitor->m_vMonitor.m_cprLevel.Reset();

	m_vATMMap->m_cprHorz.Reset();
	m_vATMMap->m_cprVert.Reset();

	if(bRefresh)	
	{
		m_vReview->InvalidateView();
		m_vPrevReview->InvalidateView();
		m_vHolter->InvalidateView();
		m_fMonitor->m_vMonitor.Invalidate();
		m_vATMMap->InvalidateView();
	}
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::SelectCathMap()

	Description		:	This function checks the current study for an existing 
							cathmap and it is loaded. If the cathmap is not set the 
							passed cathmap is loaded.

	Returns			:	None.

	Setup				:	1. Launch the EP-WorkMate application.

	Testing			:	1.	Left mouse click on the 'Begin/Review Study' button.
							Verify the opening menu window displays.
							2. Verify the 'Begin New Study' radio button is selected.
							3. Enter the Patient name and Id in the edit boxes.
							Verify the name and id displays.
							4. Verify the first cathmap from the list is selected.
							5. Left mouse click on the 'Start' button. Verify the 
							study is created.
							6. Press the 'Update Review' keystroke. Verify the recording
							starts and stops. Verify the review screen updates.
							7. Left mouse click on the 'Exit' button. Verify the 'Are yuo
							sure you want to leave' prompt displays.
							8. Left mouse click on the 'Yes' button. Verify the shell displays.
							9. Repeat Step 1. Left mouse button click on the patient name from
							the list control. Verify the patient is selected. Verify the name
							and the id displays in the edit boxes.
							10. Left mouse click on the 'Cathmap Name' list box control. Verify 
							the combo box drops down. Verify the cathmaps display.
							11. Left mouse click on the second item in the list box control. Verify
							the chosen cathmap is selected.
							12. Repeat Step 5. Verify 'Add a New Study for ' the patient prompts.
							13. Left mouse click on the 'Yes' button. Verify the study is created.
							14. Repeat Steps 6-8. Repeat Step 1. 
							15. Left mouse click on the 'Edit Previous Study' radio button. Verify the 
							conrol is selected.
							16. Left mouse button click on the patient name from
							the list control. Verify the patient is selected. Verify the name
							and the id displays in the edit boxes.
							17. Left mouse click on the 'Start' button. Verify the 'Studies of' window
							displays the two previous studies with different Study types.
							18. Left mouse click on the first one item in list control. Verify the study
							is loaded. Verify the cathmap name displays on the caption.
							19. Left mouse click on the 'DataBase' button. Verify the database button
							displays.
							20. Left mouse click on the 'Select' button under the Study group. Verify the
							'Availabe Studies of' list box window displays. 
							21. Left mouse button click on the second item entry in the list box control.
							Verify the second study loads. Verify the cathmap name displays on the caption.
							22. Verify the cathmap names are changing according to the studies.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::SelectCathMap(const CString& csCathmap)
{
	// ask study type and load it
	if( !csCathmap.IsEmpty() ) 
	{	 
		if(m_dProcedure.m_Procedure.study_type[0] && 
			csCathmap.CompareNoCase(CA2T((PCHAR)m_dProcedure.m_Procedure.study_type))!=0 )
		{
			// Load the Cathmap associated with the Study.
			m_dCathMap.SelectCathMap(CA2T((PCHAR)m_dProcedure.m_Procedure.study_type));
		} 
		else 
		{
			m_dCathMap.SelectCathMap(csCathmap);	
		}
	}
}

// --------------------------------------------------------------------
// Enforce business rules for not allowing requested study to be opened
// Return value: true if a restriction exists for opening the study
// --------------------------------------------------------------------
bool CWMApp::EnforceOpenStudyRestrictions(eStudyOpenMode requestedStudyMode)
{
	int iMessageFileErrorID = 0; // No errors until restrictions are checked

	// Restriction: PowerPoint is open
	if ( (requestedStudyMode == eOpenNewStudy || requestedStudyMode == eOpenContinuedStudy ) && 
		CReport::FindLibreOfficeImpress(NULL))
	{
		iMessageFileErrorID = 2287;
	}
	// Add additional restrictions here
	//else if {} ... 

	bool bPreventStudyOpen = ( 0 < iMessageFileErrorID );

	// Force user to acknowledge reason that study was prevented from opening
	if ( bPreventStudyOpen )
	{
		CMessage::DisplayError(WMFILELINE, iMessageFileErrorID);
		if (CReport::IsLibreOfficeImpressInstalled())
		{
			theApp.LibreOfficeImpress().Show();
		}
	}
	else
	{
		m_eStudyMode = requestedStudyMode;
		if (m_eStudyMode == eOpenPreviousStudy)
		{
			SetModePassive();
		}
		else
		{
			SetModeActive();
		}
	}

	return bPreventStudyOpen;
}

#if defined(ALLURA_TSM) && !defined(PHILIPS_VIEWER)

/// iRetVal : 
//	-1	-	ASSERT
//	0	-	Patient Exists, New Study
//	1	-	New Patient, New Study
//	2	-	Patient Exists, Old Study
bool CWMApp::OpenScreen(SPatient& rPatient, SProcedure& rProcedure, SAlluraCase& rAllura, SHORT& iRetVal)
{
	bool retry = false;

	bool bNewSession = false;

	do {
	
  	COpenScreen opScreen( AfxGetMainWnd(), rPatient, rProcedure, rAllura );

	if( opScreen.DoModal() == IDOK)	
   {			
		//CMessage::m_erLog.ReportError("After opScreen.DoModal");
		if ( EnforceOpenStudyRestrictions( opScreen.GetStudyOpenMode() ) )
		{
			retry = true;
		}
		else
		{
			SetDemoMode( opScreen.IsDemo() );
			
			//CMessage::m_erLog.ReportError("After SetDemoMode");

			bool bPatientExists = false;
			TCHAR billingNumber[26] = {0};
			TCHAR caseNumber[13] = {0};
			::WMStrnCpy(caseNumber, CA2T((PCHAR)theApp.m_dProcedure.m_Procedure.case_number), sizeof(caseNumber));
			::WMStrnCpy(billingNumber, CA2T((PCHAR)theApp.m_dProcedure.m_Procedure2.billing), sizeof(billingNumber));
		
			if (!opScreen.m_csPatient.IsEmpty() )
			{
				::strncpy((PCHAR)m_dPatient.m_Access.m_pIndex->key1, 
								CT2A(opScreen.m_csPatient), 
								m_dPatient.m_Access.m_pIndex->key1_length);
				
				::strncpy((PCHAR)m_dPatient.m_Access.m_pIndex->key2, 
								CT2A(opScreen.m_csId), 
								m_dPatient.m_Access.m_pIndex->key2_length);
				
				if(m_dPatient.GetMasterRecord(GET_FROM_INDEX, LOCK_EDIT, 9999))
				{
					// This is the case where a new study is being started but the patient name was not picked from the list
					// Force the name to have commas in it for storage as of Claris 1.1.1
					CString full, last, first, mid;
					theApp.m_dPatient.ParsePatientName(m_dPatient.m_Access.m_pIndex->key1, first, mid, last);
					theApp.m_dPatient.BuildPatientName(full, first, mid, last);
					::strncpy((PCHAR)m_dPatient.m_Access.m_pIndex->key1, CT2A(full), ARRAY_SIZE(m_dPatient.m_Patient.name));

					// if the name won't retrieve, store it
					::strncpy((PCHAR)m_dPatient.m_Patient.name,
									(PCHAR)m_dPatient.m_Access.m_pIndex->key1, 
									ARRAY_SIZE(m_dPatient.m_Patient.name));
					
					::strncpy((PCHAR)m_dPatient.m_Patient.id,
									(PCHAR)m_dPatient.m_Access.m_pIndex->key2, 
									ARRAY_SIZE(m_dPatient.m_Patient.id));

					m_dPatient.m_Access.PutRecord();
				}
				else
				{
					bPatientExists = true;
				}
			}

			//CMessage::m_erLog.ReportError("After opScreen.m_csPatient.IsEmpty()");
			
			eStudyOpenMode uiSelectedStudyMode = opScreen.GetStudyOpenMode();
			switch( uiSelectedStudyMode )	// new study
			{
				case	eOpenNewStudy	:
				{
					//CMessage::m_erLog.ReportError("In eOpenNewStudy");
					
					if(bPatientExists)
					{
						iRetVal = 0;
						AfxTrace(_T("NEW-> Exists"));

						//CMessage::m_erLog.ReportError("Before m_dProcedure.m_Access.FreeRecord()");
						m_dProcedure.m_Access.FreeRecord();
						m_dProcedure.m_Access.InitRecord();

						// get the HL7 import information (zero filled if we did not perform a HL7 import)
						CHL7::SImportPatient& rRecord = CHL7::GetPrototypeInstance();

						// are we creating a new study for the patient that was imported via HL7?
						if (!::_tcsncmp(rRecord.name, CA2T((PCHAR)m_dPatient.m_Patient.name), KEY1_LENGTH) && !::_tcsncmp(rRecord.id, CA2T((PCHAR)m_dPatient.m_Patient.id), KEY2_LENGTH))
						{
							// prepopulate study fields with information that was retrieved via HL7

							// incoming height is in inches, database expects centimeters.
							const int height = int(::_tstoi(rRecord.height) * float(2.54) + float(0.5));
							// incoming weight is in lbs, database also expects lbs.
							const int weight = ::_tstoi(rRecord.weight);

							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.case_number, CT2A(rRecord.caseNumber), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.case_number));
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure2.billing, CT2A(rRecord.billingNumber), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure2.billing));
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.referring, CT2A(rRecord.refdr), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.referring));
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.primary, CT2A(rRecord.primaryPhysician), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.primary));
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.physician2[0], CT2A(rRecord.attendingPhysician), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.physician2[0]));
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.date, CT2A(rRecord.visitDate), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.date));

							// Note: truncated to maximum short rather than unsigned
							// short because this code likes to cast values to a short.
							theApp.m_dProcedure.m_Procedure.height = min(max(0, height), SHRT_MAX);
							theApp.m_dProcedure.m_Procedure.weight = min(max(0, weight), SHRT_MAX);

							// order number and visit number are not represented in the database, we place  them
							// in the USER database tab (as the fourth user text entry).

							TCHAR pszBuffer[500] = {0};
							std::memset(pszBuffer, 0, sizeof(pszBuffer));
							_sntprintf(
								pszBuffer,
								(sizeof(pszBuffer) / sizeof(TCHAR)) - 1,
								GETMESSAGE(2229),
								rRecord.orderID,
								rRecord.visitNumber
							);
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.other4[3], CT2A(pszBuffer), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.other4[3]));
							::WMStrnCpy(
								theApp.m_dProcedure.m_pszAccessionNumber,
								rRecord.accessionNumber,
								sizeof(theApp.m_dProcedure.m_pszAccessionNumber)
							);
						}

						//CMessage::m_erLog.ReportError("Before SelectCathMap(opScreen.m_csCathmap)");
						// ask study type and load it
						SelectCathMap(opScreen.m_csCathmap);

						//CMessage::m_erLog.ReportError("Before m_dProcedure.StoreProcedure");
						m_dProcedure.StoreProcedure();
						m_dProcedure.SaveDICOMAccessionNumber();
					}
					else
					{
						iRetVal = 1;
						AfxTrace(_T("NEW-> NEW"));

						//CMessage::m_erLog.ReportError("Before SelectCathMap(opScreen.m_csCathmap)");
						// ask study type and load it
						SelectCathMap(opScreen.m_csCathmap);

						//CMessage::m_erLog.ReportError("Before m_dProcedure.StoreProcedure");
						m_dProcedure.StoreProcedure();
						
		#ifdef ALLURA_TSM
					m_bPrimaryEdited		=	false;
					m_bReferringEdited	=	false;
		#endif

						//CMessage::m_erLog.ReportError("Before NewSession()");
						NewSession();
						//CMessage::m_erLog.ReportError("After NewSession()");
					}

					if((opScreen.m_csPatient.Compare(CA2T((PCHAR)rPatient.name))!=0) &&
						(opScreen.m_csId.Compare(CA2T((PCHAR)rPatient.id))!=0) )
					{
						// User has overridden the Alura's Patient & Id
						// Wants to create a different patient with a new study
						if(!opScreen.m_csPatient.IsEmpty())
						{
							iRetVal = bPatientExists ? 3 : 4;
						}
						else
						{	
							// User right click on the dialog without the patient.
							iRetVal = 5;
						}
					}

					SetModeActive();
					SetStateControls();

					bNewSession = true;
					retry = false;
				}
				break;
			
				case eOpenPreviousStudy	:
				{	
					// edit old study
					iRetVal = (!opScreen.m_csPatient.IsEmpty()) ? 2 : 5;
					// pull in the study type
					
                    // The returned mode is the highest level allowed for the study.
                    // We are opening in "review mode" which is always allowed.
					m_dProcedure.SelectProcedure(true);

					m_dProcedure.StoreProcedure();
					
					retry = false;

					SetModePassive();
					SetStateControls();

					// ask study type and load it
					SelectCathMap(opScreen.m_csCathmap);
				}
				break;
				case eOpenContinuedStudy	:
				{	// continue study
					iRetVal = (!opScreen.m_csPatient.IsEmpty()) ? 2 : 5;
					// pull in the study type

                    // The returned mode is the highest level allowed for the study.
                    // That might be lower then "continue" mode so check for match.
					retry = (m_dProcedure.SelectProcedure(true) != uiSelectedStudyMode);
					if (!retry)
					{
						m_dProcedure.StoreProcedure();
						SetModeActive();
						SetStateControls();

						// ask study type and load it
						SelectCathMap(opScreen.m_csCathmap);
					}
                    else
                    {
		                CMessage::DisplayError(WMFILELINE, 3102);
                    }
				}
				break;
			}
		}

		// clear out the HL7 import information, if there was any. we want the imported
		// information to persist for at most one new study that gets created. note that
		// this information is cleared out even if it was never used to prepopulate a new
		// study
		if (!retry)
		{
			CHL7::GetPrototypeInstance().Reset();
		
			// This is used for report to find current log dir
			m_INIfile.m_lLastOpenedLogNumber =   theApp.m_dLog.m_lCurrentLogDirNumber;
			m_INIfile.PutLastLogDirectoryNumber();
		}
	    else // We have to reshow the open screen dialog
	    {
            // RLG.10.APR.2013: 
            // The messy structure of all the study selection GUI logic sitting down 
            // here prior and under several call stack layers of biz logic that had
            // previously began selecting a study not wanted by the user, nessesitaties 
            // this block of code to deal with unsuccessful attempts to select a study 
            // with the mode (continue) choosen by the user.

            // Clear out side effects of procedure selection logic that 
            // pre-loaded a default procedure
            ClearProcedureData(); // Same code pri

            // Redo the log / realtime initialization done earlier 
            // a couple levels up the call stack in CWMApp::ReviewScreenStart()
            StartLog();
            StartMasterTimers();

            iRetVal = -1;
        }
   }
	else
	{
      m_dPatient.m_Access.FreeRecord();
      m_dPatient.m_Access.InitRecord();

		iRetVal = -1;
   }

  } while(retry);

	if(CWMLibrary::IsSafeWindow(m_vMeasurement))
	{
		m_vMeasurement->Refresh();
	}

	//CMessage::m_erLog.ReportError("Before m_fChart->TurnOffAutoChartMeasurements()");
	m_fChart->TurnOffAutoChartMeasurements();

	return bNewSession;
}

void CWMApp::ProcessOpenScreen(	CAlluraPatientDataModel&	sPDM, 
											SPatient&						sPatient, 
											SProcedure&						sProcedure, 
											SProcedure2&					sProcedure2, 
											SAlluraCase&					sAllura, 
											SPrePost&						sPrePost, 
											SHORT&							iRetVal, 
											bool&								bNewStudy)
{
#ifndef PHILIPS_VIEWER
	// Allura connections need to be tested with PPT running
	// Unclear if we can flat out skip all processing here when PPT is running
	if ( !EnforceOpenStudyRestrictions(eOpenNewStudy) )
	{
		switch(iRetVal)
		{
		case 0	:	//	0	-	Patient Exists, New Study
			{
				// 1. Assign the TSM attributes
				m_dPatient.m_Patient		=	sPatient;
				m_dProcedure.m_Procedure=	sProcedure;
				m_dProcedure.m_Procedure2	=	sProcedure2;
				m_sAllura					=	sAllura;
				m_dProcedure.m_PrePost	=	sPrePost;

				const bool bReadOnly = m_TSM.IsModelValid();

				// 2. User chose to edit an Old study, disable Auto Update.
				m_TSM.SetAutoUpdate(bReadOnly);

				// 3. Make the DB Fields ReadOnly
				if(CWMLibrary::IsSafeWindow(m_vDB))
				{
					m_vDB->SetReadOnly(bReadOnly);
				}

				/*Check the patient name, patient Id, Assign the StudyInstanceUID*/
			}
			break;

		case 1	:	//	1	-	New Patient, New Study
			{
				// 1. Assign the TSM attributes
				m_dPatient.m_Patient		=	sPatient;
				m_dProcedure.m_Procedure=	sProcedure;
				m_dProcedure.m_Procedure2	=	sProcedure2;
				m_sAllura					=	sAllura;
				m_dProcedure.m_PrePost	=	sPrePost;

				const bool bReadOnly = m_TSM.IsModelValid();

				// 2. User chose to edit an Old study, disable Auto Update.
				m_TSM.SetAutoUpdate(bReadOnly);

				// 3. Make the DB Fields ReadOnly
				if(CWMLibrary::IsSafeWindow(m_vDB))
				{
					m_vDB->SetReadOnly(bReadOnly);
				}

				// continue
			}
			break;	

		case 2	:	//	2	-	Patient Exists, Old Study
			{
			if (::strlen((PCHAR)m_dPatient.m_Patient.name) != 0) // Support for icelandic characters
				{
					// Check to see the old study has the Allura's attributes
					if(m_sAllura.wzStudyInstanceUId[0])
					{
						if(m_TSM.IsValidPatient(sPDM) && m_TSM.IsCurrentPatient(sPDM))
						{
							// Probably pulled an Old Study but is currently active with Allura

							const bool bReadOnly = m_TSM.IsModelValid();

							// 1. Enalbe Auto Update.
							m_TSM.SetAutoUpdate(bReadOnly);
							// 2. Make the DB Fields ReadOnly
							if(CWMLibrary::IsSafeWindow(m_vDB))
							{
								m_vDB->SetReadOnly(bReadOnly);
							}
						}
						else
						{
							// Probably pulled an Old Study but is different than the currently active with Allura's Study OR
							// Allura Study Attributes are NOT valid yet.

							// 1. Disable Auto Update.
							m_TSM.SetAutoUpdate(false);
							// 2. Make the DB Fields Editable
							if(CWMLibrary::IsSafeWindow(m_vDB))
							{
								m_vDB->SetReadOnly(false);
							}
						}
					}
					else
					{
						// Old Study is purely WorkMate's.

						// 1. Disable Auto Update.
						m_TSM.SetAutoUpdate(false);
						// 2. Make the DB Fields Editable
						if(CWMLibrary::IsSafeWindow(m_vDB))
						{
							m_vDB->SetReadOnly(false);
						}
					}
				}
				else
				{
					// User right clicked on the   with Edit Old Study and no patient selected in the Edit Box

					// Check for the Patient in our database
					bool bPatientExists = false;

					::strncpy((PCHAR)m_dPatient.m_Access.m_pIndex->key1, 
						(PCHAR)sPatient.name,
						m_dPatient.m_Access.m_pIndex->key1_length);

					::strncpy((PCHAR)m_dPatient.m_Access.m_pIndex->key2, 
						(PCHAR)sPatient.id,
						m_dPatient.m_Access.m_pIndex->key2_length);

					if(m_dPatient.GetMasterRecord(GET_FROM_INDEX, LOCK_EDIT, 9999))
					{
						// if the name won't retrieve, store it
						::strncpy((PCHAR)m_dPatient.m_Patient.name,
							(PCHAR)m_dPatient.m_Access.m_pIndex->key1, 
							ARRAY_SIZE(m_dPatient.m_Patient.name));

						::strncpy((PCHAR)m_dPatient.m_Patient.id,
							(PCHAR)m_dPatient.m_Access.m_pIndex->key2, 
							ARRAY_SIZE(m_dPatient.m_Patient.id));

						m_dPatient.m_Access.PutRecord();
					}
					else
					{
						bPatientExists = true;
					}

					// Treat it like a new study

					m_bNewStudy=bNewStudy = true;

					if(bPatientExists)
					{
						m_dProcedure.m_Access.FreeRecord();
						m_dProcedure.m_Access.InitRecord();

						m_dProcedure.StoreProcedure();
					}
					else
					{
#ifdef ALLURA_TSM
						m_bPrimaryEdited		=	false;
						m_bReferringEdited	=	false;
#endif
						NewSession();
					}

					// 1. Assign the TSM attributes
					m_dPatient.m_Patient		=	sPatient;
					m_dProcedure.m_Procedure=	sProcedure;
					m_dProcedure.m_Procedure2	=	sProcedure2;
					m_sAllura					=	sAllura;
					m_dProcedure.m_PrePost	=	sPrePost;

					const bool bReadOnly = m_TSM.IsModelValid();

					// 2. User chose to edit an Old study, disable Auto Update.
					m_TSM.SetAutoUpdate(bReadOnly);

					// 3. Make the DB Fields ReadOnly
					if(CWMLibrary::IsSafeWindow(m_vDB))
					{
						m_vDB->SetReadOnly(bReadOnly);
					}

					// continue
				}
			}
			break;	

		case 3	:	//	3	-	Overridden Patient Exists, New Study
			{
				// 1. User chose a different New Patient, disable Auto Update.
				m_TSM.SetAutoUpdate(false);

				// 2. Make the DB Fields ReadOnly
				if(CWMLibrary::IsSafeWindow(m_vDB))
				{
					m_vDB->SetReadOnly(false);
				}

				// 3. Manipulate the flag such that the study is NOT added in the Table.
				m_bNewStudy=bNewStudy = false;
			}
			break;

		case 4	:	//	4	-	Overridden New Patient, New Study
			{
				// 1. User chose a different New Patient, disable Auto Update.
				m_TSM.SetAutoUpdate(false);

				// 2. Make the DB Fields ReadOnly
				if(CWMLibrary::IsSafeWindow(m_vDB))
				{
					m_vDB->SetReadOnly(false);
				}

				// 3. Manipulate the flag such that the study is NOT added in the Table.
				m_bNewStudy=bNewStudy = false;
			}
			break;

		case 5	:	//	5	-	User right clicked on the dialog with out Patient
			{
				ZEROSET(m_dPatient.m_Patient);
				ZEROSET(m_dProcedure.m_Procedure);
				ZEROSET(m_dProcedure.m_Procedure2);
				ZEROSET(m_sAllura);

				// 1. User chose a different New Patient, disable Auto Update.
				m_TSM.SetAutoUpdate(false);

				// 2. Make the DB Fields ReadOnly
				if(CWMLibrary::IsSafeWindow(m_vDB))
				{
					m_vDB->SetReadOnly(false);
				}

				// 3. Manipulate the flag such that the study is NOT added in the Table.
				m_bNewStudy=bNewStudy = false;
			}
			break;

		case -1	:	//	-1	-	ASSERT
		default	:	WMASSERT(0);
			break;	
		}

		if(CWMLibrary::IsSafeWindow(m_vMeasurement))
		{
			m_vMeasurement->Refresh();
		}

		m_fChart->TurnOffAutoChartMeasurements();
#endif
	}
}

bool CWMApp::AlluraIntialize(SPrevRunRecord& sLast, bool& bNewStudy)
{
	bool bAlluraReady = false;

#ifndef PHILIPS_VIEWER
	CAlluraPatientDataModel sPDM;

	if(m_INIfile.m_bTSMInstalled)
	{			
		if(!m_TSM.IsCreated())
		{
			// Show Message : Initializing the TSM
			CWMPopupWindow* pMessageWnd = new CWMPopupWindow;

			if(pMessageWnd)
			{
				pMessageWnd->ShowMessage(1384);
			}

			if(m_TSM.Initialize(&m_MainBar))
			{
				CWMLibrary::Wait(ALLURA_LINK_TIME_OUT);
				
				if( m_TSM.GetPatientModelUpdate(sPDM) )
				{	
					bAlluraReady = (sPDM.bModel && sPDM.bStudyInstanceUId);
				}
			}

			// Hide Message
			if(pMessageWnd)
			{
				pMessageWnd->Hide(pMessageWnd);
			}
		}	
	}

	SPatient		sPatient		=	{0};
	SProcedure	sProcedure	=	{0};
	SProcedure2	sProcedure2	=	{0};
	SAlluraCase	sAllura		=	{0};
	SPrePost		sPrePost		=	{0};	
	SHORT			iRetVal		=	-1;

	if(bAlluraReady)
	{
		if( !sLast.mast_recN) 
		{
			// 1. Assign sPDM to the Database
			CAlluraAdapter::ConvertTSM2WMDatabase(sPDM);

			sPatient	=	m_dPatient.m_Patient;
			sProcedure	=	m_dProcedure.m_Procedure;
			sProcedure2	=	m_dProcedure.m_Procedure2;
			sAllura		=	m_sAllura;
			sPrePost	=	m_dProcedure.m_PrePost;

			m_bNewStudy=bNewStudy = OpenScreen(sPatient, sProcedure, sAllura, iRetVal);

			ProcessOpenScreen(sPDM, 
									sPatient, 
									sProcedure, 
									sProcedure2, 
									sAllura, 
									sPrePost, 
									iRetVal, 
									bNewStudy);
		} 
		else 
		{
			// WorkMate Crashed during the last case, reload it again.
			m_dPatient.GetOpeningPatient(sLast);
							
			if (sLast.inReviewMode)
			{
				m_bActiveMode = false;
				m_eStudyMode = eOpenPreviousStudy;
			}
			else
			{
				m_bActiveMode = true;
				
			}

			bool bSet = false;

			if(bAlluraReady)
			{
				bSet = CAlluraAdapter::IsCurrentStudy(sPDM, m_sAllura);
			}

			m_TSM.SetAutoUpdate(bSet);

			if( CWMLibrary::IsSafeWindow(m_vDB) )
			{
				m_vDB->SetReadOnly(bSet);
			}		
		}
	}
	else
	{
		if(CWMLibrary::IsSafeWindow(m_vDB))
		{
			m_vDB->SetReadOnly(false);
		}

		if(!sLast.mast_recN)
		{
			m_bNewStudy=bNewStudy = OpenScreen(sPatient, sProcedure, sAllura, iRetVal);  

			if(m_INIfile.m_bTSMInstalled && m_TSM.m_bAMLinkActive)
			{
				ProcessOpenScreen(sPDM, 
										sPatient, 
										sProcedure, 
										sProcedure2, 
										sAllura, 
										sPrePost, 
										iRetVal, bNewStudy);

				bAlluraReady = true;
			}
		} 
		else 
		{
			// WorkMate Crashed during the last case, reload it again.
			m_dPatient.GetOpeningPatient(sLast);
							
			if (sLast.inReviewMode)
			{
				m_bActiveMode = false;
				m_eStudyMode = eOpenPreviousStudy;
			}
			else
			{
				m_bActiveMode = true;					
			}			
		}
	}
#endif
	return bAlluraReady;
}

void CWMApp::AddPhysician(LPCTSTR szPhysician, const int iSize)
{
	m_dbPhysician.InitRecord();

	WMStringList slPhysician;	
	
	m_dbPhysician.FillList(slPhysician);

	if(!CWMLibrary::IsInList(slPhysician, szPhysician))
	{
		::strncpy((PCHAR)m_Doctor.name, CT2A(szPhysician), ARRAY_SIZE(m_Doctor.name));

		m_dbPhysician.PutRecord();

		m_dbPhysician.FreeRecord();
	}

	slPhysician.clear();
}
#endif

bool CWMApp::OpenScreen(void)
{
	bool retry = false;

	bool bNewSession = false;

	do {
	
#ifndef PHILIPS_VIEWER	
  	COpenScreen opScreen( AfxGetMainWnd(), m_dPatient.m_Patient, m_dProcedure.m_Procedure, m_sAllura);

	if(opScreen.DoModal() == IDOK)	
   {	
		// Reset communications with amplifier
#ifndef PHILIPS_VIEWER
		IAmplifierSession* m_pAmpSession = IAmplifierSession::Instance();
		if (m_pAmpSession)
		{
			m_pAmpSession->ResetSession();
		}
		IAmplifierMonitor* m_pAmp = IAmplifierMonitor::Instance();
		if (m_pAmp)
		{
			m_pAmp->ResetFirstPacketTimeReceived();  // 100 nanosec units (NT)/ 1 msec units (95)
			m_pAmp->ResetLastPacketTimeReceived();   // 100 nanosec units (NT)/ 1 msec units (95)
			m_pAmp->ResetTotalPackets();
			m_pAmp->ResetDroppedPacketCount();
			m_pAmp->ResetCommPauseCount();
			m_pAmp->ResetDataRateMonitor();
			m_pAmp->AmplifierErrorClear();
		}
#endif

		if ( EnforceOpenStudyRestrictions( opScreen.GetStudyOpenMode() ) )
		{
			retry = true;
		}
		else
		{
			SetDemoMode( opScreen.IsDemo() );

			if(!opScreen.m_csPatient.IsEmpty() ) 
			{
				::strncpy((PCHAR)m_dPatient.m_Access.m_pIndex->key1, 
								CT2A(opScreen.m_csPatient), 
								m_dPatient.m_Access.m_pIndex->key1_length);
				
				::strncpy((PCHAR)m_dPatient.m_Access.m_pIndex->key2,
								CT2A(opScreen.m_csId), 
								m_dPatient.m_Access.m_pIndex->key2_length);
				
				if(m_dPatient.GetMasterRecord(GET_FROM_INDEX, LOCK_EDIT, 9999)) 
				{
					// This is the case where a new study is being started but the patient name was not picked from the list
					// Force the name to have commas in it for storage Claris 1.1.1
					CString full, last, first, mid;
					theApp.m_dPatient.ParsePatientName(m_dPatient.m_Access.m_pIndex->key1, first, mid, last);
					theApp.m_dPatient.BuildPatientName(full, first, mid, last);
					::strncpy((PCHAR)m_dPatient.m_Access.m_pIndex->key1, CT2A(full), ARRAY_SIZE(m_dPatient.m_Access.m_pIndex->key1));

					// if the name won't retrieve, store it
					::strncpy((PCHAR)m_dPatient.m_Patient.name,
									(PCHAR)m_dPatient.m_Access.m_pIndex->key1, 
									ARRAY_SIZE(m_dPatient.m_Patient.name));
					
					::strncpy((PCHAR)m_dPatient.m_Patient.id,
									(PCHAR)m_dPatient.m_Access.m_pIndex->key2, 
									ARRAY_SIZE(m_dPatient.m_Patient.id));

					m_dPatient.m_Access.PutRecord();
				}
			}

			switch( opScreen.GetStudyOpenMode() )	// new study
			{			
				case eOpenNewStudy:
				{
					if(opScreen.IsPatientExist())	
					{
						AfxTrace(_T("NEW-> Exists"));

						m_dProcedure.m_Access.FreeRecord();
						m_dProcedure.m_Access.InitRecord();

						// get the HL7 import information (zero filled if we did not perform a HL7 import)
						CHL7::SImportPatient& rRecord = CHL7::GetPrototypeInstance();

						// are we creating a new study for the patient that was imported via HL7?
						if (!::_tcsncmp(rRecord.name, CA2T((PCHAR)m_dPatient.m_Patient.name), KEY1_LENGTH) && !::_tcsncmp(rRecord.id, CA2T((PCHAR)m_dPatient.m_Patient.id), KEY2_LENGTH))
						{
							// prepopulate study fields with information that was retrieved via HL7

							// incoming height is in inches, database expects centimeters.
							const int height = int(::_tstoi(rRecord.height) * float(2.54) + float(0.5));
							// incoming weight is in lbs, database also expects lbs.
							const int weight = ::_tstoi(rRecord.weight);

							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.case_number, CT2A(rRecord.caseNumber), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.case_number));
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure2.billing, CT2A(rRecord.billingNumber), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure2.billing));
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.referring, CT2A(rRecord.refdr), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.referring));
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.primary, CT2A(rRecord.primaryPhysician), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.primary));
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.physician2[0], CT2A(rRecord.attendingPhysician), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.physician2[0]));
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.date, CT2A(rRecord.visitDate), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.date));

							// Note: truncated to maximum short rather than unsigned
							// short because this code likes to cast values to a short.
							theApp.m_dProcedure.m_Procedure.height = min(max(0, height), SHRT_MAX);
							theApp.m_dProcedure.m_Procedure.weight = min(max(0, weight), SHRT_MAX);

							// order number and visit number are not represented in the database, we place  them
							// in the USER database tab (as the fourth user text entry).

							TCHAR pszBuffer[500] = {0};
							std::memset(pszBuffer, 0, sizeof(pszBuffer));
							_sntprintf(
								pszBuffer,
								(sizeof(pszBuffer) / sizeof(TCHAR)) - 1,
								GETMESSAGE(2229),
								rRecord.orderID,
								rRecord.visitNumber
							);
							::strncpy((PCHAR)theApp.m_dProcedure.m_Procedure.other4[3], CT2A(pszBuffer), ARRAY_SIZE(theApp.m_dProcedure.m_Procedure.other4[3]));
							::WMStrnCpy(
								theApp.m_dProcedure.m_pszAccessionNumber,
								rRecord.accessionNumber,
								sizeof(theApp.m_dProcedure.m_pszAccessionNumber)
							);
						}

						// ask study type and load it
						SelectCathMap(opScreen.m_csCathmap);

						m_dProcedure.StoreProcedure();
						m_dProcedure.SaveDICOMAccessionNumber();
						
					}	
					else	
					{
						AfxTrace(_T("NEW-> NEW"));

			#ifdef ALLURA_TSM
						m_bPrimaryEdited		=	false;
						m_bReferringEdited	=	false;
			#endif
						NewSession();

						// ask study type and load it
						SelectCathMap(opScreen.m_csCathmap);

						m_dProcedure.StoreProcedure();
					}

					SetModeActive();
					SetStateControls();

					bNewSession = true;
					retry = false;
				}
				break;
			
				case eOpenPreviousStudy	:	
				{	// edit old study
					// pull in the study type
					retry = !m_dProcedure.SelectProcedure(true);
					if (!retry)
					{
						m_dProcedure.StoreProcedure();
						SetModePassive();
						SetStateControls();
						// ask study type and load it
						SelectCathMap(opScreen.m_csCathmap);
					}
				}
				break;

				case eOpenContinuedStudy	:
				{	// continue a study
					// pull in the study type
					retry = !m_dProcedure.SelectProcedure(true);
					if (!retry)
					{
						m_dProcedure.StoreProcedure();
						SetModeActive();
						SetStateControls();
						// ask study type and load it
						SelectCathMap(opScreen.m_csCathmap);
					}
				}
				break;
			}
		}

	 } 
	else 
		{
		  m_dPatient.m_Access.FreeRecord();
		  m_dPatient.m_Access.InitRecord();
		}
   } while(retry);

	if(CWMLibrary::IsSafeWindow(m_vMeasurement))
	{
		m_vMeasurement->Refresh();
	}

	m_fChart->TurnOffAutoChartMeasurements();
#endif
	return bNewSession;
}

short CWMApp::ReviewScreenStart(void)
{
	CheckDate();

#ifdef PHILIPS_VIEWER
	if(!ParseLogDirFromCommandLine())
		{
		return false;
		}
#endif

	//check for duplicate case#
	AssignNonDuplicateStudyDir();
	StartLog();

	SPrevRunRecord sLast={0};
    m_INIfile.GetPrevRun(&sLast);

   StartMasterTimers();

	bool bNewStudy		= m_bNewStudy = false;

	if (sLast.mast_recN)
	{
		if (sLast.log_dir_number > 0)
		{
			ReadUpdateCrashLog(sLast.log_dir_number);
						
		}

		CMessageBox message(AfxGetMainWnd(), GETMESSAGE(2298), YES_NO);
		message.CaseRecovery = true;
		CString csEventLog;

		if (message.DoModal() != IDYES)
		{
			sLast.mast_recN = 0;
			sLast.inReviewMode = false;
			sLast.log_dir_number = 0;

			m_INIfile.PutPrevRunAll(
				sLast.mast_recN, 
				sLast.cathmap_recN, 
				sLast.proc_recN, 
				sLast.inReviewMode,
				0);

			csEventLog.Format(_T("%s %d: Case Recovered - User selected: New Case"), WMFILELINE); 
			CMessage::m_erLog.ReportError(csEventLog); 
		}
		else
		{			
			m_INIfile.PutPrevRunAll(
				sLast.mast_recN, 
				sLast.cathmap_recN, 
				sLast.proc_recN, 
				sLast.inReviewMode, 
				sLast.log_dir_number);


			csEventLog.Format(_T("%s %d: Case Recovered - User selected: Recover Case#%x"), WMFILELINE,sLast.log_dir_number); 
			CMessage::m_erLog.ReportError(csEventLog);
		}		
	}

	
#ifndef PHILIPS_VIEWER
	bool bAlluraReady = false;

#if defined(DEMO_CD_ROM)
	#ifdef ALLURA_TSM
		{
			m_INIfile.m_bTSMInstalled = TRUE;

			CString csIPAddress( m_INIfile.m_szAlluraIPAddress );

			do
			{
				CEditDialog edtDialog(csIPAddress, m_fMain, GETMESSAGE(1451), false, false);

				if(edtDialog.DoModal()==IDOK)
				{
					if(::inet_addr(csIPAddress)!=INADDR_NONE)
					{
						::WMStrnCpy( m_INIfile.m_szAlluraIPAddress, csIPAddress, sizeof(m_INIfile.m_szAlluraIPAddress));
						break;
					}
				}
			} while(true);
		}

		bAlluraReady = AlluraIntialize(sLast, bNewStudy);
			
	#else
	m_bNewStudy=bNewStudy = OpenScreen();
	#endif
#else
	
	#ifdef ALLURA_TSM
		bAlluraReady = AlluraIntialize(sLast, bNewStudy);
	#else
		if(!sLast.mast_recN) 
		{
			m_bNewStudy=bNewStudy = OpenScreen();  
		} 
		else 
		{
			
			m_dPatient.GetOpeningPatient(sLast);
				
			if (sLast.inReviewMode)
			{
				m_eStudyMode = eOpenPreviousStudy;
				m_bActiveMode = false;					
			}
			else
			{
				m_eStudyMode = eOpenContinuedStudy;
				m_bActiveMode = true;					
			}			
		}
	#endif
#endif

	//CMessage::m_erLog.ReportError("Before ReviewScreenStart()::m_vDB->DataToGUIExchange()");

   m_vDB->DataToGUIExchange();
   
   //CMessage::m_erLog.ReportError("After ReviewScreenStart()::m_vDB->DataToGUIExchange()");

#ifndef PHILIPS_VIEWER
   if(m_vCathMap)
	{
		//CMessage::m_erLog.ReportError("Before ReviewScreenStart()::m_vCathMap->RefreshScreen()");
		m_vCathMap->RefreshScreen();
	}
#endif

	if(m_fMain)
	{
		//CMessage::m_erLog.ReportError("Before ReviewScreenStart()::m_fMain->DrawScreenHeader()");
		m_fMain->DrawScreenHeader();
	}

#ifndef PHILIPS_VIEWER
#ifdef ALLURA_TSM
	#ifndef DEMO_CD_ROM
		if(bAlluraReady && bNewStudy)
		{
			m_TSM.AddStudy();
		}
	#endif
#endif
#endif

#else
	
	TCHAR szLogDirName[MAX_PATH]={0};
	m_dLog.MakeLogName(szLogDirName, sizeof(szLogDirName));
	
	m_dPatient.ImportPatientFromLog(szLogDirName);

	m_dLog.m_lCurrentLogDirNumber = m_dProcedure.m_Procedure.log_dir_number;
	m_dLog.m_CurDHR = m_dProcedure.m_Procedure.dwDHR;

	if(m_dLog.OpenLogFiles())
	{
		m_dChart.OpenChartFiles();

		m_dCathMap.GetProcCathMap();
	}
	else
	{
		ResetPatientStudy();
	}

   ResetReview();

	GetSession();
	m_MainBar.SetDrugIcon();

   m_vDB->DataToGUIExchange();

#ifndef PHILIPS_VIEWER
   if(m_vCathMap)
	{
		m_vCathMap->RefreshScreen();
	}
#endif

	if(m_fMain)
	{
		m_fMain->DrawScreenHeader();
	}

#endif

	//CMessage::m_erLog.ReportError("Before ReviewScreenStart()::Initialize(bNewStudy)");
	return Initialize(bNewStudy);
}

CSignalView* CWMApp::GetSignalView(const CReviewPortParams& rReview)
{
	switch(rReview.eType)	
	{
		case	eReview		:	return m_vReview;
		case	ePrevReview	:	return m_vPrevReview;
		case	eFreqReview	:	return m_vFreqReview;
	}
	WMASSERT(0);	
	return NULL;
}

void CWMApp::InitAutoRecord(void)
{
	m_dCathMap.ValidateAutoRecordParams();

   	if (m_bDisableAutoRec)
	{
		m_iAutoRecordSave = AUTO_REC_OFF;
	}
	else
	{
		// this will turn off anything currently recording that shouldn't be
		m_iAutoRecordSave&= m_dCathMap.m_CathMap.iAutoRecordMode;
	}

	for(register short iIndex=0; iIndex<MAX_SCREEN_CHANNELS; ++iIndex) 
	{
		InitOneAutoRecord(m_dMonitor.realtime_analysis[iIndex]);
	}

	InitOneAutoRecord(m_dMonitor.surface_analysis);

	InitOneAutoRecord(m_dMonitor.stim_analysis);

	InitOneAutoRecord(m_dMonitor.VRate_analysis);

	InitOneAutoRecord(m_dMonitor.ARate_analysis);
}

void CWMApp::InitOneAutoRecord(SChannelAnalysis& rAnalysis)
{
	rAnalysis.lower				=	0;
	rAnalysis.upper				=	0x7fff;
	rAnalysis.auto_refract		=	0;
	rAnalysis.event_count1		=	rAnalysis.event_count2=-5;
	rAnalysis.last_event1		=	rAnalysis.last_event2=MAX_INTERVAL;
	rAnalysis.auto_rec			=	0;
   rAnalysis.CheckAutoRecord	=	NULL;
   rAnalysis.last_spike		=	0;

	if(!m_bDisableAutoRec && m_dCathMap.m_CathMap.iAutoRecordMode&AUTO_REC_HIGH) 
	{
		if(rAnalysis.type==TRIG_SURFACE) 
		{
			rAnalysis.lower= m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE].iRate;//m_INIfile.m_iAutoRecordHighRate;
			rAnalysis.auto_rec|=AUTO_REC_HIGH;
			rAnalysis.CheckAutoRecord=CheckAutoRecordRate;
		}
	}

	if(!m_bDisableAutoRec && m_dCathMap.m_CathMap.iAutoRecordMode&AUTO_REC_LOW) 
	{
		if(rAnalysis.type==TRIG_SURFACE) 
		{
			rAnalysis.upper=m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_LOW_RATE].iRate;
			rAnalysis.auto_rec|=AUTO_REC_LOW;
			rAnalysis.CheckAutoRecord=CheckAutoRecordRate;
		}
	}

	if(!m_bDisableAutoRec && m_dCathMap.m_CathMap.iAutoRecordMode&AUTO_REC_STIM) 
	{
		if(rAnalysis.type==TRIG_STIM) 
		{
			rAnalysis.auto_rec|=AUTO_REC_STIM;
		}
	}

	if(!m_bDisableAutoRec && m_dCathMap.m_CathMap.iAutoRecordMode&AUTO_REC_AHIGH) 
	{
		if(rAnalysis.type==TRIG_ATRIAL) 
		{
			rAnalysis.lower= m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE_ATRIAL].iRate;
			rAnalysis.auto_rec|=AUTO_REC_AHIGH;
			rAnalysis.CheckAutoRecord=CheckAutoRecordARate;
		}
	}

	if(!m_bDisableAutoRec && m_dCathMap.m_CathMap.iAutoRecordMode&AUTO_REC_VHIGH) 
	{
		if(rAnalysis.type==TRIG_VENT) 
		{
			rAnalysis.lower= m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE_VENTRICULAR].iRate;
			rAnalysis.auto_rec|=AUTO_REC_VHIGH;
			rAnalysis.CheckAutoRecord=CheckAutoRecordVRate;
		}
	}
}

namespace
{
long computeAutoRecordLastEvent(const SAutoRecordParams& params)
{
	long lastEvent = 0L; // means auto-record will never turn off

	if (params.iStop)
	{
		const long sampleWindow = (SAMPLE_RATE * long(params.iRate) * long(params.iCount)) / 1000;
		const long sampleStop = max(10L, SAMPLE_RATE * long(params.iStop));
		lastEvent = sampleWindow + sampleStop;
	}

	return lastEvent;
}
}

void CWMApp::CheckAutoRecordRate(SChannelAnalysis& rAnalysis, USHORT usInterval)
{
	static ULONG ulUpdateLowTimeOn	=	0L;
	static ULONG ulUpdateHighTimeOn	=	0L;
	static ULONG ulUpdateLowTimeOff	=	0L;
	static ULONG ulUpdateHighTimeOff	=	0L;
	
	if(--rAnalysis.last_event1==0L) 
	{
		if((theApp.m_iAutoRecordSave&AUTO_REC_LOW) && theApp.m_dLog.m_iSaveData) 
		{
			if(theApp.m_uiMSecTimer>ulUpdateLowTimeOff)
			{
				theApp.m_dLog.UpdateLogPush(UPDATE_LOG_LOW_END,
					theApp.m_dLog.GetCurrentSaveFilePosition(),
					theApp.m_uiMSecTimer);
				
				theApp.m_ulAutoRecordTimeLRate=theApp.m_uiMSecTimer;
				ulUpdateLowTimeOff=theApp.m_uiMSecTimer+1000; // 1 second per message is enough
			}
		}
	}

	if(--rAnalysis.last_event2==0L) 
	{
		if((theApp.m_iAutoRecordSave&AUTO_REC_HIGH) && theApp.m_dLog.m_iSaveData) 
		{
         if(!(theApp.m_iAutoRecordSave&AUTO_REC_STIM) && !theApp.m_bStimulating) 
			{ // no reason to update the log if the stim is doing it
				if(theApp.m_uiMSecTimer>ulUpdateHighTimeOff)
				{
					theApp.m_dLog.UpdateLogPush(UPDATE_LOG_HIGH_END,
						theApp.m_dLog.GetCurrentSaveFilePosition(),
						theApp.m_uiMSecTimer);
					
					ulUpdateHighTimeOff=theApp.m_uiMSecTimer+1000; // 1 second per message is enough
				}
         }
			theApp.m_ulAutoRecordTimeHRate=theApp.m_uiMSecTimer;
		}
	}

   if(!usInterval) 
	{
      // this will set off the low rate detector on asystole
	   if(++rAnalysis.auto_refract>=MAX_INTERVAL) 
		{
         usInterval=MAX_INTERVAL;
	   }
   }

   if(usInterval) 
	{
      // low rate detector
      if(usInterval>=rAnalysis.upper) 
		{
		   if(++rAnalysis.event_count1>=theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_LOW_RATE].iCount) 
			{
			   rAnalysis.event_count1=0;

				if(theApp.m_uiMSecTimer>ulUpdateLowTimeOn)
				{
					if(!theApp.m_dLog.m_iSaveData) 
					{
						theApp.m_dMonitor.m_usSaveAcquirePop
							= CLOGDoc::RewindLogPop(theApp.m_dMonitor.m_usAcquirePop, 
															theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_LOW_RATE].iDelay*SAMPLE_RATE); // so it will have to do all of acquire buffer

						theApp.m_dLog.m_iSaveData=true;

						theApp.m_iAutoRecordSave|=AUTO_REC_LOW;

						theApp.m_dLog.m_arlUpdateLogSample[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_dMonitor.SamplesBehind(); // havent started saving yet
					} 
					else 
					{
						if(theApp.m_iAutoRecordSave || theApp.m_dLog.m_iSaveData==SAVE_DATA_TEMP) theApp.m_iAutoRecordSave|=AUTO_REC_LOW;

						theApp.m_dLog.m_arlUpdateLogSample[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_dLog.GetCurrentSaveFilePosition();
					}

					theApp.m_dLog.m_ariUpdateLogType[theApp.m_dLog.m_iUpdateLogPush]=UPDATE_LOG_LOW;
					theApp.m_dLog.m_arulUpdateLogTime[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_uiMSecTimer;
					theApp.m_dLog.IncrementUpdateLogPush();
				}
				theApp.m_ulAutoRecordTimeLRate=MAXLONG;
				ulUpdateLowTimeOn=theApp.m_uiMSecTimer+6000; // it will go off repeatedly without 6 seconds
		   }

			rAnalysis.last_event1 = computeAutoRecordLastEvent(theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_LOW_RATE]);
			rAnalysis.last_event1=max(rAnalysis.last_event1, 6020); // 6000 is the asystolic limit above
      } 
		else 
		{
         rAnalysis.event_count1=0;
      }

      // high rate detector
      // we don't want it to go off if pacing is active

      if(usInterval<=rAnalysis.lower) 
		{
		   if(++rAnalysis.event_count2>=theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE].iCount)
			{
            // the auto record
				if(theApp.m_uiMSecTimer>ulUpdateHighTimeOn)
				{
					if(!theApp.m_dLog.m_iSaveData) 
					{
						theApp.m_dMonitor.m_usSaveAcquirePop
							=CLOGDoc::RewindLogPop(	theApp.m_dMonitor.m_usAcquirePop, 
															theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE].iDelay*SAMPLE_RATE); // so it will have to do all of acquire buffer

						theApp.m_dLog.m_iSaveData=true;

						theApp.m_iAutoRecordSave|=AUTO_REC_HIGH;

						theApp.m_dLog.m_arlUpdateLogSample[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_dMonitor.SamplesBehind();
					}
					else
					{
						if(theApp.m_iAutoRecordSave || theApp.m_dLog.m_iSaveData==SAVE_DATA_TEMP) theApp.m_iAutoRecordSave|=AUTO_REC_HIGH;

						theApp.m_dLog.m_arlUpdateLogSample[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_dLog.GetCurrentSaveFilePosition();
					}

					if(!(theApp.m_iAutoRecordSave&AUTO_REC_STIM) && !theApp.m_bStimulating) 
					{
						theApp.m_dLog.m_ariUpdateLogType[theApp.m_dLog.m_iUpdateLogPush]=UPDATE_LOG_HIGH;
						theApp.m_dLog.m_arulUpdateLogTime[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_uiMSecTimer;
						theApp.m_dLog.IncrementUpdateLogPush();
					}
				}
            // if not saving, react right away
            if(!theApp.m_dLog.m_iSaveData) 
               ulUpdateHighTimeOn=0; 
            else 
               ulUpdateHighTimeOn=theApp.m_uiMSecTimer+theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE].iCount*rAnalysis.lower;

				theApp.m_ulAutoRecordTimeHRate=MAXLONG;
				
			   rAnalysis.event_count2=0;
		   }

			rAnalysis.last_event2 = computeAutoRecordLastEvent(theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE]);
		} 
		else 
		{
         rAnalysis.event_count2=0;
      }
		rAnalysis.auto_refract=0;
   }
}

void CWMApp::CheckAutoRecordARate(SChannelAnalysis& rAnalysis, USHORT usInterval)
{
	static ULONG	ulUpdateHighTimeOn	=	0L;
	static ULONG	ulUpdateHighTimeOff	=	0L;
	
	if(--rAnalysis.last_event2==0L) 
	{
		if((theApp.m_iAutoRecordSave&AUTO_REC_AHIGH) && theApp.m_dLog.m_iSaveData) 
		{
         if(!(theApp.m_iAutoRecordSave&AUTO_REC_STIM) && !theApp.m_bStimulating) 
			{ // no reason to update the log if the stim is doing it
				if(theApp.m_uiMSecTimer>ulUpdateHighTimeOff)
				{
					theApp.m_dLog.UpdateLogPush(UPDATE_LOG_HIGH_END,
						theApp.m_dLog.GetCurrentSaveFilePosition(),
						theApp.m_uiMSecTimer);
					
					ulUpdateHighTimeOff=theApp.m_uiMSecTimer+1000; // 1 second per message is enough
				}
         }
			theApp.m_ulAutoRecordTimeHARate=theApp.m_uiMSecTimer;
		}
	}

   if (usInterval) 
	{
      // ARate rate detector
      // we don't want it to go off if pacing is active
      if(usInterval<=rAnalysis.lower) 
		{
		   if(++rAnalysis.event_count2>=theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE_ATRIAL].iCount)
			{
            // the auto record
				if(theApp.m_uiMSecTimer>ulUpdateHighTimeOn)
				{
					if (!theApp.m_dLog.m_iSaveData) 
					{
						theApp.m_dMonitor.m_usSaveAcquirePop
							=CLOGDoc::RewindLogPop(	theApp.m_dMonitor.m_usAcquirePop, 
															theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE_ATRIAL].iDelay*SAMPLE_RATE); // so it will have to do all of acquire buffer

						theApp.m_dLog.m_iSaveData=true;

						theApp.m_iAutoRecordSave|=AUTO_REC_AHIGH;

						theApp.m_dLog.m_arlUpdateLogSample[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_dMonitor.SamplesBehind();
					}
					else
					{
						if(theApp.m_iAutoRecordSave || theApp.m_dLog.m_iSaveData==SAVE_DATA_TEMP) theApp.m_iAutoRecordSave|=AUTO_REC_AHIGH;

						theApp.m_dLog.m_arlUpdateLogSample[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_dLog.GetCurrentSaveFilePosition();
					}

					if(!(theApp.m_iAutoRecordSave&AUTO_REC_STIM) && !theApp.m_bStimulating) 
					{
						theApp.m_dLog.m_ariUpdateLogType[theApp.m_dLog.m_iUpdateLogPush]=UPDATE_LOG_AHIGH;
						theApp.m_dLog.m_arulUpdateLogTime[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_uiMSecTimer;
						theApp.m_dLog.IncrementUpdateLogPush();
					}
				}
            // if not saving, react right away
            if (!theApp.m_dLog.m_iSaveData) 
               ulUpdateHighTimeOn=0; 
            else 
               ulUpdateHighTimeOn=theApp.m_uiMSecTimer+theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE_ATRIAL].iCount*rAnalysis.lower;

				theApp.m_ulAutoRecordTimeHARate=MAXLONG;
				
			   rAnalysis.event_count2=0;
		   }

			rAnalysis.last_event2 = computeAutoRecordLastEvent(theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE_ATRIAL]);
		} 
		else 
		{
         rAnalysis.event_count2=0;
      }
		rAnalysis.auto_refract=0;
   }
}

void CWMApp::CheckAutoRecordVRate(SChannelAnalysis& rAnalysis, USHORT usInterval)
{
	static ULONG	ulUpdateHighTimeOn	=	0L;
	static ULONG	ulUpdateHighTimeOff	=	0L;
	
	if(--rAnalysis.last_event2==0L) 
	{
		if((theApp.m_iAutoRecordSave&AUTO_REC_VHIGH) && theApp.m_dLog.m_iSaveData) 
		{
         if(!(theApp.m_iAutoRecordSave&AUTO_REC_STIM) && !theApp.m_bStimulating) 
			{ // no reason to update the log if the stim is doing it
				if(theApp.m_uiMSecTimer>ulUpdateHighTimeOff)
				{
					theApp.m_dLog.UpdateLogPush(UPDATE_LOG_HIGH_END,
						theApp.m_dLog.GetCurrentSaveFilePosition(),
						theApp.m_uiMSecTimer);
					
					ulUpdateHighTimeOff=theApp.m_uiMSecTimer+1000; // 1 second per message is enough
				}
         }
			theApp.m_ulAutoRecordTimeHVRate=theApp.m_uiMSecTimer;
		}
	}

   if (usInterval) 
	{
      // VRate rate detector
      // we don't want it to go off if pacing is active
      if (usInterval<=rAnalysis.lower) 
		{
		   if (++rAnalysis.event_count2>=theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE_VENTRICULAR].iCount) 
			{
            // the auto record
				if (theApp.m_uiMSecTimer>ulUpdateHighTimeOn)
				{
					if (!theApp.m_dLog.m_iSaveData) 
					{
						theApp.m_dMonitor.m_usSaveAcquirePop
							=CLOGDoc::RewindLogPop( theApp.m_dMonitor.m_usAcquirePop, 
															theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE_VENTRICULAR].iDelay*SAMPLE_RATE); // so it will have to do all of acquire buffer

						theApp.m_dLog.m_iSaveData=true;

						theApp.m_iAutoRecordSave|=AUTO_REC_VHIGH;

						theApp.m_dLog.m_arlUpdateLogSample[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_dMonitor.SamplesBehind();
					}
					else
					{
						if(theApp.m_iAutoRecordSave || theApp.m_dLog.m_iSaveData==SAVE_DATA_TEMP) theApp.m_iAutoRecordSave|=AUTO_REC_VHIGH;

						theApp.m_dLog.m_arlUpdateLogSample[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_dLog.GetCurrentSaveFilePosition();
					}

					if(!(theApp.m_iAutoRecordSave&AUTO_REC_STIM) && !theApp.m_bStimulating)
					{
						theApp.m_dLog.m_ariUpdateLogType[theApp.m_dLog.m_iUpdateLogPush]=UPDATE_LOG_VHIGH;
						theApp.m_dLog.m_arulUpdateLogTime[theApp.m_dLog.m_iUpdateLogPush]=theApp.m_uiMSecTimer;
						theApp.m_dLog.IncrementUpdateLogPush();
					}
				}
            // if not saving, react right away
            if (!theApp.m_dLog.m_iSaveData) 
               ulUpdateHighTimeOn=0; 
            else 
               ulUpdateHighTimeOn=theApp.m_uiMSecTimer+theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE_VENTRICULAR].iCount*rAnalysis.lower;

				theApp.m_ulAutoRecordTimeHVRate=MAXLONG;
				
			   rAnalysis.event_count2=0;
		   }

			rAnalysis.last_event2 = computeAutoRecordLastEvent(theApp.m_dCathMap.m_CathMap.arAutoRecordParams[AUTO_RECORD_PARAM_HIGH_RATE_VENTRICULAR]);
		} 
		else 
		{
         rAnalysis.event_count2=0;
      }
		rAnalysis.auto_refract=0;
   }
}

void CWMApp::ConvertNumLockKeys(int& iVirtKey, long& lKeyData)
{
	switch(iVirtKey)	
	{
		case	VK_HOME	:	if(lKeyData==4653057L)	{	iVirtKey=103;	}	break;

		case	VK_UP		:	if(lKeyData==4718593L)	{	iVirtKey=104;	}	break;

		case	VK_PRIOR	:	if(lKeyData==4784129L)	{	iVirtKey=105;	}	break;

		case	VK_LEFT	:	if(lKeyData==4915201L)	{	iVirtKey=100;	}	break;

		//	12 This is for Key 5 without Numlock
		case	0xC		:	if(lKeyData==4980737L)	{	iVirtKey=101;	}	break;

		case	VK_RIGHT	:	if(lKeyData==5046273L)	{	iVirtKey=102;	}	break;

		case	VK_END	:	if(lKeyData==5177345L)	{	iVirtKey=97;	}	break;

		case	VK_DOWN	:	if(lKeyData==5242881L)	{	iVirtKey=98;	}	break;

		case	VK_NEXT	:	if(lKeyData==5308417L)	{	iVirtKey=99;	}	break;

		case	VK_INSERT:	if(lKeyData==5373953L)	{	iVirtKey=96;	}	break;

		case	VK_DELETE:	if(lKeyData==5439489L)	{	iVirtKey=110;	}	break;
	}
}

void CWMApp::ShutDown(bool bKillShell, bool bShutdownMapMate)
{
	if(m_hhkLowLevelKybd)
	{
		::UnhookWindowsHookEx(m_hhkLowLevelKybd);
		m_hhkLowLevelKybd=NULL;
	}

	m_fMain->m_bCreateRemoteMouse = false;

	if(g_bMoved)
	{
		m_vChartEvent->SaveAndExit();
	}
	
	#if defined(DEMO_CD_ROM)

	#else								// Server
#ifndef PHILIPS_VIEWER
		if(m_INIfile.m_bNurseMateInstalled)
		{
			m_sNM.ShutDown();
		}
#endif
	#endif

#ifndef PHILIPS_VIEWER

	m_dMapping->Terminate();

#endif

	m_dCine.Terminate();

#ifndef PHILIPS_VIEWER
	IAmplifierSession::Instance()->ShutDown();
#endif

	if( CWMLibrary::IsSafeWindow(m_MainBar.m_pStopWatchDialog) )	
	{
		m_MainBar.m_pStopWatchDialog->DestroyWindow();	
		m_MainBar.m_pStopWatchDialog=NULL;
	}

#ifndef PHILIPS_VIEWER
	if(CWMLibrary::IsSafeWindow(m_pTrace))
	{
		m_pTrace->DestroyWindow();

		m_pTrace = NULL;
	}

	m_Stim.Terminate(true);
#endif

	if( CWMLibrary::IsSafeWindow(m_fRealTime) )
	{
		m_fRealTime->ShutDownThread();
	}

	m_DirectDraw.Destroy();

	ExitDataBase();

	m_cpClipPen.DeleteObject();
	m_cpReviewClipPen.DeleteObject();

	m_cfAppFont.DeleteObject();

#ifndef PHILIPS_VIEWER
	if( bKillShell && CWMLibrary::IsSafeWindow(m_pShell) ) 
	{ 
		m_pShell->DestroyWindow(); 
		delete m_pShell; 
		m_pShell=NULL; 
	}
#endif

	for(register short iIndex=0; iIndex<2; ++iIndex)
	{
		m_TriggerCtl[iIndex].m_dcInterval.Delete();
		m_TriggerModeCtl[iIndex].m_dcInterval.Delete();
	}

	DestroyReviewWindows();
}

bool CWMApp::EjectMODisk(void)
{
	bool bSuccess = false;

	for(register short iIndex=0; iIndex<MAX_ARCHIVE_PATH; ++iIndex)
	{
		TCHAR szDisk[4]={0};

		szDisk[0] = m_INIfile.m_szArchivePath[iIndex][0];
		szDisk[1] = _T(':');
		szDisk[2] = _T('\\');
		szDisk[3] = 0;

		switch(GetDriveType(szDisk))
		{
			case	DRIVE_REMOVABLE			:
			case	DRIVE_CDROM					:
			{
				if(CWMLibrary::IsDiskInDrive(szDisk))
				{
					bSuccess = (CEjectMODisk::EjectVolume(m_INIfile.m_szArchivePath[iIndex][0])==TRUE);
				}
			}
			break;

			case	DRIVE_FIXED				:
			case	DRIVE_REMOTE			:
			case	DRIVE_RAMDISK			:  
			case	DRIVE_UNKNOWN			:
			case	DRIVE_NO_ROOT_DIR		:
			default							:
			{
			}
			break;
		 }
	}

	return bSuccess;	
}

bool CWMApp::ShellProcessHotKey(const int iVirtKey, const long lKeyData)
{
	const SHORT iAltState		=	::GetKeyState(VK_MENU);
	const bool	bLeftAlt			=	( iAltState<0 && iVirtKey!=VK_MENU && lKeyData!=538968065L );
	const bool	bRightAlt		=	( iVirtKey==VK_MENU && lKeyData==557318145L );
	const SHORT iShiftState		=	::GetKeyState(VK_SHIFT);
	const SHORT iControlState	=	::GetKeyState(VK_CONTROL);

	AfxTrace(_T("key %d\n"), iVirtKey);

	if(iControlState<0 && iVirtKey!=VK_CONTROL)	//	CONTROL based.
	{
		AfxTrace(_T("CONTROL + Key %d\n"), iVirtKey);

		switch(iVirtKey)
		{
			case	_T('r')	:
			case	_T('R')	:
			{
				return Restore();					
			}

			case	_T('e')	:
			case	_T('E')	:
			{
				return EjectMODisk();
			}
		}
	}

	return false;
}

bool CWMApp::Restore(void)
{
	// 1. Figure out what PC is this ?

	CString csDummy;
	const bool bP4 = CWMLibrary::IsP4(csDummy);

	TCHAR szFullPath[MAX_PATH]={0};

	if(bP4)
	{
		// 2. Check fo the availability pf the "P4_RESTORE.BAT" 
		MakePath(_T("P4_RESTORE.BAT"), szFullPath, sizeof(szFullPath));
	}
	else
	{
		// 2. Check fo the availability pf the "P3_RESTORE.BAT" 
		MakePath(_T("P3_RESTORE.BAT"), szFullPath, sizeof(szFullPath));
	}

	if(CFileDB::IsExists(szFullPath))
	{
		::_tsystem(szFullPath);

		return true;
	}

	return false;
}


bool CWMApp::IsInRPMTextMode(void)
{
	return false;
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::PreTranslateMessage()

	Description		:	This function is filters the window message before they 
							are dispatched to the Windows operating system message 
							translation functions.

	Returns			:	TRUE when handled or FALSE when uninterrupted..

	Setup				:	1.	Open the Review screen with recorded signals.

	Testing			:	1. Press the right 'SHIFT' keystroke. Verify there is no
							beeping or clicking sound from the PC's speaker.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
BOOL CWMApp::PreTranslateMessage(MSG* pMsg) 
{
	m_Trace.Trap(pMsg);

	if(pMsg->message==WM_MOUSEWHEEL)
	{			
		if(::IsWindow(pMsg->hwnd))
		{
#if _MSC_VER >= 1400 
			UINT nFlags = GET_KEYSTATE_WPARAM(pMsg->wParam);
			short zDelta = GET_WHEEL_DELTA_WPARAM(pMsg->wParam);	
#else
			UINT nFlags= LOWORD(pMsg->wParam);					// key flags
			short zDelta = (short) HIWORD(pMsg->wParam);    // wheel rotation
#endif
			
			CPoint ptPoint(GET_X_LPARAM(pMsg->lParam), GET_Y_LPARAM(pMsg->lParam)); 	

			CRect crTemp;

			if ( CWMLibrary::IsSafeWindow(m_vReview) )
			{
				m_vReview->GetWindowRect(&crTemp);
				if( crTemp.PtInRect(ptPoint) && m_vReview->m_bMouseHover )
				{							
					return m_vReview->OnMouseWheel(nFlags, zDelta, ptPoint);
				}
			}

			if ( CWMLibrary::IsSafeWindow(m_vPrevReview) )
			{
				m_vPrevReview->GetWindowRect(&crTemp);
				if( crTemp.PtInRect(ptPoint) && m_vPrevReview->m_bMouseHover ) //if(m_vPrevReview->GetSafeHwnd()==pMsg->hwnd)
				{				
					return m_vPrevReview->OnMouseWheel(nFlags, zDelta, ptPoint);
				}
			}

	
			if( m_fMonitor->GetSafeHwnd() )
			{
				m_fMonitor->m_vMonitor.GetWindowRect(&crTemp);
				if( crTemp.PtInRect(ptPoint) && m_fMonitor->m_vMonitor.m_bMouseHover ) 
				{
					//if(m_fMonitor->m_vMonitor.GetSafeHwnd()==pMsg->hwnd)
					{							
						return m_fMonitor->m_vMonitor.OnMouseWheel(nFlags, zDelta, ptPoint);
					}
				}			
			}
			
			if(m_fRealTime)
			{
				if( m_fRealTime->m_mtMonitor.m_vMonitor.GetSafeHwnd() )
				{
					m_fRealTime->m_mtMonitor.m_vMonitor.GetWindowRect(&crTemp);
					if( crTemp.PtInRect(ptPoint) && m_fRealTime->m_mtMonitor.m_vMonitor.m_bMouseHover ) 
					{
						return m_fRealTime->m_mtMonitor.m_vMonitor.OnMouseWheel(nFlags, zDelta, ptPoint);
					}
				}
			}			
			
			if(theApp.m_INIfile.m_iEP4Installed)
			{
				#ifndef PHILIPS_VIEWER		
					return m_Stim.OnMouseWheel(nFlags, zDelta, ptPoint);
				#endif				
			}			
		}
	}

	if((pMsg->message==WM_KEYDOWN) || 
		(pMsg->message==WM_SYSKEYDOWN) )	
	{
#ifndef PHILIPS_VIEWER
		m_hCurWnd = pMsg->hwnd;
#endif

		int iVirtKey = static_cast<int> (pMsg->wParam);    // Virtual-Key Code 
		long lKeyData	=	pMsg->lParam;							// Key Data 		

		if(m_bShellActive)	
		{
		#ifndef PHILIPS_VIEWER		
            // Any key press resets the detected inactivity period for 
            // managing the screen saver
			if( CWMLibrary::IsSafeWindow(m_pShell) )
			{
				if( CWMLibrary::IsSafeWindow(m_pWMSplashScreen) )
				{
					HideSplashScreen();
                    m_pShell->EndUserInactivitySession();
                    m_pShell->BeginUserInactivitySession();
					return TRUE;
				}
			}
		#endif
			
			// EJB 1/9/2013: replaced via new ShellMenu
			/*
			if(ProcessExit(iVirtKey))	
			{
				if(m_bAutoArchiving)
				{
					CMessage::PopupMessage(WMFILELINE, 1685);
					return TRUE;
				}

				if( CWMLibrary::IsSafeWindow(m_fMain) )	
				{
					CString csServicePassword;
					int iPassword = CWMApp::m_ctTime.GetMonth() + CWMApp::m_ctTime.GetDay();
					csServicePassword.Format("%d", iPassword);
				
					if(m_INIfile.m_iDBAccessMode != DISABLE_PASSWORDS)
					{
						CString csHashPassword;
						CEditDialog edtDialog(	csHashPassword, 
														m_fMain, 
														GETMESSAGE(1506), 
														CWMLibrary::ePasswordEdit, 
														-1);

						if(edtDialog.DoModal()==IDOK)
						{
							SHashPassword sHashPassword= m_INIfile.m_sAdminPassword;
							m_INIfile.m_cCrypt.Decrypt(sHashPassword.arValue, sHashPassword.iLength);

							if((csHashPassword.Compare((PTCHAR)sHashPassword.arValue)==0) || 
								(csHashPassword.Compare(csServicePassword)==0))
							{
								ShutDown(true, true);
								m_fMain->SendMessage(WM_CLOSE);
								return CWinApp::PreTranslateMessage(pMsg);
							}
							else
							{
								CMessage::PopupMessage(WMFILELINE, GETMESSAGE(1505));
								return true;
							}
						}
						else
						{
							return true;
						}
					}
					else
					{
						CString csHashPassword;
						CEditDialog edtDialog(csHashPassword, 
													 m_fMain, 
													 GETMESSAGE(1506), 
													 CWMLibrary::ePasswordEdit, 
													 -1);

						if(edtDialog.DoModal()==IDOK)
						{			
							SHashPassword sHashPassword= m_INIfile.m_sAdminPassword;
							m_INIfile.m_cCrypt.Decrypt(sHashPassword.arValue, sHashPassword.iLength);
						
							if((csHashPassword.Compare((PTCHAR)sHashPassword.arValue)==0)					|| 
								(csHashPassword.Compare((PTCHAR)m_sServiceLogin.sHashPassword.arValue)==0)|| 
								(csHashPassword.Compare(csServicePassword)==0))
							{
								ShutDown(true, true);
								m_fMain->SendMessage(WM_CLOSE);
								return CWinApp::PreTranslateMessage(pMsg);
							}
							else
							{
								CMessage::PopupMessage(WMFILELINE, GETMESSAGE(1505));
								return true;
							}											
						}
						else
						{
							return true;
						}
					}
				}
			}
			*/
			else if(ShellProcessHotKey(iVirtKey, lKeyData))
			{
				return true;
			}
		}	
		else if(m_bArchiveCreated) 
		{
			// Do Nothing.
		}	
		else if(m_bSysMaintCreated)	
		{
			// Do Nothing.
		}	
		else if(m_bQueryCreated)	
		{
			// Do Nothing.
		}	
		else	
		{
			ConvertNumLockKeys(iVirtKey, lKeyData);
			pMsg->wParam = iVirtKey;
			pMsg->lParam = lKeyData;

#ifndef PHILIPS_VIEWER
			if(m_Stim.ProcessHotKey(iVirtKey, lKeyData)) 
			{ 
				return TRUE; 
			}
#endif
			{

#ifndef  PHILIPS_VIEWER
				if (
					(CWMLibrary::IsSafeWindow(this->m_vDB)) &&
					(this->m_bDBScrnActive) &&
					(this->m_vCathMap && !this->m_vCathMap->IsInFocus())
				)
#else
				if (CWMLibrary::IsSafeWindow(this->m_vDB) && this->m_bDBScrnActive)
#endif
				{
					CTabDialog* pTabDialog = this->m_vDB->GetActiveChild();

					if (CWMLibrary::IsSafeWindow(pTabDialog)) {
						const eHotKey eResult = pTabDialog->ProcessKeyStroke(pMsg);
						if (eResult == eProcess) {
							return CWinApp::PreTranslateMessage(pMsg);
						}
						else if (eResult == eNoProcess) {
							return TRUE;
						}
						else {
							// WMASSERT(0);
						}	
					}
				}

#ifndef PHILIPS_VIEWER
				//	CathMap Screen If Visible
				if(CWMLibrary::IsSafeWindow(m_vCathMap) && 
					m_vCathMap->IsWindowVisible() )	
				{		
					eHotKey eResult = m_vCathMap->ProcessHotkey(iVirtKey, lKeyData);
					if( eResult==eNoProcess )	
					{
						return TRUE;
					}
					else if(eResult==eProcess)	
					{	
					}
				}

				//	Config screen If Visible
				if(CWMLibrary::IsSafeWindow(m_vCathMap->m_pConfigScreen) && 
					m_vCathMap->m_pConfigScreen->IsWindowVisible() )
				{						
					const int iTab = m_vCathMap->m_pConfigScreen->m_tabConfigCtl.GetCurSel();
					if(iTab>-1) 		
					{
						CConfigTabDialog* pTabDialog = m_vCathMap->m_pConfigScreen->m_arpConfigTab[iTab];

						if(CWMLibrary::IsSafeWindow(pTabDialog) )
						{
							eHotKey eResult = pTabDialog->ProcessKeyStroke(pMsg);
							if( eResult==eNoProcess )	{	return TRUE;	}
							else if(eResult==eProcess)	{	return CWinApp::PreTranslateMessage(pMsg);	}
						}
					}
				}
#endif
				if(m_vRF->m_pViewDataDialog && m_vRF->m_pViewDataDialog->IsWindowVisible())
				{
					if( m_vRF->m_pViewDataDialog->ProcessKeyStroke(pMsg) )	{	return TRUE;	}
				}
				if(m_vRF->m_pRFSummaryDialog && m_vRF->m_pRFSummaryDialog->IsWindowVisible())
				{
					if( m_vRF->m_pRFSummaryDialog->ProcessKeyStroke(pMsg) )	{	return TRUE;	}
				}
  				if( m_bChartSuppliesDialogCreated && CWMLibrary::IsSafeWindow(m_pChartSuppliesDialog) )
				{
					if( m_pChartSuppliesDialog->ProcessKeyStroke(pMsg) )	
					{
						return CWinApp::PreTranslateMessage(pMsg);
					}
				}

  				if( m_fChart->IsWindowVisible() )	//	CathMap Screen If Visible
				{
					if( m_vChartEvent->ProcessKeyStroke(pMsg) )	
					{
						return CWinApp::PreTranslateMessage(pMsg);
					}
				}

				if( ProcessHotkey(iVirtKey, lKeyData) )	
				{
					return TRUE;
				}
			}
		}
	}
	
	return CWinApp::PreTranslateMessage(pMsg);
}

bool CWMApp::IsEP3HotKey(const int iVirtKey, const long lKeyData) 
{
	const SHORT iShiftState = ::GetKeyState(VK_SHIFT);

	AfxTrace(_T("Shift State %d\n"), iShiftState);

	if(iShiftState<0 && iVirtKey!=VK_SHIFT)	//	SHIFT based.
	{	
		AfxTrace(_T("SHIFT + Key %d\n"), iVirtKey);

		switch( iVirtKey)	
		{
			case	VK_F1		:
			case	VK_F2		:
			case	VK_F3		:
			case	VK_F4		:
			case	VK_F5		:
			case	VK_F6		:
			case	VK_F7		:
			case	VK_F8		:
			case	VK_F9		:
			case	VK_F10	:
			case	VK_F11	:
			case	VK_PRINT	:	return true;
			default			:	return false;
		}

		return false;
	}

	const SHORT iControlState = ::GetKeyState(VK_CONTROL);

	if(iControlState<0 && iVirtKey!=VK_CONTROL)	//	CONTROL based.
	{	
		AfxTrace(_T("CONTROL + Key %d\n"), iVirtKey);

		return false;
	}

	if( iVirtKey==VK_CONTROL || iVirtKey==VK_SHIFT)	
	{
		return false;
	}

	switch(iVirtKey)		//	F KEYS and Normal Keys.
	{
		case	VK_F1			:
		case	VK_F2			:
		case	VK_F3			:
		case	VK_F4			:
		case	VK_F5			:
		case	VK_F6			:
		case	VK_F7			:
		case	VK_F8			:
		case	VK_F9			:
		case	VK_F10		:
		case	VK_F11		:
		case	VK_PRINT		:	
		case	VK_ADD		:	
		case	VK_MULTIPLY	:	
		case	VK_NUMLOCK	:	
		case VK_SCROLL	:
		{
			return true;
		}

		case	VK_RETURN:	
		{
			bool bNumEnter = (lKeyData&0x1000000) ? true : false;	
			if(bNumEnter)
			{
				return true;
			}
		}
		return false;

		default			:	return false;
	}

	return false;
}

CWMApp::SDialogMap CWMApp::m_mpDialogMap[] =
{
	{IDD_ABOUTBOX				,	false},
	{IDD_DIALOG_ANALYSIS		,	false},
	{IDD_DIALOG_ANNOTATION	,	false},
	{IDD_DB_TAB_ARRH			,	false},
	{IDD_DIALOG_ARRHYTHMIA	,	false},
	{IDD_DIALOG_AUTO_RECORD	,	false},
	{IDD_DIALOG_CHANGE		,	false},
	{IDD_DIALOG_CINE_MODES	,	false},
   {IDD_DIALOG_COMTEST		,	false},
	{IDD_DIALOG_DATETIME		,	false},
	{IDD_DIALOG_DEVICE_STATUS,	false},
	{IDD_DIALOG_DRUG			,	false},
	{IDD_EDIT_SCREEN			,	false},
	{IDD_DIALOG_FILE_LIST	,	false},
	{IDD_DIALOG_GRAPH			,	false},
	{IDD_DIALOG_GRAPH_EDIT	,	false},
	{IDD_DIALOG_GRAPH_LIST	,	false},
	{IDD_DIALOG_GRAPH_PICK_LIST,false},
	{IDD_DIALOG_GRID_SETTINGS,	false},
	{IDD_DIALOG_CATHMAP_JUNCTION_BOX_1,false},
	{IDD_DIALOG_CATHMAP_JUNCTION_BOX_2,false},
	{IDD_DIALOG_CATHMAP_JUNCTION_BOX_3,false},
	{IDD_DIALOG_LIST			,	false},
	{IDD_DIALOG_DEMO_LIST_NAMES,false},
	{IDD_DIALOG_MEAS_SAVE		, false},
	{IDD_DIALOG_MENU			,	false},
	{IDD_DIALOG_MESSAGE_BOX	,	false},
	{IDD_DIALOG_CATHMAP_NAME,	false},
	{IDD_DIALOG_NOTEPAD		,	false},
	{IDD_DIALOG_OPENSCREEN	,	false},
	{IDD_DIALOG_PKEY_SAVE	,	false},
	{IDD_DIALOG_CATHMAP_PMI_2,	false},
	{IDD_DIALOG_CATHMAP_PMI_3,	false},
	{IDD_DIALOG_PATIENT		,	false},
	{IDD_DIALOG_PRINT_REPORT,	false},
	{IDD_DIALOG_PROGRESS		,	false},
	{IDD_DIALOG_TIME			,	false},
	{IDD_DIALOG_TRIGGER		,	false},
	{IDD_DIALOG_MEAS_TYPE	,	false},
	{IDD_DIALOG_USER_LOGIN	,	false},
	{IDD_DIALOG_POPUPLIST	,	false},
	{IDD_DIALOG_MAP_SORT	,	false},
	{IDD_DIALOG_PRINT			,	false},
	{IDD_DIALOG_POPUP			,	false},
	{IDD_DIALOG_CHECKLIST	,	false},
	{IDD_DIALOG_VIEWS			,	false},
	{IDD_DIALOG_DATE			,	false},
	{IDD_DIALOG_COMBOBOX		,	false},
	{IDD_DIALOG_AMP_SETTINGS	,	false},
	{IDD_DIALOG_SCROLL			,	false},
	{IDD_DIALOG_FLOAT			,	false},
	{IDD_DIALOG_EVENT			,	false},
	{IDD_CATHMAP_FORM			,	false},
	{IDD_DIALOG_VIDEO_TEAR	,	false},
	{IDD_DIALOG_COLORS			,	false},
	{IDD_DIALOG_EVENTS			,	false},
	{IDD_DIALOG_CHANNELS		,	false},
	{IDD_DIALOG_MAP_JUNCTION_BOX,	false},
	{IDD_DIALOG_MAP_NOTES		,	false},
	{IDD_DIALOG_WAIT_POPUP	,	false},
	{IDD_DIALOG_CHANNEL_SELECT	,	false},
	{IDD_DIALOG_EGM				,	false},
	{IDD_DIALOG_ATMMAP_CHANGE,	false},
	{IDD_DEFINE_DIALOG			,	false},
	{IDD_DIALOG_BEEP			,	false},
	{IDD_DIALOG_EDIT_PARAMS	,	false},
	{IDD_DIALOG_EP4_MENU		,	false},
	{IDD_DIALOG_EP4_PKEY_EDIT,	false},
	{IDD_DIALOG_USERS			,	false},
	{IDD_DIALOG_CALIBRATION	,	false},
	{IDD_DBMERGE_DIALOG		,	false},
	{IDD_DIALOG_ADD_RECORDED_CATHETER		,	false},
	{IDD_DIALOG_CHART_SUPPLIES	,	false},
	{IDD_DIALOG_CHART_MENU	,	false},
	{IDD_DIALOG_INSERT_EVENT	,	false},
	{IDD_DIALOG_LOGIN			,	false},
	{IDD_DIALOG_ADMIN			,	false},
	{IDD_DIALOG_USER			,	false},
	{IDD_DIALOG_CONSCIOUS_SEDATION,		false},
	{IDD_DIALOG_REPORT,						false},
	{IDD_DIALOG_FREQUENCY_CHANGE,			false},
	{IDD_DIALOG_CHART_AUTO_MEASUREMENTS,false},
	{IDD_DIALOG_DB_VIEWS,			false},
	{IDD_DIALOG_EDIT_DBVIEW,		false},
	{IDD_DIALOG_DB_FIELDS,			false},
	{IDD_DIALOG_CARTO_NOTES,		false},
	{IDD_DIALOG_ACT,					false},
	{IDD_DIALOG_TREE_MENU,			false},
	{IDD_DIALOG_BURN,					false},
	{IDD_DIALOG_TREE,					false},
	{IDD_DIALOG_DRUGS_TREE_MENU,	false},
	{IDD_DIALOG_CALCULATOR,			false},
	{IDD_DIALOG_MEDICATION_ANNOTATION, false},
	{IDD_DIALOG_SERVICE_AREA,	false},
	{IDD_DIALOG_CATHETER_WIZARD, false},
	{IDD_DIALOG_DICOM_QUERY_RETRIEVE, false},
	{IDD_DIALOG_MODIFY_PATIENT_ID, false},
	{IDD_DIALOG_IMPORT_CONFLICT_SOFT, false},
	{IDD_DIALOG_IMPORT_CONFLICT_HARD, false}
};

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::SetCreated()

	Description		:	This function sets the active dialog map whenever a dialog
							box is created.

	Returns			:	None.

	Setup				:	1. Acquire a video signal to the installed frame grabber in the 
								WorkMate PC.
							2. Open the Cine window.

	Testing			:	1. Press the 'Play' button. Verify the Cine application launches.
							2. Press the 'Record' keystroke. Verify the recording starts.
							3. Press the 'Record' keystroke again. Verify the recording stops.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::SetCreated( CWnd* pCurDlg , const UINT uiDlgId, const bool bFlag)
{
	bool bSuccess = false;

	if(m_INIfile.m_iCineMaximumDevices<=1)
	{
		bSuccess = (!m_bShellActive			&& 
						(m_dCine.m_bInstalled)	&& 
						m_dCine.GetInterrupt()	&& 
						(m_dCine.GetCineState(0)!=eCineOff));
	}
	else
	{
		bSuccess =	(!m_bShellActive			&& 
						 (m_dCine.m_bInstalled) && 
						 m_dCine.GetInterrupt() && 
						 ((m_dCine.GetCineState(0)!=eCineOff)||(m_dCine.GetCineState(1)!=eCineOff)));
	}

	if(bSuccess)
	{
		if(bFlag)
		{
			PushWindow( pCurDlg->GetSafeHwnd() );
			
			pCurDlg->SetWindowPos(&CWnd::wndTopMost, -1, -1, -1, -1, SWP_NOMOVE|SWP_NOSIZE);
			pCurDlg->BringWindowToTop();
		}
		else
		{
			if(m_iTopLevel>0)
			{
				PopWindow();
				
				if(m_iTopLevel<=0)
				{
					::SendMessage(HWND_BROADCAST, m_arMessage[CINE2WM_SET_ORDER].uiId, (WPARAM)1, (LPARAM)0);
				}
				else
				{
					HWND& hTopWnd = m_arTop[m_iTopLevel];

					::SetWindowPos(hTopWnd, HWND_TOPMOST, -1, -1, -1, -1, SWP_NOMOVE|SWP_NOSIZE);
					::BringWindowToTop(hTopWnd);
				}
			}
			else
			{
				::SendMessage(HWND_BROADCAST, m_arMessage[CINE2WM_SET_ORDER].uiId, (WPARAM)1, (LPARAM)0);
			}
		}
	}


	switch(uiDlgId)	
	{
		// ModeLess
		case	IDD_CATHMAP_FORM				:	m_bCathMapScrnActive = bFlag; break;
		case	IDD_DIALOG_CONFIG_SCREEN		:	m_bConfigScrnActive	= bFlag; break;
		case	IDD_DIALOG_PKEY_EDIT			:	m_bPKeyEditDlgActive = bFlag; break;
		case	IDD_DIALOG_MAP_JUNCTION_BOX		:	m_bMapJBoxAlive	= bFlag; break;
		case	IDD_DIALOG_CHART_SUPPLIES		:	m_bChartSuppliesDialogCreated = bFlag; break;

		// Modal
		case	IDD_ABOUTBOX					:
		case	IDD_DIALOG_ANALYSIS				:
		case	IDD_DIALOG_ANNOTATION			:
		case	IDD_DB_TAB_ARRH					:
		case	IDD_DIALOG_ARRHYTHMIA			:
		case	IDD_DIALOG_AUTO_RECORD			:
		case	IDD_DIALOG_CHANGE				:
		case	IDD_DIALOG_CINE_MODES			:
		case	IDD_DIALOG_COMTEST				:
		case	IDD_DIALOG_DATETIME				:
		case	IDD_DIALOG_DEVICE_STATUS		:
		case	IDD_DIALOG_DRUG					:
		case	IDD_EDIT_SCREEN					:
		case	IDD_DIALOG_FILE_LIST			:
		case	IDD_DIALOG_GRAPH				:
		case	IDD_DIALOG_GRAPH_EDIT			:
		case	IDD_DIALOG_GRAPH_LIST			:
		case	IDD_DIALOG_GRAPH_PICK_LIST		:
		case	IDD_DIALOG_GRID_SETTINGS		:
		case	IDD_DIALOG_CATHMAP_JUNCTION_BOX_1:
		case	IDD_DIALOG_CATHMAP_JUNCTION_BOX_2:
		case	IDD_DIALOG_CATHMAP_JUNCTION_BOX_3:
		case	IDD_DIALOG_LIST					:
		case	IDD_DIALOG_DEMO_LIST_NAMES		:
		case	IDD_DIALOG_MEAS_SAVE			:	
		case	IDD_DIALOG_MENU					:
		case	IDD_DIALOG_MESSAGE_BOX			:
		case	IDD_DIALOG_CATHMAP_NAME			:
		case	IDD_DIALOG_NOTEPAD				:
		case	IDD_DIALOG_OPENSCREEN			:
		case	IDD_DIALOG_CATHMAP_PMI_2		:
		case	IDD_DIALOG_CATHMAP_PMI_3		:
		case	IDD_DIALOG_PATIENT				:
		case	IDD_DIALOG_PRINT_REPORT			:
		case	IDD_DIALOG_PROGRESS				:
		case	IDD_DIALOG_TIME					:
		case	IDD_DIALOG_TRIGGER				:
		case	IDD_DIALOG_MEAS_TYPE			:
		case	IDD_DIALOG_USER_LOGIN			:
		case	IDD_DIALOG_POPUPLIST			:
		case	IDD_DIALOG_MAP_SORT				:
		case	IDD_DIALOG_PRINT				:	
		case	IDD_DIALOG_POPUP				:	
		case	IDD_DIALOG_CHECKLIST			:	
		case	IDD_DIALOG_VIEWS				:	
		case	IDD_DIALOG_DATE					:
		case	IDD_DIALOG_COMBOBOX				:
		case	IDD_DIALOG_AMP_SETTINGS			:
		case	IDD_DIALOG_SCROLL				:
		case	IDD_DIALOG_FLOAT				:
		case	IDD_DIALOG_EVENT				:
		case	IDD_DIALOG_VIDEO_TEAR			:
		case	IDD_DIALOG_COLORS				:
		case	IDD_CONFIG_TAB_COLORS			:
		case	IDD_DIALOG_EVENTS				:
		case	IDD_DIALOG_CHANNELS				:
		case	IDD_DIALOG_MAP_NOTES			:
		case	IDD_DIALOG_WAIT_POPUP			:
		case	IDD_DIALOG_CHANNEL_SELECT		:
		case	IDD_DIALOG_EGM					:
		case	IDD_DIALOG_ATMMAP_CHANGE		:
		case	IDD_DIALOG_USERS				:
		case	IDD_DIALOG_BEEP					:
		case	IDD_DIALOG_EDIT_PARAMS			:
		case	IDD_DIALOG_EP4_MENU				:
		case	IDD_DIALOG_CALIBRATION			:
		case	IDD_DBMERGE_DIALOG				:
		case	IDD_DIALOG_ADD_RECORDED_CATHETER:
		case	IDD_DIALOG_CHART_MENU			:
		case	IDD_DIALOG_INSERT_EVENT			:
		case	IDD_DIALOG_LOGIN				:
		case	IDD_DIALOG_OVERRIDE				:
		case	IDD_DIALOG_ADMIN				:
		case	IDD_DIALOG_USER					:
		case	IDD_DIALOG_CONSCIOUS_SEDATION	:
		case	IDD_DIALOG_REPORT				:
		case	IDD_DIALOG_FREQUENCY_CHANGE		:
		case	IDD_DIALOG_CHART_AUTO_MEASUREMENTS:
		case	IDD_DIALOG_DB_VIEWS				:
		case	IDD_DIALOG_EDIT_DBVIEW			:
		case	IDD_DIALOG_DB_FIELDS			:
		case	IDD_DIALOG_CARTO_NOTES			:
		case	IDD_DIALOG_ACT					:
		case	IDD_DIALOG_TREE_MENU			:		
		case	IDD_DIALOG_BURN					:
		case	IDD_DIALOG_TREE					:
		case	IDD_DIALOG_DRUGS_TREE_MENU		:
		case	IDD_DIALOG_CALCULATOR			:
		case	IDD_DIALOG_MEDICATION_ANNOTATION:
		case	IDD_DIALOG_SERVICE_AREA			:
		case	IDD_DIALOG_CATHETER_WIZARD		:
		case	IDD_DIALOG_DICOM_QUERY_RETRIEVE	:
		case	IDD_DIALOG_MODIFY_PATIENT_ID	:
		case	IDD_DIALOG_IMPORT_CONFLICT_SOFT	:
		case	IDD_DIALOG_IMPORT_CONFLICT_HARD	:
		{
			for(register int iIndex=0; iIndex<ARRAY_SIZE(m_mpDialogMap); ++iIndex)	
			{
				if(m_mpDialogMap[iIndex].uiId==uiDlgId)
				{				
					m_mpDialogMap[iIndex].bActive = bFlag;					
				}
			}
			break;
		}

		case	IDD_DIALOG_ARCHIVE				:	m_bArchiveCreated = bFlag; break;
		case	IDD_DIALOG_SYS_MAINT			:	m_bSysMaintCreated = bFlag;	break;
		case	IDD_DIALOG_QUERY				:	m_bQueryCreated	= bFlag; break;

		case	IDD_DIALOG_FORM					:
		case	IDD_DIALOGBAR_SHELL				:	
		case	IDD_DIALOG_STOP_WATCH			:	
		case	IDD_DIALOG_REVIEW_CHANGE		:
		case	IDD_DIALOG_MONITOR_CHANGE		:	
		case	IDD_DIALOG_PEPS					:	
		case	IDD_DIALOG_STATUS				:	
		case	IDD_DEFINE_DIALOG				:	
		case	IDD_DIALOG_PKEY_SAVE			:	
		case	IDD_DIALOG_EP4_PKEY_EDIT		:
		case	IDD_DIALOG_ANALOG_OUTPUT_IMPORT	:
			break;

		default:	
		{
			WMASSERT(0);	//	This is to Notify Us, that we have missed this Dialog	
			AfxTrace(_T("%u"), uiDlgId);
		}
		break;
	}
}

bool CWMApp::IsCreated( const UINT uiDlgId)
{
	switch(uiDlgId)	
	{
		// ModeLess
		case	IDD_CATHMAP_FORM				:	return m_bCathMapScrnActive;
		case	IDD_DIALOG_CONFIG_SCREEN	:	return m_bConfigScrnActive;
		case	IDD_DIALOG_PKEY_EDIT			:	return m_bPKeyEditDlgActive;
		case	IDD_DIALOG_MAP_JUNCTION_BOX:	return m_bMapJBoxAlive;
		case	IDD_DIALOG_CHART_SUPPLIES	:	return m_bChartSuppliesDialogCreated;

		// Modal
		case	IDD_ABOUTBOX						:
		case	IDD_DIALOG_ANALYSIS				:
		case	IDD_DIALOG_ANNOTATION			:
		case	IDD_DB_TAB_ARRH					:
		case	IDD_DIALOG_ARRHYTHMIA			:
		case	IDD_DIALOG_AUTO_RECORD			:
		case	IDD_DIALOG_CHANGE					:
		case	IDD_DIALOG_CINE_MODES			:
		case	IDD_DIALOG_COMTEST      		:
		case	IDD_DIALOG_DATETIME				:
		case	IDD_DIALOG_DEVICE_STATUS		:
		case	IDD_DIALOG_DRUG					:
		case	IDD_EDIT_SCREEN					:
		case	IDD_DIALOG_FILE_LIST				:
		case	IDD_DIALOG_GRAPH					:
		case	IDD_DIALOG_GRAPH_EDIT			:
		case	IDD_DIALOG_GRAPH_LIST			:
		case	IDD_DIALOG_GRAPH_PICK_LIST		:
		case	IDD_DIALOG_GRID_SETTINGS		:
		case	IDD_DIALOG_CATHMAP_JUNCTION_BOX_1:
		case	IDD_DIALOG_CATHMAP_JUNCTION_BOX_2:
		case	IDD_DIALOG_CATHMAP_JUNCTION_BOX_3:
		case	IDD_DIALOG_LIST					:
		case	IDD_DIALOG_DEMO_LIST_NAMES		:
		case	IDD_DIALOG_MEAS_SAVE				:	
		case	IDD_DIALOG_MENU					:
		case	IDD_DIALOG_MESSAGE_BOX			:
		case	IDD_DIALOG_CATHMAP_NAME			:
		case	IDD_DIALOG_NOTEPAD				:
		case	IDD_DIALOG_OPENSCREEN			:
		case	IDD_DIALOG_CATHMAP_PMI_2		:
		case	IDD_DIALOG_CATHMAP_PMI_3		:
		case	IDD_DIALOG_PATIENT				:
		case	IDD_DIALOG_PRINT_REPORT			:
		case	IDD_DIALOG_PROGRESS				:
		case	IDD_DIALOG_TIME					:
		case	IDD_DIALOG_TRIGGER				:
		case	IDD_DIALOG_MEAS_TYPE				:
		case	IDD_DIALOG_USER_LOGIN			:
		case	IDD_DIALOG_POPUPLIST				:
		case	IDD_DIALOG_MAP_SORT:
		case	IDD_DIALOG_PRINT					:	
		case	IDD_DIALOG_POPUP					:	
		case	IDD_DIALOG_CHECKLIST				:	
		case	IDD_DIALOG_VIEWS					:	
		case	IDD_DIALOG_DATE					:
		case	IDD_DIALOG_COMBOBOX				:
		case	IDD_DIALOG_AMP_SETTINGS			:
		case	IDD_DIALOG_SCROLL					:
		case	IDD_DIALOG_FLOAT					:
		case	IDD_DIALOG_EVENT					:
		case	IDD_DIALOG_VIDEO_TEAR			:
		case	IDD_DIALOG_COLORS					:
		case	IDD_DIALOG_EVENTS					:
		case	IDD_DIALOG_CHANNELS				:
		case	IDD_DIALOG_MAP_NOTES				:
		case	IDD_DIALOG_WAIT_POPUP			:
		case	IDD_DIALOG_CHANNEL_SELECT		:
		case	IDD_DIALOG_EGM						:
		case	IDD_DIALOG_ATMMAP_CHANGE		:
		case	IDD_DIALOG_USERS					:
		case	IDD_DIALOG_BEEP					:
		case	IDD_DIALOG_EDIT_PARAMS			:
		case	IDD_DIALOG_EP4_MENU				:
		case	IDD_DIALOG_CALIBRATION			:
		case	IDD_DBMERGE_DIALOG				:
		case	IDD_DIALOG_ADD_RECORDED_CATHETER	:
		case	IDD_DIALOG_CHART_MENU			:
		case	IDD_DIALOG_INSERT_EVENT			:
		case	IDD_DIALOG_LOGIN					:
		case	IDD_DIALOG_OVERRIDE					:
		case	IDD_DIALOG_ADMIN					:
		case	IDD_DIALOG_USER					:
		case	IDD_DIALOG_CONSCIOUS_SEDATION	:
		case	IDD_DIALOG_REPORT					:
		case	IDD_DIALOG_FREQUENCY_CHANGE	:
		case	IDD_DIALOG_CHART_AUTO_MEASUREMENTS:
		case	IDD_DIALOG_DB_VIEWS				:
		case	IDD_DIALOG_EDIT_DBVIEW			:
		case	IDD_DIALOG_DB_FIELDS				:
		case	IDD_DIALOG_CARTO_NOTES			:
		case	IDD_DIALOG_ACT						:
		case	IDD_DIALOG_TREE_MENU				:		
		case	IDD_DIALOG_BURN					:
		case	IDD_DIALOG_TREE					:
		case	IDD_DIALOG_DRUGS_TREE_MENU		:
		case	IDD_DIALOG_CALCULATOR			:
		case	IDD_DIALOG_MEDICATION_ANNOTATION:
		case	IDD_DIALOG_SERVICE_AREA			:
		case	IDD_DIALOG_CATHETER_WIZARD		:
		case	IDD_DIALOG_DICOM_QUERY_RETRIEVE:
		case	IDD_DIALOG_MODIFY_PATIENT_ID	:
		{
			for(register int iIndex=0; iIndex<=ARRAY_SIZE(m_mpDialogMap); ++iIndex)	
			{
				if(m_mpDialogMap[iIndex].uiId==uiDlgId)
				{
					if(m_mpDialogMap[iIndex].bActive)	
					{
						return true;
					}
				}
			}
		}
		break;
		case	IDD_DIALOG_ARCHIVE				:	return m_bArchiveCreated;
		case	IDD_DIALOG_SYS_MAINT				:	return m_bSysMaintCreated;
		case	IDD_DIALOG_QUERY					:	return m_bQueryCreated;
		case	IDD_DIALOG_FORM					:
		case	IDD_DIALOG_STOP_WATCH			:	
		case	IDD_DIALOG_REVIEW_CHANGE		:
		case	IDD_DIALOG_MONITOR_CHANGE		:	
		case	IDD_DIALOG_PEPS					:	
		case	IDD_DIALOG_STATUS					:	
		case	IDD_DEFINE_DIALOG					:	
		case	IDD_DIALOG_PKEY_SAVE				:	
		case	IDD_DIALOG_EP4_PKEY_EDIT		:	break;
		case	IDD_DIALOG_ANALOG_OUTPUT_IMPORT	:	break;

		default										:	
		{
			WMASSERT(0);	//	This is to Notify Us, that we have missed this Dialog	
			AfxTrace(_T("%u"), uiDlgId);
		}
		return false;
	}

	return false;
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::ExportA_A()

	Description	:	This function exports the peak to peak intervals on the HRA 
						channel based on the tick interval marks in the HIS channel
						on the same page between the PrevReview and Review screens.

	Returns		:	None

	Setup			:	1.	Split the PrevReview and the Review screens.
						2. Verify the HIS and the HRA channels are present on the 
						screen.
						3. Place some tick interval marks on the HIS channel.
						4. Set the A-A analysis on the HRA channel.

	Testing		:	1. Press the CTRL+SHIFT+H keystroke on the keyboard and
							verify the File Save dialog display.
						2. Save the file and verify the exported file has the data
							in it.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::ExportA_A(LPCTSTR csExport, SExportInfo& m_seInfo)
{
	// 1. Look for the HIS & HRA channels
	short iHISChannel = -1, iHRAChannel=-1;
	CReviewPortParams& rReview = m_dReview.m_rppReview;
	short ariHISInterval[3]={0};
	register short iHISTickCount =0;

   for (register short iChannelN=0; iChannelN<MAX_SCREEN_CHANNELS; ++iChannelN) 
	{
		short iChannelType = m_dReview.ChannelType(iChannelN);

		switch (iChannelType)
		{
			case CSignalDoc::TYPE_HIS:
			{
				memset(ariHISInterval, 0, sizeof(ariHISInterval));
				iHISTickCount =0;
			   // Look for the 3 tick marks on the HIS channel
				for(register short iIndex=0; iIndex<m_dPrevReview.m_rppReview.intervalN; ++iIndex) 
				{
					if( m_dPrevReview.m_rppReview.interval_channel[iIndex]==iChannelN && 
						 m_dPrevReview.m_rppReview.interval_pageN[iIndex]==m_dPrevReview.m_rppReview.iPageN	&&
						 iHISTickCount<(ARRAY_SIZE(ariHISInterval)))
					{
						ariHISInterval[iHISTickCount] = m_dPrevReview.m_rppReview.interval[iIndex];

						++iHISTickCount;
					}
				}
				if(iHISTickCount == ARRAY_SIZE(ariHISInterval)) iHISChannel = iChannelN;
			}
			break;

			case CSignalDoc::TYPE_A:
			{
				iHRAChannel = iChannelN;
			}
			break;

			default:	//Loop through till HIS channel is found.
			break;
		}

		if(iHISChannel>-1 && iHRAChannel>-1)
		{
			//Found it
			break;
		}
	}

	if(iHISChannel==-1)
	{
		// Could not find the iHISChannel channel.
		CMessage::PopupMessage(WMFILELINE, GETMESSAGE(1761));
		return;
	}

	if(iHRAChannel==-1)
	{
		// Could not find the iHRAChannel channel.
		// CMessage::PopupMessage();
		CMessage::PopupMessage(WMFILELINE, GETMESSAGE(1762));
		return;
	}

	// 3. Locate the A-A intervals on the HRA channel.
	CFileDB	ecg_file;
	
	short arPeak2Peak[10000]={0};
	int iMaxPeak2Peak	=	0;
	int iState			=	0;
	int iHISCount1		=	0;
	int iHISCount2		=	0;
	int iMin				=	0;
	int iMax				=	0;
	register short iFileNumber = (short) m_seInfo.lBegFileNumber;
	//for(register short iFileNumber = m_seInfo.lBegFileNumber; iFileNumber<=m_seInfo.lEndFileNumber; ++iFileNumber)
	{
		TCHAR szFullPath[MAX_PATH] = {0};
		if(ecg_file.Open( m_dLog.MakeEcgName(iFileNumber, szFullPath, sizeof(szFullPath)), 
								OPF_READ, 
								9999, 
								ON_ERROR_RETURN ))
		{
			// Read the signal header
			SSignalHeader signal_header={0};
			m_dLog.ReadSignalHeader( signal_header, ecg_file );

			// Calc the file length
 			long file_length = (signal_header.total_channelN>0) ? 
									((long)ecg_file.GetLength()-signal_header.offset)/LogSampleSize(signal_header.total_channelN) : 0;

			signal_header.map.config[rReview.iPageN][iHRAChannel].analysis = TRIG_ATRIAL;
			SChannelAnalysis sAnalysis={0};
			m_dMonitor.InitAnalysis(&sAnalysis, 
											&signal_header.map.config[rReview.iPageN][iHRAChannel], 
											1, 
											false, 
											signal_header.map.signal_resolution);

			short	iValue						=	0;
			short	ariEcg[MAX_LOG_CHANNELS]=	{0};
			SChannelConfig* pConfig			=	NULL;

			// Note: this should be only one, but there is no overloaded InitFilters function which takes only one filter.
			// I will write it later as it takes rebuilding the whole project
			SSampleFilter filter[MAX_SCREEN_CHANNELS]={0};	

			// initialize the filter first 
			m_flFilter.InitFilters( filter, signal_header.map.config[rReview.iPageN]);

			USHORT usSampleSize = LogSampleSize( signal_header.total_channelN);

			long lNextRead = m_seInfo.lBegFilePosition;

			ecg_file.Seek( lNextRead * usSampleSize + signal_header.offset, CFile::begin );

			long lEndFilePosition = (m_seInfo.lBegFileNumber==m_seInfo.lEndFileNumber) ?
											 m_seInfo.lEndFilePosition : file_length;

			iState=0;

			while( (lNextRead<lEndFilePosition) )
			{
				if(ecg_file.Read(ariEcg, usSampleSize) != usSampleSize)
				{
					break; // there is no more
				}

				{
					pConfig = &signal_header.map.config[rReview.iPageN][iHRAChannel];

					iValue = (short)CSignalDoc::DecodeChannel(ariEcg[ signal_header.log_map[pConfig->pos_offset] ],
																			ariEcg[ signal_header.log_map[pConfig->neg_offset] ],
																			m_INIfile.m_bReverseSignal && pConfig->cath_row==CATH_ROW_BOX);

					// now analyze
					if( pConfig->analysis )
					{
						if(m_dMonitor.PerformAnalysis( sAnalysis, iValue, false ) != 0 )
						{					
							iState = 1;
							iHISCount1=0;
						}
					}

					// now filter
					iValue = (short)m_flFilter.FilterSample( filter[iHRAChannel], iValue );
				}
				{
					pConfig = &signal_header.map.config[rReview.iPageN][iHISChannel];

					iValue = (short)CSignalDoc::DecodeChannel(ariEcg[ signal_header.log_map[pConfig->pos_offset] ],
																			ariEcg[ signal_header.log_map[pConfig->neg_offset] ],
																			m_INIfile.m_bReverseSignal && pConfig->cath_row==CATH_ROW_BOX);

					
					// now filter
					iValue = (short)m_flFilter.FilterSample( filter[iHISChannel], iValue );
				}
				
				switch(iState)
				{
					case 0: 
					break;

					case 1: 
					{
						++iHISCount1;

						if(iHISCount1>=ariHISInterval[1])
						{
							iState=2;
							iMin = ECG_VALUE_LIMIT_32BIT;
							iMax = -ECG_VALUE_LIMIT_32BIT;
							
							iHISCount2=0;
						}
					}
					break;

					case 2:
					{
						iMax = max(iMax, iValue);
						iMin = min(iMin, iValue);

						if(++iHISCount2>=ariHISInterval[2])
						{
							arPeak2Peak[iMaxPeak2Peak]=iMax-iMin;

							++iMaxPeak2Peak;
							if(iMaxPeak2Peak>=10000)
							{
								lNextRead=lEndFilePosition;
							}

							iState = 0;


						}
					}
					break;

				}

				lNextRead++;
			}

			ecg_file.Close();
		}
	}

	// Create the Export file
	CFileStream cfsFile; 
	if(cfsFile.Open(csExport, _T("wt")))
	{
		for(int iIndex=0; iIndex<iMaxPeak2Peak; ++iIndex)
		{
			_ftprintf(cfsFile, _T("%d\r\n"), arPeak2Peak[iIndex]);
		}

		cfsFile.Close();
	}
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::ProcessHotkey()

	Description	:	This function processes the keystrokes and passes them to the 
						related modules. If the keystroke is not handled then it returns
						a false value to the frame work.

	Returns		:	boolean(true or false).

	Setup			:	1. Open the Review screen.
	PACING SITES:
						1. Open the stimulator window.
	REVIEW PRINTING:
						1. Open the Review and PrevReview windows in a split screen.
REVIEW SCREEN JPEG:
						1. Open the Review screen.

	Testing		:	1. Press the 'x' keystroke and verify the application exits to the shell.
						2. Press the 'CTRL+SHIFT+F' keystroke and verify the Review-Frequency splitter 
							screen is shown. Press the keystroke again and verify the splitter is
							hidden and only Review screen is shown.
	PAST RECORDING:
						1. Press the 'TAB' keystroke on the keyboard. Verify the recording starts.
						2. Press the 'SHIFT+TAB' keystroke on the keyboard. Verify the recording starts.

	PACING SITES:
						1. Press the 'CTRL+SHIFT+1' keystroke. Verify the pacing site A1 
						check box control is toggled.
						2. Press the 'CTRL+SHIFT+2' keystroke. Verify the pacing site B1 
						check box control is toggled.
						3. Press the 'CTRL+SHIFT+3' keystroke. Verify the pacing site A2 
						check box control is toggled.
						4. Press the 'CTRL+SHIFT+4' keystroke. Verify the pacing site B2 
						check box control is toggled.
	REVIEW PRINTING:
						1. Press the 'Print Preview' keystroke on the keboard. Verify both the
						screens are printed on the page from the printer.
						2. Press the 'Split' button on the MainBar. Verify the PrevReview window
						closes. Verify only the Review Screen is visible.
						3. Repeat Step 1. Verify only the Review screen is printed on the page from 
						the printer.
						4. Press the 'RF' button on the MainBar. Verify the RF and Review screens
						are displayed in a split setup.
						5. Repeat Step 1. Verify only the Review screen is printed on the page from 
						the printer.
	MAPPING NOTES:
						1. Press the '|' keystroke. Verify the mapping notes window displays.
REVIEW SCREEN JPEG:
						1. Press the 'CTRL+ALT+SHIFT+A' keystroke on the keyboard. Verify the 
						Review screen saves as a JPEG image file in the Slides path.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
bool CWMApp::ProcessHotkey(const int iVirtKey, const long lKeyData)
{
	AfxTrace(_T("Key %d, %d\n"), iVirtKey, lKeyData);

	const SHORT iAltState		=	::GetKeyState(VK_MENU);
	const bool	bLeftAlt			=	( (iAltState<0) && (iVirtKey!=VK_MENU) && (lKeyData!=538968065L) );
	const bool	bRightAlt		=	( (iVirtKey==VK_MENU) && (lKeyData==557318145L) );
	const SHORT iShiftState		=	::GetKeyState(VK_SHIFT);
	const SHORT iControlState	=	::GetKeyState(VK_CONTROL);

	if( bRightAlt )	//	ALT based.
	{
		AfxTrace(_T("Right ALT%d\n"));

		if( m_dLog.m_iSaveData )		// Turn Off Recording
		{
			m_dMonitor.TurnSaveOff();

			return true;
		}	
		else	// Start Recording.
		{	
			if(!m_dMonitor.m_bEnetInterrupts && !m_dMonitor.m_iDemoMode)
			{
				CMessage::PopupMessage(WMFILELINE, 865, 3000);
				return false;
			}
			
			if(IsPassiveMode())
			{
				CMessage::Beep();
				return false;
			}
	
			if(m_vReview)	
			{
				m_vReview->SaveAndDrawOneScreen(ACQUIRE_MODE_CONTINUOUS);

				return true;
			}

			return false;
		}
	}

	if(bLeftAlt											&&	// Left Alt
		(iShiftState<0 && iVirtKey!=VK_SHIFT)	&&	//	SHIFT based.
		(iControlState<0 && iVirtKey!=VK_CONTROL))//	CONTROL based.
	{
		AfxTrace(_T("ALT+SHIFT+CTRL"));

		switch(iVirtKey)	
		{
			case _T('A') :
			{
				if(CWMLibrary::IsWindowVisible(m_fReview))
				{
					m_bAskPath = false;	
					AfxBeginThread(CMainBar::CreateInvertedReviewJPEGFile, &m_bAskPath);
					return true;
				}
				else
				{
					CMessage::PopupMessage(WMFILELINE, 1691);
				}
			}
			return false;

			case _T('B') :
			{
				/* Razor 2468
				if(CWMLibrary::IsWindowVisible(m_fReview))
				{
					m_bAskPath = false;	
					AfxBeginThread(CMainBar::CreateInvertedReviewBMPFile, &m_bAskPath);
					return true;
				}
				else
				{
					CMessage::PopupMessage(WMFILELINE, 1691);
				}*/
			}
			return false;

			case _T('D') :
			{
#ifndef PHILIPS_VIEWER
				CString csMesg;
				csMesg.Format(	_T("%s: %s"), GETMESSAGE(400), 
									(IsActiveMode() ? GETMESSAGE(2567) : GETMESSAGE(2568) ));
				CMessage::PopupMessage(WMFILELINE, csMesg);
				return true;
#endif
			}
			return false;

			case _T('N') :
			{
#ifndef PHILIPS_VIEWER
				if(CWMLibrary::IsSafeWindow(m_vCathMap))
				{
					m_vCathMap->ConfigSetup();
					return true;
				}
#endif
				return false;
			}

			case _T('L')	:
			{
				m_dLog.FixLogEntries();

			   m_dLog.CreateLogEntriesMenu(true);
				m_vLog->RedrawLogWindow();				// Lets Test This

				return true;
			}
			case _T('M')	:
			{
				if(m_vDB && m_vDB->IsWindowVisible())
				{
					CMergeDialog mgDialog(m_fMain);

					mgDialog.DoModal();

					return true;
				}
				return false;
			}
			case _T('O') :
			{
				FixOpticals();
				return true;
			}
			case _T('R')	:
			{
				m_dRF.ShowCommErrorResults();
				return true;
			}

			case _T('F') :
			{
#ifndef PHILIPS_VIEWER
				if (m_vCathMap && m_vCathMap->IsWindowVisible())
				{
					m_vCathMap->ConvertDOSCathMap();
					return true;
				}
#endif
				return false;
			}
		}
	}

	if(!bLeftAlt										&& // Left Alt
		!bRightAlt										&& // Right Alt
		(iShiftState<0 && iVirtKey!=VK_SHIFT)	&&	//	SHIFT based.
		(iControlState<0 && iVirtKey!=VK_CONTROL))//	CONTROL based.
	{
		switch(iVirtKey)	
		{	
			case _T('0'):
			{
				m_dFreqReview.m_bDisplayFileSamplesOnReview = !m_dFreqReview.m_bDisplayFileSamplesOnReview;

				if(m_vReview)
				{
					m_vReview->InvalidateView();
				}
			}
			break;

			case _T('1') :
			{
#ifndef PHILIPS_VIEWER
				m_Stim.OnCheckA1();
#endif
			}
			break;

				case _T('2') :
			{
#ifndef PHILIPS_VIEWER
				m_Stim.OnCheckA2();
#endif
			}
			break;

			case _T('3') :
			{
#ifndef PHILIPS_VIEWER
				m_Stim.OnCheckB1();
#endif
			}
			break;

			case _T('4') :
			{
#ifndef PHILIPS_VIEWER
				m_Stim.OnCheckB2();
#endif
			}
			break;

			case _T('A') :
			{
				#ifdef ALLURA_TSM
					CString csAccession(m_sAllura.wzAccession);
					CString csProcedureId(m_sAllura.wzRequestedProcedureId);
					CString csMesg; csMesg.Format(_T("%s: %s - %s: %s"), GETMESSAGE(2569), csAccession, GETMESSAGE(2570), csProcedureId);
					CMessage::PopupMessage(WMFILELINE, csMesg);
				#endif
			}
			break;

			case _T('B') :
			{
				//AfxTrace("ALT+SHIFT+CTRL+B\n");

				if(m_Session.entry_count>0)
				{
					TCHAR szFullPath[MAX_PATH]={0};
					MakePath(_T("RF_EXPORT_TEST.TXT"), szFullPath, sizeof(szFullPath));

					FILE* pFile = _tfopen(szFullPath, _T("wt"));
					
					if(pFile)
					{					
						SPowerAvg arPower[MAX_SESSION_ENTRIES] = {0};
						int iPowerAvgCount = 0;

						CString cs;
						cs.Format(_T("POWER\tTIME\n"));
						_fputts(cs, pFile);

						for(register short iIndex = 0; iIndex<m_Session.entry_count; ++iIndex)
						{												
							if(iIndex>0)
							{
								const long lT1 = (long)CRFDoc::SessionTime(iIndex-1);
								const long lT2 = (long)CRFDoc::SessionTime(iIndex);
									
								if(lT1==lT2)
								{
									arPower[iPowerAvgCount].lPower += theApp.m_Session.entry[iIndex].power;
									arPower[iPowerAvgCount].lTime = lT1;
									++arPower[iPowerAvgCount].iCount;
								}
								else
								{																		
									++iPowerAvgCount;		// go to the next one.
									arPower[iPowerAvgCount].iCount = 0;	//reset for the ave power
									arPower[iPowerAvgCount].lPower += theApp.m_Session.entry[iIndex].power;
									arPower[iPowerAvgCount].lTime = lT2;
									++arPower[iPowerAvgCount].iCount;	
								}
							}
							else
							{
								arPower[iPowerAvgCount].iCount = 0;
								arPower[iPowerAvgCount].lPower += theApp.m_Session.entry[iIndex].power;
								arPower[iPowerAvgCount].lTime  = (long)CRFDoc::SessionTime(iIndex);								
								++arPower[iPowerAvgCount].iCount;
							}

							cs.Format(_T("%u\t%d\n"), theApp.m_Session.entry[iIndex].power, (long)CRFDoc::SessionTime(iIndex));
							_fputts(cs, pFile);
						}

						cs.Format(_T("\n\n\n"));
						_fputts(cs, pFile);

						double dEnergy = 0.0;
						for(iIndex = 0; iIndex<iPowerAvgCount; ++iIndex)
						{
							if(arPower[iIndex].iCount>0)
							{
								arPower[iIndex].lPower = arPower[iIndex].lPower/arPower[iIndex].iCount;
							}
							
							if(iIndex>0)
							{		
								dEnergy += (arPower[iIndex].lPower+arPower[iIndex-1].lPower) * 
													(arPower[iIndex].lTime-arPower[iIndex-1].lTime)/2.0;
							}

							cs.Format(_T("%u\t%d\n"), arPower[iIndex].lPower, arPower[iIndex].lTime);
							_fputts(cs, pFile);
						}

						cs.Format(_T("Energy:%d\n"), (int)dEnergy);
						_fputts(cs, pFile);							
						
						fclose(pFile);
						pFile = NULL;
						
						CMessage::PopupMessage(WMFILELINE, GETMESSAGE(2571));
					}
				}				
			}
			break;
			
			case _T('D')	:
			{
#ifndef PHILIPS_VIEWER
				if(IsCreated(IDD_DIALOG_OPENSCREEN))
				{
					if( CWMLibrary::IsSafeWindow(COpenScreen::m_pSelf) )
					{						
						COpenScreen::m_pSelf->RetrievePatientsFromArchive();
					}
				}
#endif
			}
			break;

			case _T('F') :
			{
				/*if(CWMLibrary::IsSafeWindow(m_fReview) && CWMLibrary::IsSafeWindow(m_vFreqReview))
				{
					if(!m_vFreqReview->IsWindowVisible())
					{
						m_fReview->Toggle(true);

						m_dFreqReview.GetCurrentFreqPage(m_dFreqReview.m_iFreqWindowType, m_dFreqReview.m_iSamples);
					
						m_fReview->ShowWindow(SW_SHOW);
						m_fReview->BringWindowToTop();				
					}
					else
					{
						m_fReview->Toggle(false);
					}

					return true;
				}*/ // Razor3273 Deactivate Ctrl-Shift-F hot key 

				return false;
			}

			case _T('R') :
			{
				if(m_dCine.m_bInstalled)
				{
					::SendNotifyMessage(	HWND_BROADCAST, 
												m_arMessage[WM2CINE_GET_REFRESH_RATE].uiId, 
												(WPARAM)0, 
												(LPARAM)0);
					return true;
				}

				return false;
			}

			case _T('S') :
			{
				OLECHAR wzGuid[40]= {0};
				char szGuid[40]	= {0};

				if(!::StringFromGUID2(m_dProcedure.m_Procedure2.sSUID, wzGuid, 40))
				{
					return NULL;
				}

				size_t tRet = wcstombs(szGuid, wzGuid, 40);
				
				CMessage::PopupMessage(WMFILELINE, CA2T(szGuid));
				return true;
			}
			return false;

			case _T('H') :
			{
				if( !(m_fReview->IsWindowVisible() && m_fPrevReview->IsWindowVisible()) )
				{
					CMessage::PopupMessage(WMFILELINE, GETMESSAGE(743));
					return false;
				}

				if( m_dReview.m_rppReview.iPageN != m_dPrevReview.m_rppReview.iPageN )
				{
					CMessage::PopupMessage(WMFILELINE, GETMESSAGE(743));
					return false;
				}
				
				TCHAR szFilter[] = _T("Text Files (*.txt)|*.txt|All Files (*.*)|*.*||");

				CString csExport;
				CWMFileDialog fdDialog(FALSE, _T("*.txt"), csExport, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, szFilter, m_fMain);

				if(fdDialog.DoModal()==IDOK)
				{
					csExport = (fdDialog.m_ofn.lpstrFile);

					::SetCurrentDirectory(m_INIfile.m_szMsiDirName);	// reset the Current Directory Here, because the DirDialog changed it.

					SExportInfo	m_seInfo;
					m_seInfo.bAscii = true; 

					// lets use the m_rppReview port for all input and output, then reload it
					m_seInfo.lBegFileNumber		=	m_dPrevReview.m_rppReview.file_number;
					m_seInfo.lBegFilePosition	=	m_dPrevReview.m_rppReview.file_position;

					m_seInfo.lEndFileNumber		=	m_dReview.m_rppReview.file_number;
					m_seInfo.lEndFilePosition	=	m_dReview.m_rppReview.file_position+m_dReview.m_rppReview.screen_size;
					if (m_seInfo.lEndFilePosition	> m_dReview.m_rppReview.file_length) m_seInfo.lEndFilePosition = m_dReview.m_rppReview.file_length;
					m_seInfo.lFileNumber=-1L;

					ExportA_A(csExport, m_seInfo);

					return true;
				}

				return false;
			}

			case	VK_F1	:
			{
				m_MainBar.EventHotKeys(13);
			}
			return true;

			case	VK_F2	:
			{
				m_MainBar.EventHotKeys(14);
			}
			return true;

			case	VK_F3	:
			{
				m_MainBar.EventHotKeys(15);
			}
			return true;

			case	VK_F4	:
			{
				m_MainBar.EventHotKeys(16);
			}
			return true;

			case	VK_F5	:
			{
				m_MainBar.EventHotKeys(17);
			}
			return true;

			case	VK_F6	:
			{
				m_MainBar.EventHotKeys(18);
			}
			return true;

			case	VK_F7	:
			{
				m_MainBar.EventHotKeys(19);
			}
			return true;

			case	VK_F8	:
			{
				m_MainBar.EventHotKeys(20);
			}
			return true;

			case	VK_F9	:
			{
				m_MainBar.EventHotKeys(21);
			}
			return true;

			case	VK_F10	:
			{
				m_MainBar.EventHotKeys(22);
			}
			return true;

			case	VK_F11	:
			{
				m_MainBar.EventHotKeys(23);
			}
			return true;

			case	VK_F12	:
			{
				m_MainBar.EventHotKeys(24);
			}
			return true;
		}
	}

	if( bLeftAlt )	// Left Alt
	{
		AfxTrace(_T("ALT + Key %d\n"), iVirtKey);

		switch(iVirtKey)	
		{
			case _T('C')	:
			{
				if( IsDialogsActive() )
				{
					return false;
				}
			
				if(m_fChart)
				{
					CWMLibrary::HandleClicks(m_fChart, eChart);
					m_MainBar.SetButtonColor(eChart);

					return true;
				}
			}
			return false;

			case _T('L')	:
			{
			}
			break;

			case _T('N')	:
			{
				if(CWMLibrary::IsSafeWindow(m_vATMMap) && !bRightAlt)
				{
					if( IsDialogsActive() )
					{
						return false;
					}
				
					if(m_vATMMap->m_iCurZone>-1)
					{
						m_vATMMap->AddNotes();
						
						return true;
					}
				}
			}
			return false;

			case _T('G')	:
			{
				if( IsDialogsActive() )
				{
					return false;
				}
			
				HorizontalSplit(eReview, eLog);
			}
			return true;

			case _T('M')	:
			{
				if( IsDialogsActive() )
				{
					return false;
				}
			
				HorizontalSplit(eReview, eMeasurement);
			}
			return true;

			case _T('O')	:
			{
				return AddMappingNotes();
			}
			return false;

			case _T('T')	:	// Text Annotation
			{
			}
			return false;

			case _T('S')	:	// Signal Annotation
			{
			}
			return false;

			case VK_DOWN :
			{
				if(m_vReview)
				{
					m_vReview->ReviewAmpDown();
				}
			}
			return true;

			case VK_UP:
			{
				if(m_vReview)
				{
					m_vReview->ReviewAmpUp();
				}
			}
			return true;

			case 	VK_LEFT:
			{
				if(m_iTriggeredSweepActive[TS_REVIEW] || (m_uiTriggeredReviewMode!=TRIGGERED_MODE_NONE))
				{
					return false;
				}

				if(m_vReview && m_fReview)
				{	
					if(!m_fReview->m_pSignalBar->m_bButtonClick)
					{	
						CWMLibrary::StopScrolling( m_vReview, m_fReview->m_pSignalBar);
					}
					m_fReview->m_pSignalBar->Scroll( m_vReview, true, false);
					m_fReview->m_pSignalBar->m_bButtonClick=!m_fReview->m_pSignalBar->m_bButtonClick;
				}
			}
			return true;

			case 	VK_RIGHT:
			{
				if(m_iTriggeredSweepActive[TS_REVIEW] || (m_uiTriggeredReviewMode!=TRIGGERED_MODE_NONE))
				{
					return false;
				}

				if(m_vReview && m_fReview)
				{
					if(!m_fReview->m_pSignalBar->m_bButtonClick)
					{	
						CWMLibrary::StopScrolling( m_vReview, m_fReview->m_pSignalBar);
					}
					m_fReview->m_pSignalBar->Scroll( m_vReview, false, false);
					m_fReview->m_pSignalBar->m_bButtonClick=!m_fReview->m_pSignalBar->m_bButtonClick;
				}
			}
			return true;

			case	VK_F1	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(0);
			}
			return true;

			case	VK_F2	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(1);
			}
			return true;

			case	VK_F3	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(2);
			}
			return true;

			case	VK_F4	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(3);
			}
			return true;

			case	VK_F5	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(4);
			}
			return true;

			case	VK_F6	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(5);
			}
			return true;

			case	VK_F7	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(6);
			}
			return true;

			case	VK_F8	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(7);
			}
			return true;

			case	VK_F9	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(8);
			}
			return true;

			case	VK_F10	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(9);
			}
			return true;

			case	VK_F11	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(10);
			}
			return true;

			case	VK_F12	:
			{
				m_dCathMap.RealtimeProtocolHotKeys(11);
			}
			return true;
		}

		return false;
	}

	AfxTrace(_T("Shift State %d\n"), iShiftState);

	if(iShiftState<0 && iVirtKey!=VK_SHIFT)	//	SHIFT based.
	{
		AfxTrace(_T("SHIFT + Key %d\n"), iVirtKey);

		switch( iVirtKey)	
		{
			case	_T('3'):
			{
				if( IsDialogsActive() )
				{
					return false;
				}

#ifndef PHILIPS_VIEWER

				if( !CWMLibrary::IsSafeWindow(m_vCathMap) )
				{
					return false;
				}

				m_vCathMap->OnButtonReNumber();
#endif				
			}
			return true;
		
			case	VK_LEFT	:
			{
				if( IsDialogsActive() )
				{
					return false;
				}

				if( !CWMLibrary::IsSafeWindow(m_vReview) || !CWMLibrary::IsSafeWindow(m_fReview) )
				{
					return false;
				}

				m_vReview->LogLeft(m_fReview->m_pSignalBar );
			}
			return true;

			case	VK_RIGHT:
			{
				if( IsDialogsActive() )
				{
					return false;
				}

				if( !CWMLibrary::IsSafeWindow(m_vReview) || !CWMLibrary::IsSafeWindow(m_fReview) )
				{
					return false;
				}

				m_vReview->LogRight(m_fReview->m_pSignalBar);
			}
			return true;

			case	VK_DOWN:
			{
				if( IsDialogsActive() )
				{
					return false;
				}

				if( !CWMLibrary::IsSafeWindow(m_vReview) || !CWMLibrary::IsSafeWindow(m_fReview) )
				{
					return false;
				}
				
#ifndef PHILIPS_VIEWER
				if(  m_INIfile.m_iEP4Installed>=STIMULATOR_EP4 && IsStimActive() )
#endif
				{
					return false;
				}
				
				m_vReview->ReviewPageDown(m_fReview->m_pSignalBar);
			}
			return true;

			case	VK_UP:
			{
				if( IsDialogsActive() )
				{
					return false;
				}

				if( !CWMLibrary::IsSafeWindow(m_vReview) || !CWMLibrary::IsSafeWindow(m_fReview) )
				{
					return false;
				}

#ifndef PHILIPS_VIEWER
				if(  m_INIfile.m_iEP4Installed>=STIMULATOR_EP4 && IsStimActive() )
#endif
				{
					return false;
				}

				m_vReview->ReviewPageUp(m_fReview->m_pSignalBar);
			}
			return true;

			case	VK_F1	:
			{
				AfxTrace(_T("P1 Key\n"));
				CMessage::Beep();
			}
			return true;

			case	VK_F2	:
			{
				AfxTrace(_T("P2\n"));
				CMessage::Beep();
			}
			return true;

			case	VK_F3	:
			{
				AfxTrace(_T("P3\n"));
				ShowStimTab(eP1);
			}
			return true;

			case	VK_F4	:
			{
				AfxTrace(_T("P4\n"));
				ShowStimTab(eP2);
			}
			return true;

			case	VK_F5	:
			{
				AfxTrace(_T("P5\n"));
				ShowStimTab(eP3);
			}
			return true;

			case	VK_F6	:
			{
				AfxTrace(_T("P6\n"));
				ShowStimTab(eP4);
			}
			return true;

			case	VK_F7	:
			{
				AfxTrace(_T("P7\n"));
				ShowStimTab(eP5);
			}
			return true;

			case	VK_F8	:
			{
				AfxTrace(_T("P8\n"));
				ShowStimTab(eP6);
			}
			return true;

			case	VK_F9	:
			{
				AfxTrace(_T("P9\n"));
				ShowStimTab(eP7);
			}
			return true;

			case	VK_F10	:
			{
				AfxTrace(_T("P10\n"));
				ShowStimTab(eP8);
			}
			return true;

			case	VK_F11	:
			{
				AfxTrace(_T("P11\n"));
				ShowStimTab(eP9);
			}
			return true;

			case	VK_PRINT	:
			{
				AfxTrace(_T("PBurst\n"));
				ShowStimTab(ePBurst);
			}
			return true;

			case _T('C')	:
			{
				const SHORT iControlState = ::GetKeyState(VK_CONTROL);

				if(iControlState<0)
				{
					AfxTrace(_T("CTRL+SHIFT+C\n"));

					TCHAR szFullPath[MAX_PATH]={0};
					MakePath(_T("INI.exe"), szFullPath, sizeof(szFullPath));

					STARTUPINFO				siInfo={0};
					PROCESS_INFORMATION	piInfo={0}; 
					BOOL bSuccess=::CreateProcess(NULL,				// Pointer to name of executable module
															(LPTSTR)(LPCTSTR)szFullPath,	//LPTSTR lpCommandLine,  // pointer to command line string
															NULL,					//LPSECURITY_ATTRIBUTES lpProcessAttributes,  // process security attributes
															NULL,					//LPSECURITY_ATTRIBUTES lpThreadAttributes,   // thread security attributes
															FALSE,				//BOOL bInheritHandles,  // handle inheritance flag
															DETACHED_PROCESS,	//DWORD dwCreationFlags, // creation flags
															NULL,					//LPVOID lpEnvironment,  // pointer to new environment block
															NULL,					//LPCTSTR lpCurrentDirectory,   // pointer to current directory name
															&siInfo,				//LPSTARTUPINFO lpStartupInfo,  // pointer to STARTUPINFO
															&piInfo);			//LPPROCESS_INFORMATION lpProcessInformation  // pointer to PROCESS_INFORMATION
   
					#ifdef _DEBUG
					DWORD dw = ::GetLastError();
					#endif

					DWORD dwRet = ::WaitForInputIdle(piInfo.hProcess, INFINITE);

					#ifdef _DEBUG
					dw = ::GetLastError();
					#endif

					return true;
				}
				else
				{
					AfxTrace(_T("SHIFT+C\n"));
				}
			}
			return false;

			case VK_TAB	:
			{
				if( IsDialogsInFocus() )
				{
					return false;
				}

				if(!m_dMonitor.m_bEnetInterrupts && !m_dMonitor.m_iDemoMode)
				{
					CMessage::PopupMessage(WMFILELINE, 865, 3000);
					return false;
				}

				// save past
				m_vReview->SaveAndDrawOneScreen(ACQUIRE_MODE_CONTINUOUS_PAST);

				m_MainBar.PastRecordKeyPressedMessage();

				return true;
			}
			return false;
		}

		return false;
	}

	AfxTrace(_T("key %d\n"), iVirtKey);

	if(iControlState<0 && iVirtKey!=VK_CONTROL)	//	CONTROL based.
	{
		AfxTrace(_T("CONTROL + Key %d\n"), iVirtKey);

		switch(iVirtKey)
		{
			case	_T('A')	:
			{
#ifndef PHILIPS_VIEWER
				if( CWMLibrary::IsSafeWindow(m_MainBar) && (IsActiveMode()))
				{
					m_MainBar.ToggleAutoRec();
				}
#endif
			}
			return true;

			case 	_T('B'):
			{
				if( CWMLibrary::IsSafeWindow(m_fRF) )
				{
					if(m_fRF->IsWindowVisible())
					{
						if( CWMLibrary::IsSafeWindow(m_vRF) )
						{
							m_vRF->OnSessionLeft();
							return true;
						}
					}
				}

				if( CWMLibrary::IsSafeWindow(m_vLog) )
				{
					m_vLog->PrevViewLogPage();
				}
			}
			return true;

			case _T('C')	:
			{
				if( CWMLibrary::IsSafeWindow(m_MainBar) )
				{
					m_MainBar.OnHorCaliperButton();
				}

				AfxTrace(_T("C\n"));
			}
			return true;

			case _T('D')	:
			{
				if (CWMLibrary::IsSafeWindow(this->m_vDB) && this->m_vDB->IsWindowVisible()) {
					CPreStudyTabDialog* pTabDialog =
						dynamic_cast<CPreStudyTabDialog*>(
							this->m_vDB->SetActiveChild(ViewModelKeyPreStudy)
						);

					if (pTabDialog != NULL) {
						CString csDate;

						CDateDialog	dlg(this->m_fMain, GETMESSAGE(601), csDate, 0);
						if (dlg.DoModal() == IDOK) {
							pTabDialog->m_csStudyDate = csDate;
							pTabDialog->m_edtStudyDateCtl.SetText(csDate);
						}

						return true;
					}
				}
				else {
#ifndef PHILIPS_VIEWER
					if( CWMLibrary::IsSafeWindow(m_MainBar) && (IsActiveMode()))	
					{	
						m_MainBar.OnDrugButton();	
						return true;
					}
					return false;
#endif					
				}
			}
			return false;

			case _T('E')	:
			{
                if (!PrepPrint()) return true;
				Print12lead25();	
			}
			return true;

			case _T('F')	:
			{
				if(m_dMonitor.m_iDemoMode==DEMO_MODE_CONT)
				{
					if(m_INIfile.m_iDBAccessMode != DISABLE_PASSWORDS)
					{
						if(m_sLogin.uiPrivilege & USER_PRIVILEGE_VIEW)
						{
							return false;
						}
					}

					if(IsActiveMode())
					{
						m_dRF.StartDemoMode();
					}
				} 
				else 
				{
                    if (!PrepPrint()) return true;
					Print12lead50();	
				}
			}
			return true;

			case _T('G')	:
			{
                if (!PrepPrint()) return true;
				Print12leadReview();	
			}
			return true;

			case _T('H')	:
			{
				DemoMode();
			}
			return true;

			case	_T('I')	:
			/*Razor 2468
			{
				m_bAskPath = false;
				AfxBeginThread(CMainBar::CreateBMPFile, &m_bAskPath);
			}
			return true;*/
			return false;

			case 	_T('J'):
			{
				if(m_vReview)
				{
					m_vReview->PrevViewLogEvent();
				}
			}
			return true;

			case 	_T('K'):
			{
				if(m_vReview)
				{
					m_vReview->NextViewLogEvent();
				}
			}
			return true;

			case	_T('L')	:
			{
				if(!IsTrigSweepLevelActive())
				{
					BeginTriggeredSweepLevel();
				}
				else
				{
					EndTriggeredSweepLevel();
				}
			}
			return true;

			case 	_T('M'):
			{
				if(m_vLog)
				{
					m_vLog->LastViewLogPage();
				}
			}
			return true;

			case 	_T('N'):
			{
				if( CWMLibrary::IsSafeWindow(m_fRF) )
				{
					if(m_fRF->IsWindowVisible())
					{
						if( CWMLibrary::IsSafeWindow(m_vRF) )
						{
							m_vRF->OnSessionRight();
							return true;
						}
					}
				}

				ViewNextLogEvent();
			}
			return true;

			case _T('O')	:
			{
				m_bAskPath = false;	
				AfxBeginThread(CMainBar::CreateJPEGFile, &m_bAskPath);
			}
			return true;

			case _T('P')	:
			{
				DisplayCine();
			}
			return true;

			case _T('Q')	:
			{
				if(!m_dMonitor.m_bEnetInterrupts && !m_dMonitor.m_iDemoMode)
				{
					CMessage::PopupMessage(WMFILELINE, 865, 3000);
					return false;
				}

				if(IsActiveMode())
				{
					m_vReview->SaveAndDrawOneScreen(ACQUIRE_MODE_ONE_SCREEN_AND_STOP);
				}
			}
			return true;

			case 	_T('R'):
			{
				if(!m_dMonitor.m_bEnetInterrupts && !m_dMonitor.m_iDemoMode)
				{
					CMessage::PopupMessage(WMFILELINE, 865, 3000);
					return false;
				}

				if(IsActiveMode())
				{
					m_vReview->SaveAndDrawOneScreen(ACQUIRE_MODE_CONTINUOUS_PAST);

					m_MainBar.PastRecordKeyPressedMessage();
				}
			}
			return true;

			case	_T('S')	:
			{
				m_MainBar.PrintReviewReport();
			}
			return true;

			case	_T('T')	:
			{
				if (!IsTrigSweepStimActive())
				{
					BeginTriggeredSweepStim();
				}
				else
				{
					EndTriggeredSweepStim();
				}
			}
			return true;

			case _T('U')	:
			{
				// in case they way to print next
				if( CWMLibrary::IsSafeWindow(m_fReview) && CWMLibrary::IsSafeWindow(m_fReview->m_pSignalBar) )	
				{	
					m_fReview->m_pSignalBar->OnPageEndClick();
				}	
			}
			return true;

			case 	_T('V'):
			{
				m_vLog->FirstViewLogPage();
			}
			return true;

			case	_T('W')	:
			{
				ChangeReviewSpeed();
			}
			return true;

			case _T('X')	:
			{
				if( CWMLibrary::IsSafeWindow(m_vReview) )
				{
					m_vReview->ReviewSpeedChange(false);
				}
			}
			return true;

			case _T('Y')	:
			{
				if( CWMLibrary::IsSafeWindow(m_MainBar) )
				{
					m_MainBar.OnLineCaliperButton();
				}
			}
			return true;

			case _T('Z')	:
			{
				if( CWMLibrary::IsSafeWindow(m_vReview) )
				{
					m_vReview->ReviewSpeedChange(true);
				}
			}
			return true;

			case _T('1')	:
			{
	#ifdef _DEBUG
				CWMLibrary::HandleClicks(m_fMapping, eMapping);	
	#else
				//m_dMapping->ExportMapPoints();
	#endif
			}
			return true;

			case _T('2')	:
			{
				if (!theApp.m_thePrintService.IsValidPrinter())
				{
					CMessage::PopupMessage(WMFILELINE, 195);
					m_ePrintWindow = eNoChoice;
					m_sScreens.m_eLeft=eNoWindow;	
					m_sScreens.m_eRight=eNoWindow;
					m_bPrintFromList=false;
					return true;
				}

				if( m_cgPage.IsPrinting() )	
				{	
					if(m_fPrint)	// If it is in Print Pre-View Mode Bring the PrintPreView Window to the Top.
					{
						m_fPrint->ShowWindow(SW_SHOW);
						m_fPrint->BringWindowToTop();
					} 
					else 							// If it is in Printing Mode displat the message.
					{
						CMessage::PopupMessage(WMFILELINE, 96); 
					}
					return true;	
				}

				PrintReviewFit();
			}
			return true;

			case _T('3')	:
			{
#ifndef PHILIPS_VIEWER
				if(CWMLibrary::IsSafeWindow(m_pTrace))
				{
					if(m_pTrace->IsWindowVisible())
					{
						m_pTrace->ShowWindow(SW_HIDE);
					}
					else
					{
						m_pTrace->ShowWindow(SW_SHOW);	

						#ifdef _DEBUG
						//m_dMapping->ExportMapPoints();
						#endif
					}
				}
#endif
			}
			return true;

			case 	_T('6'):
			{
				m_dMonitor.SaveDemoEcg();
			}
			return true;

			case _T('7'):
			{
				AfxTrace(_T("CTRL+7\n"));
				
				//return ToggleRemoteMouse();
			}
			return false;

			case _T('8') :
			{
			}
			return false;

			case _T('9') :
			{
#ifndef PHILIPS_VIEWER

				// Prevent user from logout while Printservice is still processing.
				if (theApp.m_thePrintService.IsPrinting() || theApp.m_cgPage.IsPrinting() || theApp.m_cgPage.printStarted)
				{
					CString csMesg; csMesg.Format(_T("%s\n%s"), GETMESSAGE(1800), GETMESSAGE(1801));
					CMessage::PopupMessage(WMFILELINE, csMesg);
					return false;

				}

				if(m_INIfile.m_iDBAccessMode != DISABLE_PASSWORDS)
				{
					Logout();
						
					return true;
				}
#endif
			}
			return false;

			case VK_NUMPAD2	:
			{
				m_dCathMap.RealtimePageDown();
			}
			return true;

			case VK_NUMPAD3	:
			{
				m_dCathMap.RealtimeAmpUp();
			}
			return true;

			case VK_NUMPAD4	:
			{
				m_dCathMap.RealtimeSpeedChange(false);
			}
			return true;

			case VK_NUMPAD6	:
			{
				m_dCathMap.RealtimeSpeedChange(true);
			}
			return true;

			case VK_NUMPAD7	:
			{
				AfxTrace(_T("Save Cine 1"));
				if( CWMLibrary::IsSafeWindow(m_vCine) && m_dCine.m_bInstalled)	
				{	
					m_vCine->OnButtonSave1();	
					return true;
				}
			}
			return false;

			case VK_NUMPAD1	:
			{
				AfxTrace(_T("Save Cine 2"));
				if( CWMLibrary::IsSafeWindow(m_vCine)  && m_dCine.m_bInstalled)	
				{	
					m_vCine->OnButtonSave2();	
					return true;
				}
			}
			return false;

			case VK_NUMPAD9	:
			{
				m_dCathMap.RealtimeAmpDown();
			}
			return true;

			case VK_PRIOR	:
			{
				const bool bPgUp = (lKeyData&0x1000000) ? true : false;

				if(bPgUp)
				{
					return false;
				}
				else	// NumPad Up Without Numpad Light.
				{
					m_dCathMap.RealtimeAmpDown();
				}
			}
			return true;

			case VK_NEXT	:
			{
				const bool bPgDown = (lKeyData&0x1000000) ? true : false;

				if(bPgDown)
				{
					return false;
				}
				else	// NumPad Up Without Numpad Light.
				{
					m_dCathMap.RealtimeAmpUp();		
				}
			}
			return true;

			case 	VK_LEFT :
			{
				const bool bLeft = (lKeyData&0x1000000) ? true : false;	
		
				if(bLeft)
				{
					if( IsDialogsActive() )
					{
						return false;
					}

					if( !CWMLibrary::IsSafeWindow(m_vReview) || !CWMLibrary::IsSafeWindow(m_fReview) )
					{
						return false;
					}
			
					m_vReview->LogLeft(m_fReview->m_pSignalBar );
				}
				else
				{
					m_dCathMap.RealtimeSpeedChange(false);
				}
			}
			return true;

			case 	VK_DOWN :
			{
				const bool bDown = (lKeyData&0x1000000) ? true : false;	 
				if(bDown)
				{
					if( IsDialogsActive() )
					{
						return false;
					}

					m_vReview->ReviewPageDown(m_fReview->m_pSignalBar);
				}
				else	// NumPad Up Without Numpad Light.
				{
					m_dCathMap.RealtimePageDown();
				}
			}
			return true;

			case 	VK_UP:
			{
				const bool bUp = (lKeyData&0x1000000) ? true : false;	
				if(bUp)
				{
					if( IsDialogsActive() )
					{
						return false;
					}

					m_vReview->ReviewPageUp(m_fReview->m_pSignalBar);
				}
				else	// NumPad Up Without Numpad Light.
				{
					m_dCathMap.RealtimePageUp();
				}
			}
			return true;

			case 	VK_RIGHT:
			{
				const bool bRight = (lKeyData&0x1000000) ? true : false;	
				if(bRight)
				{
					if( IsDialogsActive() )
					{
						return false;
					}

					if( !CWMLibrary::IsSafeWindow(m_vReview) || !CWMLibrary::IsSafeWindow(m_fReview) )
					{
						return false;
					}

					m_vReview->LogRight(m_fReview->m_pSignalBar);
				}
				else	// NumPad Up Without Numpad Light.
				{
					m_dCathMap.RealtimeSpeedChange(true);				
				}
			}
			return true;

			case 	VK_NUMPAD8:
			{
				m_dCathMap.RealtimePageUp();
			}
			return true;

#ifndef PHILIPS_VIEWER
			case	VK_F1	:
			{
				m_MainBar.EventHotKeys(1);
			}
			return true;

			case	VK_F2	:
			{
				m_MainBar.EventHotKeys(2);
			}
			return true;

			case	VK_F3	:
			{
				m_MainBar.EventHotKeys(3);
			}
			return true;

			case	VK_F4	:
			{
				m_MainBar.EventHotKeys(4);
			}
			return true;

			case	VK_F5	:
			{
				m_MainBar.EventHotKeys(5);
			}
			return true;

			case	VK_F6	:
			{
				m_MainBar.EventHotKeys(6);
			}
			return true;

			case	VK_F7	:
			{
				m_MainBar.EventHotKeys(7);
			}
			return true;

			case	VK_F8	:
			{
				m_MainBar.EventHotKeys(8);
			}
			return true;

			case	VK_F9	:
			{
				m_MainBar.EventHotKeys(9);
			}
			return true;

			case	VK_F10	:
			{
				m_MainBar.EventHotKeys(10);
			}
			return true;

			case	VK_F11	:
			{
				m_MainBar.EventHotKeys(11);
			}
			return true;

			case	VK_F12	:
			{
				m_MainBar.EventHotKeys(12);
			}
			return true;
#endif
		}

		return false;
	}

	if((iVirtKey==VK_CONTROL) || (iVirtKey==VK_SHIFT))
	{
		return false;
	}

	switch(iVirtKey)	//	F KEYS and Normal Keys.
	{
		case _T(';')	:
		case 186	:		
		case	219:
		{
			
		}
		return false;

		case	220	:
		{
			return AddMappingNotes();
		}
		return false;

		case  192	:
		{
			if(CWMLibrary::IsSafeWindow(m_fReview) && 
				CWMLibrary::IsSafeWindow(m_vFreqReview))
			{
				if(!m_vFreqReview->IsWindowVisible())
				{
					m_fReview->Toggle(true);

					m_dFreqReview.GetCurrentFreqPage(m_dFreqReview.m_iFreqWindowType, 
																m_dFreqReview.m_iSamples);
				
					m_fReview->ShowWindow(SW_SHOW);
					m_fReview->BringWindowToTop();				
				}
				else
				{
					m_fReview->Toggle(false);
				}

				return true;
			}
		}
		return false;

		case	221	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			//return ToggleRemoteMouse();
		}
		return false;

		case	_T('A')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnMAPButton();
			}
		}
		return true;

		case	_T('B')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnDBButton();
			}
		}
		return true;

		case	_T('C')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

#ifndef PHILIPS_VIEWER
			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnProtocolButton();

				return true;
			}
#endif
		}
		return false;

		case	_T('D')	:
		{
			if(IsDialogsInFocus() || 
				(IsPassiveMode()))
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnAutoRecButton();
			}
		}
		return true;

		case	_T('E')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnEventsButton();
			}
		}
		return true;

		case	_T('F')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnRFButton();
			}
		}
		return true;

		case	_T('G')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnTriggerSweepStimButton();
			}
		}
		return true;

		case	_T('H')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnHolterButton();
			}
		}
		return true;

		case	_T('I')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnSplitButton();
			}
		}
		return true;

		case	_T('L')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnLogButton();
			}
		}
		return true;

		case	_T('M')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				if (m_eStudyMode == eOpenPreviousStudy)
				{
					CMessage::Beep(1000, 40);
					return false;
				}
				else
				{
					m_MainBar.MarkEventHotKey();
				}
			}
		}
		return true;

		case	_T('N')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )	
			{	
				static INT64 iLast = -1;

				DWORD dwDiff = (DWORD)(GetFastTimeMS()-iLast);

				if((iLast==-1) || 
					(dwDiff>=250) )
				{
					m_MainBar.OnCineButton();	
				}
				else
				{
					CMessage::Beep(1000,10);
				}

				iLast = GetFastTimeMS();
			}
		}
		return true;

		case	_T('O')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

#ifndef PHILIPS_VIEWER
			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnNotesButton();
			}
#endif
		}
		return true;

		case	_T('P')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnPrintButton();
			}
		}
		return true;

		case	_T('R')	:
		{
			if(IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnMonitorButton();
			}
		}
		return true;

		case	_T('S')	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnStimButton();
			}
		}
		return true;

		case	_T('T')	:
		{
			if( IsDialogsInFocus() || 
				(IsPassiveMode()))
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnStartRecButton();
			}
		}
		return true;

		case	_T('U')	:
		{
			if(IsDialogCreated()		|| 
				m_bCathMapScrnActive || 
				m_bPKeyEditDlgActive || 
				IsMapJBoxActive()		)
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )	// This only Creates the CathmapScreen
			{
				m_MainBar.OnCathMapButton();
			}
		}
		return true;

		case	_T('V')	:
		{
			if( IsDialogsActive() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnIntervalCheck();
			}
		}
		return true;

		case	_T('W')	:
		{
			//if( IsDialogsActive() )	{	return false;	}

			if( IsDialogsInFocus() )
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnTriggerShowButton();
			}
		}
		return true;

		case	_T('X')	:
		{
			//if( IsDialogsActive() )	{	return false;	}
 			if( IsDialogCreated() || m_bPKeyEditDlgActive || IsMapJBoxActive())
			{
				return false;
			}

			if( CWMLibrary::IsSafeWindow(m_MainBar) )
			{
				m_MainBar.OnExitButton();
			}
		}
		return true;

		case	_T('Z')	:
		{
			//if( IsDialogsActive() )	{	return false;	}

			if( IsDialogsInFocus() ) {	return false;	}

			if( CWMLibrary::IsSafeWindow(m_vATMMap) )	
			{
				switch(m_INIfile.m_usMappingSystemInstalled)
				{
					case MAPPING_SYSTEM_NONE:
					case MAPPING_SYSTEM_ENSITE:
					default:
					{
						m_vATMMap->AddMapPoint();	
					}
					break;

					case MAPPING_SYSTEM_CARTO:
					{
						if(!m_dMapping->m_bMapMate)
						{
							m_vATMMap->AddMapPoint();	
						}
						else
						{
							CMessage::Beep();
						}
					}
					break;
				}
			}
		}
		return true;

		case VK_INSERT:
		{
			if( IsDialogsActive() )	{	return false;	}

			if((lKeyData&0x1000000))  // no number pads
			{
				if (!theApp.m_thePrintService.IsValidPrinter())
				{
					CMessage::PopupMessage(WMFILELINE, 195);
					m_ePrintWindow = eNoChoice;
					m_sScreens.m_eLeft=eNoWindow;	
					m_sScreens.m_eRight=eNoWindow;
					m_bPrintFromList=false;
					return true;
				}

				if( m_cgPage.IsPrinting() )	
				{	
					if(m_fPrint)	// If it is in Print Pre-View Mode Bring the PrintPreView Window to the Top.
					{
						m_fPrint->ShowWindow(SW_SHOW);
						m_fPrint->BringWindowToTop();
					}
					else	// If it is in Printing Mode displat the message.
					{
						CMessage::PopupMessage(WMFILELINE, 96); 
					}

					return true;	
				}

				bool bReviewHalf		= CWMLibrary::IsHalfWnd(m_fReview);
				bool bPrevReviewHalf = m_fPrevReview->IsWindowVisible() && CWMLibrary::IsHalfWnd(m_fPrevReview);
	
				if(bReviewHalf && bPrevReviewHalf)	// Review & PrevReview are split
				{
					m_bPrintFromList=false;
					m_sScreens.m_eLeft	=	ePrevReview;	
					m_sScreens.m_eRight	=	eReview;	

                    CString	cs;
                    cs.Format(_T("%s - %s"), GETMESSAGE(734), GETMESSAGE(723));
                    m_thePrintService.SetPrintTitle(cs);

					m_iPrintingReview=	PR_REVIEW;
					m_ePrintWindow	=	ePrintReview;
				}
				else
				{
					m_bPrintFromList			=	true;
					m_thePrintService.SetPrintTitle(723);
				}

				m_cgPage.SetSplit();

				if(IsArgument(_T("PRINT_PREVIEW")))
				{
					m_MainBar.OnFilePrintPreview(ePrintReview);
				}
				else										
				{
					m_MainBar.m_bBoth	= ( m_MainBar.m_bPrintToPrinter && m_MainBar.m_bPrintToFile );
					m_MainBar.m_bToFile = ( m_MainBar.m_bPrintToFile );

					m_MainBar.OnFilePrint(ePrintReview);
				}

				return true;
			}
		}
		break;
		
		case VK_HOME:
		{
			if(IsDialogCreated() || m_bPKeyEditDlgActive)
			{
				return false;
			}

			if(lKeyData&0x1000000) 
			{
				if(!m_dMonitor.m_bEnetInterrupts && !m_dMonitor.m_iDemoMode)
				{
					CMessage::PopupMessage(WMFILELINE, 865, 3000);
					return false;
				}

				m_vReview->SaveAndDrawOneScreen(ACQUIRE_MODE_12LEAD_STOP);
				return true;
			}
		}
		break;
		
		case	VK_F1	:
		{
			AfxTrace(_T("F1 Key\n"));
			ShowStimTab(eSetup);
		}
		return true;

		case	VK_F2	:
		{
			AfxTrace(_T("F2\n"));
#ifndef PHILIPS_VIEWER
			m_Stim.Save();
#endif
		}
		return true;

		case	VK_F3	:
		{
			AfxTrace(_T("F3\n"));
			ShowStimTab(eF1);
		}
		return true;

		case	VK_F4	:
		{
			AfxTrace(_T("F4\n"));
			ShowStimTab(eF2);
		}
		return true;

		case	VK_F5	:
		{
			AfxTrace(_T("F5\n"));
			ShowStimTab(eF3);
		}
		return true;

		case	VK_F6	:
		{
			AfxTrace(_T("F6\n"));
			ShowStimTab(eF4);
		}
		return true;

		case	VK_F7	:
		{
			AfxTrace(_T("F7\n"));
			ShowStimTab(eF5);
		}
		return true;

		case	VK_F8	:
		{
			AfxTrace(_T("F8\n"));
			ShowStimTab(eF6);
		}
		return true;

		case	VK_F9	:
		{
			AfxTrace(_T("F9\n"));
			ShowStimTab(eF7);
		}
		return true;

		case	VK_F10	:
		{
			AfxTrace(_T("F10\n"));
			ShowStimTab(eF8);
		}
		return true;

		case	VK_F11	:
		{
			AfxTrace(_T("F11\n"));
			ShowStimTab(eF9);
		}
		return true;

		case	VK_F12	:
		{
			CMessage::Beep();

			if(!m_dMonitor.m_bEnetInterrupts && !m_dMonitor.m_iDemoMode)
			{
				CMessage::PopupMessage(WMFILELINE, 865, 3000);
				return false;
			}
			m_vReview->SaveAndDrawOneScreen(ACQUIRE_MODE_ONE_SCREEN_AND_STOP);
		}
		return true;

		case VK_SCROLL	:
//		case VK_PAUSE	:	
		{
			AfxTrace(_T("Burst\n"));
			ShowStimTab(eBurst);
			
		}
		return true;

	#ifdef IN_DEBATE
		case VK_NUMPAD7	:
		{
			AfxTrace(_T("VK_NUMPAD7\n"));
			if( CWMLibrary::IsSafeWindow(m_fMain) )	
			{	
				POINT ptCurPos={0};	::GetCursorPos(&ptCurPos);
				const short iChannelN=m_fRealTime->m_mtMonitor.m_vMonitor.GetChannelNumber(ptCurPos);
				if(iChannelN!=-1)
				{
					m_dCathMap.RealTimeChannelAmpUp(iChannelN);
				}
			}
		}
		return true;

		case VK_NUMPAD1	:
		{
			AfxTrace(_T("VK_NUMPAD1\n"));
			if( CWMLibrary::IsSafeWindow(m_fMain) )	
			{	
				POINT ptCurPos={0};	::GetCursorPos(&ptCurPos);
				const short iChannelN=m_fRealTime->m_mtMonitor.m_vMonitor.GetChannelNumber(ptCurPos);
				if(iChannelN>-1 && iChannelN<MAX_SCREEN_CHANNELS)
				{
					m_dCathMap.RealTimeChannelAmpDown(iChannelN);
				}
			}
		}
		return true;
	#endif
		/*case 	VK_UP:		// ????
		{
			//m_dCathMap.RealtimePageDown();
			//m_vReview->ReviewPageUp();
			const SHORT iState = ::GetKeyState(VK_CONTROL);
			if(iState<0 && iVirtKey!=VK_CONTROL)	{

				AfxTrace("Ctrl Up Num Arrow\n");

				//if(m_iCurrentTab!=eMenu && m_iCurrentTab!=eSetup)	{	m_EP3.SendKeyPress(WYSE50_ShUP);	}

			}	else	{

				bool bUp = (lKeyData&0x1000000) ? true : false;	
				AfxTrace("Up Arrow\n");

				if(bUp)	{
					//if(m_iCurrentTab!=eMenu && m_iCurrentTab!=eSetup)	{	m_EP3.SendKeyPress(WYSE50_UP);	}
				}	else	{
					AfxTrace("Send 8\n");
					//if(m_iCurrentTab!=eMenu && m_iCurrentTab!=eSetup)	{	m_EP3.SendKeyPress('8');	}
				}
			}

		}
		return true;*/

		case VK_SUBTRACT :
		{
		}
		return false;

		case VK_TAB	:
		{
			if( IsDialogsInFocus() )
			{
				return false;
			}

			if(!m_dMonitor.m_bEnetInterrupts && !m_dMonitor.m_iDemoMode)
			{
				CMessage::PopupMessage(WMFILELINE, 865, 3000);
				return false;
			}

			// save past
			m_vReview->SaveAndDrawOneScreen(ACQUIRE_MODE_CONTINUOUS_PAST);

			m_MainBar.PastRecordKeyPressedMessage();

			return true;
		}
		return false;
	}
	
	return false;
}

bool CWMApp::PrepPrint()
{
    bool retVal = true;
	if (!theApp.m_thePrintService.IsValidPrinter())
	{
		CMessage::PopupMessage(WMFILELINE, 195);
		m_ePrintWindow = eNoChoice;
		m_sScreens.m_eLeft=eNoWindow;	
		m_sScreens.m_eRight=eNoWindow;
		m_bPrintFromList=false;
		retVal = false;
	}

	if( m_cgPage.IsPrinting() )	
	{	
		if(m_fPrint)	// If it is in Print Pre-View Mode Bring the PrintPreView Window to the Top.
		{
			m_fPrint->ShowWindow(SW_SHOW);
			m_fPrint->BringWindowToTop();
		} 
		else 
		{							// If it is in Printing Mode displat the message.
			CMessage::PopupMessage(WMFILELINE, 96); 
		}
		retVal = false;
	}
    return retVal;
}


void CWMApp::HorizontalSplit(const eWMWindow eTop, const eWMWindow eBottom)
{
	m_fReview->ShowWindow(SW_HIDE);
	m_fPrevReview->ShowWindow(SW_HIDE); 
	m_fHolter->ShowWindow(SW_HIDE);
	m_fRF->ShowWindow(SW_HIDE);
	m_fCine->ShowWindow(SW_HIDE);
	m_fLog->ShowWindow(SW_HIDE);
	m_fChart->ShowWindow(SW_HIDE);
	m_fMonitor->ShowWindow(SW_HIDE);
	m_fMapping->ShowWindow(SW_HIDE);
	m_fMeasurement->ShowWindow(SW_HIDE);

	CRect crMainBar(m_MainBar.m_crArea);

	CRect crStim(0,0,0,0);	

#ifndef PHILIPS_VIEWER
	if(IsStimActive())	
	{	
		m_Stim.GetClientRect(crStim);	
	}
#endif

	const int iWidth = CWMLibrary::GetDesktopWidth();
	int iHeight= ::GetSystemMetrics(SM_CYSCREEN);
	iHeight-=crMainBar.Height();
	iHeight-=crStim.Height();

	CRect crScreen(0, 0,0,0);
	crScreen.left	= crMainBar.left + (m_INIfile.m_bMouseRight?m_iTotalScreenWidth:0);
	crScreen.top	= crMainBar.bottom;
	crScreen.right	= crScreen.left+iWidth;
	crScreen.bottom= crScreen.top+iHeight;

#ifndef PHILIPS_VIEWER
	if(IsStimActive())	
	{	
		iHeight=(int)((float)crScreen.Height()*0.66f);
	}
	else
	{
		iHeight=(int)((float)crScreen.Height()*0.71f);
	}
#else
	iHeight=(int)((float)crScreen.Height()*0.71f);
#endif

	CRect crTop(crScreen.left, crScreen.top, crScreen.right, crScreen.top+iHeight);
	CRect crBottom(crScreen.left, crTop.bottom, crScreen.right, crScreen.bottom); 

	m_MainBar.PositionWindow(eTop, crTop);
	m_MainBar.PositionWindow(eBottom, crBottom);

	m_MainBar.SetButtonColor();
}

bool CWMApp::IsMapJBoxActive(void)	const
{
	if(m_fMapping)
	{
		return m_fMapping->IsMapJBoxActive();
	}

	return false;
}

bool CWMApp::IsDialogsActive(void)	const
{
	return ( IsDialogCreated()		|| 
				m_bDBScrnActive		|| 
				m_bCathMapScrnActive || 
				m_bPKeyEditDlgActive || 
				IsMapJBoxActive() );
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::IsDialogsInFocus()

	Description	:	This function checks the for active modal dialog boxes, 
						database screen, cathmap screen, PKey edit dialog box,
						map junction box and the config screen and returns the
						flag.

	Returns		:	boolean (true or false).

	Setup			:	1. Open the Start Record dialog box.

	Testing		:	1. Press the 'B' keystroke and verify the database screen
						does not open.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
bool CWMApp::IsDialogsInFocus(void)	const
{
	bool bFocus = (IsDialogCreated()				|| 
						m_vDB->IsInFocus()			|| 
#ifndef PHILIPS_VIEWER
						m_vCathMap->IsInFocus()		|| 
#endif
						m_vMeasurement->IsInFocus()|| 
						m_bPKeyEditDlgActive			|| 
						IsMapJBoxActive() );

#ifndef PHILIPS_VIEWER
	if(m_bConfigScrnActive && m_vCathMap->m_pConfigScreen)
	{
		bFocus = bFocus || (m_vCathMap->m_pConfigScreen->IsInFocus());
	}
#endif

	return bFocus;
}

void CWMApp::UnLockOldCal(const SCaliperDescription& rCalDesp, const CPoint& ptPoint, eWMWindow eWnd, short iUnLock)
{
   if(rCalDesp.type==eHor) 
	{
		TerminateAllCalipers(true);
	
		m_vReview->m_cprHorz.Reset(true);
		m_vPrevReview->m_cprHorz.Reset(true);
		m_vHolter->m_cprHorz.Reset(true);
		m_vATMMap->m_cprHorz.Reset(true);

		m_vReview->m_cprHorz.InitializeUnLock(	m_vReview, 
															m_vReview->m_crClient, 
															rCalDesp, 
															eWnd==eReview, 
															iUnLock);
		
		m_vPrevReview->m_cprHorz.InitializeUnLock(m_vPrevReview, 
																m_vPrevReview->m_crClient, 
																rCalDesp, 
																eWnd==ePrevReview, 
																iUnLock);
		
		m_vHolter->m_cprHorz.InitializeUnLock(	m_vHolter, 
															m_vHolter->m_crClient, 
															rCalDesp, 
															eWnd==eHolter, 
															iUnLock);
		
		m_fMonitor->m_vMonitor.m_cprHor.InitializeUnLock(&m_fMonitor->m_vMonitor, 
																		 m_fMonitor->m_vMonitor.m_crClient, 
																		 rCalDesp, 
																		 eWnd==eMonitor, 
																		 iUnLock);
		
		m_vATMMap->m_cprHorz.InitializeUnLock( m_vATMMap, 
															m_vATMMap->m_crClient, 
															rCalDesp, 
															eWnd==eHolter, 
															iUnLock);
		m_MainBar.SetCaliperButton(eHor, true);
   }
}

void CWMApp::InitOldCal(const SCaliperDescription& rCalDesp, const CPoint& ptPoint, eWMWindow eWnd)
{
   switch (rCalDesp.type) 
	{
		case	eHor	:
		{
			TerminateAllCalipers(true);
		
			m_vReview->m_cprHorz.Reset(true);
			m_vPrevReview->m_cprHorz.Reset(true);
			m_vHolter->m_cprHorz.Reset(true);
			m_vATMMap->m_cprHorz.Reset(true);

			m_vReview->m_cprHorz.Initialize(	m_vReview, 
														m_vReview->m_crClient, 
														rCalDesp, 
														eWnd==eReview, 
														true);

			m_vPrevReview->m_cprHorz.Initialize(m_vPrevReview, 
															m_vPrevReview->m_crClient, 
															rCalDesp, 
															eWnd==ePrevReview, 
															true);

			m_vHolter->m_cprHorz.Initialize(m_vHolter, 
													  m_vHolter->m_crClient, 
													  rCalDesp, 
													  eWnd==eHolter, 
													  true);

			m_fMonitor->m_vMonitor.m_cprHor.Initialize(&m_fMonitor->m_vMonitor, 
																	 m_fMonitor->m_vMonitor.m_crClient, 
																	 rCalDesp, 
																	 eWnd==eMonitor, 
																	 true);

			m_vATMMap->m_cprHorz.Initialize(	m_vATMMap, 
														m_vATMMap->m_crClient, 
														rCalDesp, 
														eWnd==eHolter, 
														true);
			m_MainBar.SetCaliperButton(eHor, true);
		}
		break;

		case ePoint:
		{
			TerminateAllCalipers(false);

			m_vReview->m_cprPoint.Reset();
			m_vPrevReview->m_cprPoint.Reset();
			m_vHolter->m_cprPoint.Reset();
		
			m_vReview->m_cprPoint.Initialize(m_vReview, 
														m_vReview->m_crClient, 
														rCalDesp, 
														eWnd==eReview);
			
			m_vPrevReview->m_cprPoint.Initialize(m_vPrevReview, 
															 m_vPrevReview->m_crClient, 
															 rCalDesp, 
															 eWnd==ePrevReview);
			
			m_vHolter->m_cprPoint.Initialize(m_vHolter, 
														m_vHolter->m_crClient, 
														rCalDesp, 
														eWnd==eHolter);
			
			m_fMonitor->m_vMonitor.m_cprPoint.Initialize(&m_fMonitor->m_vMonitor, 
																		m_fMonitor->m_vMonitor.m_crClient, 
																		rCalDesp, 
																		eWnd==eMonitor);
			
			m_MainBar.SetCaliperButton(ePoint, true);
		}
		break;

		case eLine:
			InitializeCaliper(eLine, eWnd, true, true);
		break;

		case eFull:
		{
			TerminateAllCalipers(false);

			m_vReview->m_cprFullLine.Initialize(m_vReview, 
															m_vReview->m_crClient, 
															ptPoint, 
															eWnd==eReview);
			
			m_vPrevReview->m_cprFullLine.Initialize(m_vPrevReview, 
																 m_vPrevReview->m_crClient, 
																 ptPoint, 
																 eWnd==ePrevReview);
			
			m_vHolter->m_cprFullLine.Initialize(m_vHolter, 
															m_vHolter->m_crClient, 
															ptPoint, 
															eWnd==eHolter);

			m_MainBar.SetCaliperButton(eFull, true);
		}
		break;

		case eVer:
		{
			TerminateAllCalipers(true);
		
			m_vReview->m_cprVert.Reset(true);
			m_vPrevReview->m_cprVert.Reset(true);
			m_fMonitor->m_vMonitor.m_cprVer.Reset(true);

			m_vReview->m_cprVert.Initialize(m_vReview, 
													  m_vReview->m_crClient, 
													  rCalDesp, 
													  eWnd==eReview);
			m_vPrevReview->m_cprVert.Initialize(m_vPrevReview, 
															m_vPrevReview->m_crClient, 
															rCalDesp, 
															eWnd==ePrevReview);
			m_fMonitor->m_vMonitor.m_cprVer.Initialize(&m_fMonitor->m_vMonitor, 
																	 m_fMonitor->m_vMonitor.m_crClient, 
																	 rCalDesp, 
																	 eWnd==eMonitor);
			m_vATMMap->m_cprVert.Initialize(	m_vATMMap, 
														m_vATMMap->m_crClient, 
														rCalDesp, 
														eWnd==eReview);
			m_MainBar.SetCaliperButton(eVer, true);
		}
		break;
   }
}

void CWMApp::InitOldLineCal(const CPoint& ptPoint, const eWMWindow eWnd)
{
	TerminateAllCalipers(false);

	m_vReview->m_cprLine.Initialize(	m_vReview, 
												m_vReview->m_crClient, 
												ptPoint, 
												eWnd==eReview);
	m_vPrevReview->m_cprLine.Initialize(m_vPrevReview, 
													m_vPrevReview->m_crClient, 
													ptPoint, 
													eWnd==ePrevReview);
	m_vHolter->m_cprLine.Initialize(	m_vHolter, 
												m_vHolter->m_crClient, 
												ptPoint, 
												eWnd==eHolter);
	m_MainBar.SetCaliperButton(eLine, true);
}

void CWMApp::LastCalUsed(eWMWindow eWnd)
{
   switch (m_eLastCal) 
	{
		case ePoint	:	InitializeCaliper(ePoint, eWnd, false, true);break;
		case eVer	:	InitializeCaliper(eVer,	eWnd, false, true);	break;
		case eLine	:	InitializeCaliper(eLine, eWnd, false, true);	break;
		case eFull	:	InitializeCaliper(eFull, eWnd, false, true);	break;
		default		:	InitializeCaliper(eHor, eWnd, false, true);	break;
   }
}

void CWMApp::InitializeCaliper(eCaliper eCal, eWMWindow eWnd, bool bRefresh, bool bFromMouse)
{
	TerminateAllCalipers(bRefresh);

	switch(eCal)
	{
		case eHor	:
			m_vReview->m_cprHorz.Initialize(m_vReview, m_vReview->m_crClient, eReview==eWnd, bFromMouse);
			m_vPrevReview->m_cprHorz.Initialize(m_vPrevReview, m_vPrevReview->m_crClient, ePrevReview==eWnd, bFromMouse);
			m_vHolter->m_cprHorz.Initialize(m_vHolter, m_vHolter->m_crClient, eHolter==eWnd, bFromMouse);
			m_fMonitor->m_vMonitor.m_cprHor.Initialize(&m_fMonitor->m_vMonitor, m_fMonitor->m_vMonitor.m_crClient, eMonitor==eWnd, bFromMouse);
			m_vATMMap->m_cprHorz.Initialize(m_vATMMap, m_vATMMap->m_crClient, eMapping==eWnd, bFromMouse);
			m_MainBar.SetCaliperButton(eHor, true);
		break;

		case eVer	:
			m_vReview->m_cprVert.Initialize(m_vReview, m_vReview->m_crClient, eReview==eWnd);
			m_vPrevReview->m_cprVert.Initialize(m_vPrevReview, m_vPrevReview->m_crClient, ePrevReview==eWnd);
			m_fMonitor->m_vMonitor.m_cprVer.Initialize(&m_fMonitor->m_vMonitor, m_fMonitor->m_vMonitor.m_crClient, eMonitor==eWnd);
			m_vATMMap->m_cprVert.Initialize(m_vATMMap, m_vATMMap->m_crClient, eMapping==eWnd);
			m_MainBar.SetCaliperButton(eVer, true);
		break;

		case eFull	:
			m_vReview->m_cprFullLine.Initialize(m_vReview, 
															m_vReview->m_crClient, 
															eReview==eWnd);
			
			m_vPrevReview->m_cprFullLine.Initialize(	m_vPrevReview, 
																	m_vPrevReview->m_crClient, 
																	ePrevReview==eWnd);
			
			m_vHolter->m_cprFullLine.Initialize(m_vHolter, 
															m_vHolter->m_crClient, 
															eHolter==eWnd);

			m_MainBar.SetCaliperButton(eFull, true);
		break;

		case eLine	:
			m_vReview->m_cprLine.Initialize(	m_vReview, 
														m_vReview->m_crClient, 
														eReview==eWnd);
			m_vPrevReview->m_cprLine.Initialize(m_vPrevReview, 
															m_vPrevReview->m_crClient, 
															ePrevReview==eWnd);
			m_vHolter->m_cprLine.Initialize(	m_vHolter, 
														m_vHolter->m_crClient, 
														eHolter==eWnd);
			m_MainBar.SetCaliperButton(eLine, true);
		break;

		case ePoint	:
			m_vReview->m_cprPoint.Initialize(m_vReview, 
														m_vReview->m_crClient, 
														eReview==eWnd);
			m_vPrevReview->m_cprPoint.Initialize(m_vPrevReview, 
															 m_vPrevReview->m_crClient, 
															 ePrevReview==eWnd);
			m_vHolter->m_cprPoint.Initialize(m_vHolter, 
														m_vHolter->m_crClient, 
														eHolter==eWnd);
			m_fMonitor->m_vMonitor.m_cprPoint.Initialize(&m_fMonitor->m_vMonitor, 
																		m_fMonitor->m_vMonitor.m_crClient, 
																		eMonitor==eWnd);
			m_MainBar.SetCaliperButton(ePoint, true);
		break;
	}
}

void CWMApp::StartMasterTimers(void)
{
	m_MainBar.StartTimer();

#ifndef PHILIPS_VIEWER
	m_fRealTime->StartTimer();
#endif
}

void CWMApp::StopMasterTimers(void)
{
	m_MainBar.StopTimer();
	m_fRealTime->StopTimer();
}

void CWMApp::ResetReview(void)
{
	m_dReview.m_rppReview.screen_size			= m_dPrevReview.m_rppReview.screen_size				= 0;
	m_dReview.m_rppReview.file_length			= m_dPrevReview.m_rppReview.file_length				= 0;
	m_dReview.m_rppReview.file_number			= m_dPrevReview.m_rppReview.file_number				= 0;
	m_dReview.m_rppReview.file_position			= m_dPrevReview.m_rppReview.file_position			= 0;
	m_dReview.m_rppReview.iPageN				= m_dPrevReview.m_rppReview.iPageN					= 0;
	m_dReview.m_rppReview.signal_header.time_ms	= m_dPrevReview.m_rppReview.signal_header.time_ms	= 0;

    m_fReview->SetCaption(_T("   "));
    m_fReview->m_pSignalBar->m_scrBar.SetText(_T("00:00:00"));
    m_fReview->m_pSignalBar->SetPageIcons(m_dReview.m_rppReview.iPageN);
	
    m_fPrevReview->SetCaption(_T("   "));
    m_fPrevReview->m_pSignalBar->m_scrBar.SetText(_T("00:00:00"));
    m_fPrevReview->m_pSignalBar->SetPageIcons(m_dPrevReview.m_rppReview.iPageN);

	m_dLog.m_iOldLogEntriesN			= 0;
	m_dChart.m_iOldChartEntriesN		= 0;
	m_dReview.m_rppReview.cineN			= 0;

	m_dReview.m_rppReview.max_channelN	= m_dPrevReview.m_rppReview.max_channelN	= 0;
	m_dReview.m_rppReview.max_positionN = m_dPrevReview.m_rppReview.max_positionN	= 1; // used as a divisor

	m_dPrevReview.m_rppReview.Reset();
	m_dPrevReview.GetCurrentLogPage();
	m_vPrevReview->InvalidateView();
	DrawReviewScrollKnob(ePrevReview, m_dPrevReview.m_rppReview);

	m_dReview.m_rppReview.Reset();
	m_dReview.GetCurrentLogPage();
	m_vReview->InvalidateView();
	DrawReviewScrollKnob(eReview, m_dReview.m_rppReview);

	m_vFreqReview->InvalidateView();

	m_dLog.RemoveDBLog();
	m_dLog.CreateLogEntriesMenu(true); // because it was changed above
	m_vLog->DrawLogEntries(true);

	m_dChart.RemoveDBChart();
	m_dChart.CreateChartEntriesMenu(true); // because it was changed above
	m_vChart->DrawChartEntries(true);

	m_dHolter.GetCurrentHolterPage();
	m_vHolter->InvalidateView();

	m_vRF->DataToGUIExchange(true);
	m_vCine->PostMessage(WM_REDRAW_CINE,true,0);

	m_MainBar.SetDrugButton(false);
}

void CWMApp::StopChannelDrag(void)
{
	if(m_vReview)
	{
		m_vReview->StopChannelDrag();
	}
	
	if(m_vPrevReview)
	{
		m_vPrevReview->StopChannelDrag();
	}
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::BeginTriggeredSweepStim()

	Description	:	This function stops the dragging mode of all the channels,
						closes all the calipers, checks for the recording state and
						starts the Stim Triggered Sweep on the Review screen if 
						recording signals or the Monitor screen.

	Returns		:	None

	Setup			:	1. Acquire realtime signals on the Realtime screen through the 
							amplifier.
	TRIGGERED SWEEP:
						1. Left mouse click on the Show button on the mainbar. Verify the 
						show dialog box displays.
						2. Left mouse click on the 'All' list item. Verify the Show dialog
						box closes.

	Testing		:	
		Review Screen:	
						1. Open the Review screen and start recording the signals. Verify 
							the signals are displayed on the Review screen.
						2. Press the TrigStim button on the MainBar. Verify the Triggered 
							Stim procedure starts on the Review screen.
	TRIGGERED SWEEP:
						1. Verify the past updates are recorded as gray colored signals.

		Monitor Screen:
						1. Stop recording the signals by pressing the Record keystroke on 
							the keyboard. Verify the recording of the signals is stopped.
						2.	Press the TrigStim button on the MainBar. Verify the Triggered 
							Stim procedure starts on the Monitor screen.
	TRIGGERED SWEEP:
						1. Verify the past updates are recorded as gray colored signals.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::BeginTriggeredSweepStim(void)
{
	StopChannelDrag();

	EndTriggeredReviewMode(eReview);
	EndTriggeredReviewMode(ePrevReview);	

	m_dMonitor.m_usSaveAcquirePopFinished=SAVE_ACQUIRE_POP_NONE;
	//m_dMonitor.m_usDrawAcquirePop=SAVE_ACQUIRE_POP_NONE; this could be set before trig sweep is active

	m_MainBar.m_btnTriggerStimCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND_HIGHLIGHT);

   // RULES FOR TURNING ON TRIG STIM SWEEP
   // general rule - if not saving go to monitor window else review
   //
   // if NOT saving 
   //    if Monitor window is not already in monitor trig sweep use it
   //    else turn saving on and use the review window
   // else
   //    if review window is not already in trig sweep use it
   //    else move the level trig sweep to the monitor and use the review window
   if(!m_dLog.m_iSaveData)	
   {
      if(!m_iTriggeredSweepActive[TS_MONITOR] || 
			(m_iTriggeredSweepActive[TS_MONITOR]==TRIG_SWEEP_STIM))
      {
         m_iTriggeredSweepActive[TS_MONITOR]=TRIG_SWEEP_STIM;
      } 
      else 
      {
         m_dLog.m_iSaveData=true;
         m_iTriggeredSweepActive[TS_REVIEW]=TRIG_SWEEP_STIM;
      }
   } 
   else 
   {
      if(!m_iTriggeredSweepActive[TS_REVIEW] || m_iTriggeredSweepActive[TS_REVIEW]==TRIG_SWEEP_STIM)
      {
         m_iTriggeredSweepActive[TS_REVIEW]=TRIG_SWEEP_STIM;
      } 
      else 
      { // it is implied that level is in review now
         EndTriggeredSweepLevel();
         m_iTriggeredSweepActive[TS_REVIEW]=TRIG_SWEEP_STIM;
         BeginTriggeredSweepLevel();
         
	      //TerminateAllCalipers(true);
	      if(m_eCaliper==eLevel)
	      {
				m_fMonitor->m_vMonitor.m_cprLevel.Reset();
				m_vReview->m_cprLevel.Reset();
				m_vPrevReview->m_cprLevel.Reset();
			}
      }
   }

	if (m_iTriggeredSweepActive[TS_REVIEW]==TRIG_SWEEP_STIM)	
	{	
	   m_bTriggeredFirstSweep[TS_REVIEW]=false;
		if( m_vReview->m_bScroll )
		{
			CWMLibrary::StopScrolling(m_vReview, m_fReview->m_pSignalBar, true);
		}

		if(m_iTriggeredSweepShow!=SHOW_LAST_ONLY) 
		{
			StopChannelDrag();
			m_vReview->TriggeredSweepShow();
		}

		m_fReview->ShowWindow(SW_SHOW);
		m_fReview->BringWindowToTop();

		ResizeAllReviewWindows(eReview);
		m_vReview->BeginTriggeredSweep();
		// Bring CathMap setup dialog on top if visible.
		// We don't want review dialog covers CathMap setup dialog entirely
		// otherwise, user won't be able to configure or close CathMap setup dialog.
		if (m_fCathMap->IsWindowVisible())
			m_fCathMap->BringWindowToTop();
	} 
	else 
	{
      m_bTriggeredFirstSweep[TS_MONITOR]=false;
		
		m_fMonitor->m_vMonitor.TriggeredSweepShow();

		m_fMonitor->ShowWindow(SW_SHOW);		
      m_fMonitor->BringWindowToTop();
		ResizeAllReviewWindows(eMonitor);
		m_fMonitor->m_vMonitor.BeginTriggeredSweep();	
      m_MainBar.SetButtonColor(eMonitor);
	}
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::BeginTriggeredSweepLevel()

	Description	:	This function stops the dragging mode of all the channels,
						closes all the calipers, checks for the recording state and
						starts the Level Triggered Sweep on the Review screen if 
						recording signals or the Monitor screen.

	Returns		:	None

	Setup			:	1. Acquire realtime signals on the Realtime screen through the 
							amplifier.
	TRIGGERED SWEEP:
						1. Left mouse click on the Show button on the mainbar. Verify the 
						show dialog box displays.
						2. Left mouse click on the 'All' list item. Verify the Show dialog
						box closes.
						
	Testing		:	
		Review Screen:	
						1. Open the Review screen and start recording the signals. Verify 
							the signals are displayed on the Review screen.
						2. Press the TrigLevel button on the MainBar. Verify the Triggered 
							Level procedure starts on the Review screen.
	TRIGGERED SWEEP:
						1. Verify the past updates are recorded as gray colored signals.

		Monitor Screen:
						1. Stop recording the signals by pressing the Record keystroke on 
							the keyboard. Verify the recording of the signals is stopped.
						2.	Press the TrigLevel button on the MainBar. Verify the Triggered 
							Level procedure starts on the Monitor screen.
	TRIGGERED SWEEP:
						1. Verify the past updates are recorded as gray colored signals.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::BeginTriggeredSweepLevel(void)
{
	StopChannelDrag();

   TerminateAllCalipers();

	EndTriggeredReviewMode(eReview);
	EndTriggeredReviewMode(ePrevReview);	

	m_dMonitor.m_usSaveAcquirePopFinished=SAVE_ACQUIRE_POP_NONE;
	//m_dMonitor.m_usDrawAcquirePop=SAVE_ACQUIRE_POP_NONE; this could be set before trig sweep is active

	m_MainBar.m_btnTriggerLevelCtl.SetBkColor(NEW_CTLCOLOR_DLGBAR_BUTTON_BACKGROUND_HIGHLIGHT);

   // RULES FOR TURNING ON TRIG SWEEP
   // general rule - if not saving go to monitor window else review
   //
   // if NOT saving 
   //    if Monitor window is not already in stim trig sweep use it
   //    else turn saving on and move the stim trig sweep to the review and use the monitor window
   // else
   //    if review window is not already in trig sweep use it
   //    else move the stim trig sweep to the review and use the monitor window
 	if(!m_dLog.m_iSaveData)	
   {
      if(!m_iTriggeredSweepActive[TS_MONITOR] || 
			(m_iTriggeredSweepActive[TS_MONITOR]==TRIG_SWEEP_LEVEL))
      {
         m_iTriggeredSweepActive[TS_MONITOR]=TRIG_SWEEP_LEVEL;
      }
		else
		{
         EndTriggeredSweepStim();
         m_dLog.m_iSaveData=true;
         m_iTriggeredSweepActive[TS_MONITOR]=TRIG_SWEEP_LEVEL;
         BeginTriggeredSweepStim();
      }
   }
	else
	{
      if(!m_iTriggeredSweepActive[TS_REVIEW] && 
			(m_iTriggeredSweepActive[TS_MONITOR]!=TRIG_SWEEP_STIM))
      {
         m_iTriggeredSweepActive[TS_REVIEW]=TRIG_SWEEP_LEVEL;
      }
		else	// it is implied that level is in review so move it
		{
         EndTriggeredSweepStim();
         m_iTriggeredSweepActive[TS_MONITOR]=TRIG_SWEEP_LEVEL;
         BeginTriggeredSweepStim();
      }
   }
   
	if (m_iTriggeredSweepActive[TS_REVIEW]==TRIG_SWEEP_LEVEL)	
	{	
      m_bTriggeredFirstSweep[TS_REVIEW]=false;

		if( m_vReview->m_bScroll )
		{
			CWMLibrary::StopScrolling( m_vReview, m_fReview->m_pSignalBar, true );
		}

		if(m_iTriggeredSweepShow!=SHOW_LAST_ONLY) 
		{
			StopChannelDrag();
			m_vReview->TriggeredSweepShow();
		}

		m_fReview->ShowWindow(SW_SHOW);
		m_fReview->BringWindowToTop();
      ResizeAllReviewWindows(eReview);
		m_vReview->BeginTriggeredSweep();
	} 
	else 
	{
      m_bTriggeredFirstSweep[TS_MONITOR]=false;

		m_fMonitor->m_vMonitor.TriggeredSweepShow();

		if(!m_fMonitor->IsWindowVisible())
		{
			CWMLibrary::HandleClicks(m_fMonitor, eMonitor);	
		}
		ResizeAllReviewWindows(eMonitor);
		m_fMonitor->m_vMonitor.BeginTriggeredSweep();
      m_MainBar.SetButtonColor(eMonitor);
	}
}

void CWMApp::EndTriggeredReviewMode(const eWMWindow eWindow)
{
	switch(eWindow)	
	{
		case eReview	:
		{
			if(m_uiTriggeredReviewMode & TRIGGERED_MODE_REVIEW)
			{
				m_uiTriggeredReviewMode ^= TRIGGERED_MODE_REVIEW;

				m_vReview->EndTriggeredReviewMode();
				
				if(m_fReview->m_pSignalBar)
				{
					m_fReview->m_pSignalBar->m_btnTriggerCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
				}
			}
		}
		break;

		case ePrevReview	:
		{
			if(m_uiTriggeredReviewMode & TRIGGERED_MODE_PREV_REVIEW)
			{
				m_uiTriggeredReviewMode ^= TRIGGERED_MODE_PREV_REVIEW;

				m_vPrevReview->EndTriggeredReviewMode();
				
				if(m_fPrevReview->m_pSignalBar)
				{
					m_fPrevReview->m_pSignalBar->m_btnTriggerCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);
				}
			}
		}
		break;
	}
}

void CWMApp::TerminateAllCalipers(const UINT uiExcept, bool bRefresh)
{
	m_eCursor	=	eDefaultCursor;
	m_eCaliper	=	eNoneCaliper;

	m_vReview->m_cprPoint.Reset();
	m_vReview->m_cprLine.Reset();
	m_vReview->m_cprFullLine.Reset();
	m_vReview->m_cprHorz.Reset();
	m_vReview->m_cprVert.Reset();
	
	if(uiExcept!=TRIGGERED_MODE_REVIEW)
	{
		m_vReview->m_cprLevel.Reset();
	}
		
	m_vPrevReview->m_cprPoint.Reset();
	m_vPrevReview->m_cprLine.Reset();
	m_vPrevReview->m_cprFullLine.Reset();
	m_vPrevReview->m_cprHorz.Reset();
	m_vPrevReview->m_cprVert.Reset();
	
	if(uiExcept!=TRIGGERED_MODE_PREV_REVIEW)
	{
		m_vPrevReview->m_cprLevel.Reset();
	}
	
	m_vHolter->m_cprPoint.Reset();
	m_vHolter->m_cprLine.Reset();
	m_vHolter->m_cprFullLine.Reset();
	m_vHolter->m_cprHorz.Reset();

	m_fMonitor->m_vMonitor.m_cprPoint.Reset();
	m_fMonitor->m_vMonitor.m_cprHor.Reset(true);
	m_fMonitor->m_vMonitor.m_cprVer.Reset(true);
	m_fMonitor->m_vMonitor.m_cprLevel.Reset();

	m_vATMMap->m_cprHorz.Reset();
	m_vATMMap->m_cprVert.Reset();

	if(bRefresh)	
	{
		m_vReview->InvalidateView();
		m_vPrevReview->InvalidateView();
		m_vHolter->InvalidateView();
		m_fMonitor->m_vMonitor.Invalidate();
		m_vATMMap->InvalidateView();
	}
}

void CWMApp::BeginTriggeredReviewMode(const eWMWindow eWindow)
{
	StopChannelDrag();

	if(m_iTriggeredSweepActive[TS_REVIEW]==TRIG_SWEEP_LEVEL)
	{
		EndTriggeredSweepLevel();
	}

	if(m_iTriggeredSweepActive[TS_REVIEW]==TRIG_SWEEP_STIM)
	{
      EndTriggeredSweepStim();
	}

	switch(eWindow)	
	{
		case eReview	:
		{
			UINT uiExcept = TRIGGERED_MODE_NONE;
			if(m_uiTriggeredReviewMode & TRIGGERED_MODE_PREV_REVIEW)
			{
				uiExcept = TRIGGERED_MODE_PREV_REVIEW;
			}
			
			TerminateAllCalipers(uiExcept);

			if( m_vReview->m_bScroll )
			{
				CWMLibrary::StopScrolling(	m_vReview, 
													m_fReview->m_pSignalBar, 
													true);
			}

			m_fReview->ShowWindow(SW_SHOW);
			m_fReview->BringWindowToTop();
			ResizeAllReviewWindows(eReview);

			m_uiTriggeredReviewMode |= TRIGGERED_MODE_REVIEW;

			m_vReview->BeginTriggeredReviewMode();
		}
		break;

		case ePrevReview	:
		{
			UINT uiExcept = TRIGGERED_MODE_NONE;
			if(m_uiTriggeredReviewMode & TRIGGERED_MODE_REVIEW)
			{
				uiExcept = TRIGGERED_MODE_REVIEW;
			}
			
			TerminateAllCalipers(uiExcept);

			if( m_vPrevReview->m_bScroll )
			{
				CWMLibrary::StopScrolling( m_vPrevReview, 
													m_fPrevReview->m_pSignalBar, 
													true );
			}

			m_fPrevReview->ShowWindow(SW_SHOW);
			m_fPrevReview->BringWindowToTop();
			ResizeAllReviewWindows(ePrevReview);

			m_uiTriggeredReviewMode |= TRIGGERED_MODE_PREV_REVIEW;

			m_vPrevReview->BeginTriggeredReviewMode();
		}
		break;
	}
}

void CWMApp::SetTrigger(void)
{
	if (m_iTriggeredSweepActive[TS_REVIEW])	
	{	
		m_dReview.SetTrigger();
		m_fReview->m_pSignalBar->SetPageIcons(m_dReview.m_rppReview.iPageN);
	} 
   if (m_iTriggeredSweepActive[TS_MONITOR])
   {
		m_dMonitor.SetTrigger();	
	}
}

void CWMApp::ResetTriggerLevel(void)
{
	if (!IsTrigSweepLevelActive()) return;

	for (register short iIndex=0; iIndex<MAX_SCREEN_CHANNELS; iIndex++) 
	{	
		m_dMonitor.realtime_analysis[iIndex].last_level=0;	
	}

   if (m_iTriggeredSweepLevelStart!=SWEEP_FINISHED) 
	{
		m_iTriggeredSweepLevelStart=SWEEP_RESET;	
	}
}

void CWMApp::RefreshTriggeredSweep(void)
{
	if (m_iTriggeredSweepActive[TS_REVIEW])	
	{	
		m_vReview->RefreshTriggeredSweep();	
	} 
  	if (m_iTriggeredSweepActive[TS_MONITOR])	
   {
		m_fMonitor->m_vMonitor.RefreshTriggeredSweep();	
	}
}

void CWMApp::CheckTriggeredSweep(void)
{
	switch(m_iTriggeredSweepLevelStart)
	{
		case SWEEP_FINISHED:
	   {
		   if(m_iTriggeredSweepActive[TS_MONITOR]==TRIG_SWEEP_LEVEL)	
		   {	
			   m_fMonitor->m_vMonitor.TriggeredSweepFinished();
		   }
		   m_iTriggeredSweepLevelStart=SWEEP_RESET;
	   }
	   break;
	}

	switch (m_iTriggeredSweepStimStart)
	{
		case SWEEP_FINISHED:
		{
		   if (m_iTriggeredSweepActive[TS_MONITOR]==TRIG_SWEEP_STIM)
			{	
				m_fMonitor->m_vMonitor.TriggeredSweepFinished();
			}
			m_iTriggeredSweepStimStart=SWEEP_RESET;
		}
		break;
		case SWEEP_STIM_NEW:
		{
			m_iTriggeredSweepStimStart=SWEEP_RESET; // just in case to stop recursion
			BeginTriggeredSweepStim();
		}
		break;
	}
}

void CWMApp::EndTriggeredSweepStim(void)
{
	m_MainBar.m_btnTriggerStimCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);

   if(m_iTriggeredSweepActive[TS_REVIEW]==TRIG_SWEEP_STIM)
	{	
      m_iTriggeredSweepActive[TS_REVIEW]=0;
		m_vReview->EndTriggeredSweep();
	}
 	if(m_iTriggeredSweepActive[TS_MONITOR]==TRIG_SWEEP_STIM)
   {
      m_iTriggeredSweepActive[TS_MONITOR]=0;
		m_fMonitor->m_vMonitor.EndTriggeredSweep();
	}
}

void CWMApp::EndTriggeredSweepLevel(void)
{
	m_MainBar.m_btnTriggerLevelCtl.SetBkColor(NEW_CTLCOLOR_TOOLBAR_BUTTON_BACKGROUND);

	if (m_iTriggeredSweepActive[TS_REVIEW]==TRIG_SWEEP_LEVEL)	
	{	
      m_iTriggeredSweepActive[TS_REVIEW]=0;
		m_vReview->EndTriggeredSweep();
	}
  	if (m_iTriggeredSweepActive[TS_MONITOR]==TRIG_SWEEP_LEVEL)
   {
      m_iTriggeredSweepActive[TS_MONITOR]=0;
		m_fMonitor->m_vMonitor.EndTriggeredSweep();
	}
}

bool CWMApp::ArchiveFiles(const bool bDelete)
{
#ifndef PHILIPS_VIEWER
	m_pArchiveDialog = new CArchiveDialog(bDelete, m_fMain);
	m_pArchiveDialog->Create(IDD_DIALOG_ARCHIVE, m_fMain);
	m_pArchiveDialog->ShowWindow(SW_SHOW);
#endif

	return true;
}

// EJB 1/9/2013: replaced by new ShellMenu
/*
// key_code - scan code of a key press
bool CWMApp::ProcessExit(const int iVirtKey)
{
	static short iExitFlag=0;

	// this is the back door to get out altEXIT
	switch (iVirtKey) 
	{
		case 'E'	:	iExitFlag=1;					break;
		case 'X'	:	if(iExitFlag==1) iExitFlag=3;	break;
		case 'I'	:	if(iExitFlag==3) iExitFlag=7;	break;
		case 'T'	:	if(iExitFlag==7)				return true;
		default	:		iExitFlag=0;					break;
	}
   return false;
}
*/

void CWMApp::DatabaseMaintenance(void)
{
	m_thePrintService.InstallPrinter();

#ifndef PHILIPS_VIEWER
	m_pSysMaintDialog = new CSysMaintDialog(m_fMain, m_pSysMaintDialog);
	m_pSysMaintDialog->Create( IDD_DIALOG_SYS_MAINT, m_fMain);
	m_pSysMaintDialog->ShowWindow(SW_SHOW);
#endif	
}

void CWMApp::DatabaseQuery(void)
{
	m_thePrintService.InstallPrinter();

#ifndef PHILIPS_VIEWER
	m_pQueryDialog = new CQueryDialog(m_fMain);
	m_pQueryDialog->Create( IDD_DIALOG_QUERY, m_fMain);
	m_pQueryDialog->ShowWindow(SW_SHOW);
#endif	
}

void CWMApp::CheckAllViews(BOOL bActive, const eWMWindow eWinType)
// bActive = true from MFC and must be true or it returns
// eWinType - eDB... enums for window type
{
	if(m_bResizing || !bActive) return;

	if( m_fCine && 
		m_fCine->IsWindowVisible() && 
		m_INIfile.m_bCineInstalled &&
		m_dCine.IsCinePlaying() &&
		eWinType!=eCine)
	{
		if(m_INIfile.m_iCineMaximumDevices>1) 
		{
			for(int iControl=CINE_CTL_1; iControl<=CINE_CTL_4; ++iControl)
			{
				if(m_dCine.GetCineState(iControl)!=eCineOff)
				{
					CWindowDC dc(&m_vCine->m_ccVideoCtl[iControl]); 

					CRect crVisible;				
					dc.GetClipBox(&crVisible);

					BOOL bEmpty = crVisible.IsRectNull();
					if( bEmpty )
					{
						switch(iControl)
						{
							case CINE_CTL_1 : m_vCine->OnButtonPlay1(); break;
							case CINE_CTL_2 : m_vCine->OnButtonPlay2(); break;
							case CINE_CTL_3 : m_vCine->OnButtonPlay3(); break;
							case CINE_CTL_4 : m_vCine->OnButtonPlay4(); break;
						}
					}
                    m_vCine->m_ccVideoCtl[iControl].ReleaseDC(&dc);
				}		
			}
		}
		else
		{
			eCineState eState = m_dCine.GetCineState(0);

			if(eState!=eCineOff)
			{
				short iControl=MAX_CINE_DEVICES;
				switch(eState)
				{
					case eCinePlay1 : iControl = CINE_CTL_1; break;
					case eCinePlay2 : iControl = CINE_CTL_2; break;
					case eCinePlay3 : iControl = CINE_CTL_3; break;
					case eCinePlay4 : iControl = CINE_CTL_4; break;
				}

				if(iControl<MAX_CINE_DEVICES)
				{
					CWindowDC dc(&m_vCine->m_ccVideoCtl[iControl]); 

					CRect crVisible;				
					dc.GetClipBox(&crVisible);

					BOOL bEmpty = crVisible.IsRectNull();
					if( bEmpty )
					{
						switch(iControl)
						{
							case CINE_CTL_1 : m_vCine->OnButtonPlay1(); break;
							case CINE_CTL_2 : m_vCine->OnButtonPlay2(); break;
							case CINE_CTL_3 : m_vCine->OnButtonPlay3(); break;
							case CINE_CTL_4 : m_vCine->OnButtonPlay4(); break;
						}
					}
				}
			}		
		}
	}   

	long lWidth = ::GetSystemMetrics(SM_CXSCREEN);
	//if(m_INIfile.m_bDualMonitorInstalled)
	//{
		//lWidth *= 2;
	//}

	if(m_fRealTime && lWidth<2000)	// 1 MONITOR.
	{
		if(m_INIfile.m_szAmpAdapterIP[0] != 0) // Indicates network adapter info supplied.
		{
			if(m_INIfile.m_bRealTimeOnTop)
			{
				if(!m_fRealTimeBar->IsWindowVisible())
				{
					m_fRealTimeBar->ShowWindow(SW_SHOW);
				}
				
				if(!m_fRealTime->IsWindowVisible())
				{
					m_fRealTime->ShowWindow(SW_SHOW);
				}
				m_fRealTime->BringWindowToTop();		 // Realtime is always on top
			}
		}
		else
		{
			m_fRealTime->ShowWindow(SW_HIDE);
			m_fRealTimeBar->ShowWindow(SW_HIDE);
		}
	}
}

void CWMApp::RecordDisplay(void)
{
	long lDiskFreeMin			=	(long)(m_dLog.m_lMaxDiskFree/SAMPLE_RATE/60);	// in minutes
	const long lDiskFreeHr	=	lDiskFreeMin/60;											// in hours
	lDiskFreeMin				=	lDiskFreeMin%60;											// 2 digit number

	long lDiskUsedMin			=	0;

	if(m_dReview.m_rppReview.signal_header.total_channelN>0)
	{
		USHORT usSampleSize	=	LogSampleSize( m_dReview.m_rppReview.signal_header.total_channelN );

		if(usSampleSize>0)
		{
			lDiskUsedMin		=	(long)(m_dLog.m_lMaxDiskUsedBytes/((INT64)usSampleSize*SAMPLE_RATE*60));	// in minutes
		}
		else
		{
			lDiskUsedMin		=	(long)(m_dLog.m_lMaxDiskUsed/SAMPLE_RATE/60);	// in minutes
		}
	}
	else
	{
		lDiskUsedMin			=	(long)(m_dLog.m_lMaxDiskUsed/SAMPLE_RATE/60);	// in minutes
	}
	const long lDiskUsedHr	=	lDiskUsedMin/60;											// in hours
	lDiskUsedMin				=	lDiskUsedMin%60;											// 2 digit number

	TCHAR szDate[DATE_SIZE]={0};
	CDateTime::ConvDate(szDate, MM_DD_YY, CA2T((PCHAR)m_dLog.m_lhLogHeader.szDate), 0.0);

	CString csTemp; csTemp.Format(GETMESSAGE(878), lDiskUsedHr, lDiskUsedMin);
	m_MainBar.m_stcDiskUsedCtl.SetText(csTemp);

	if(m_INIfile.m_iNumberHardDrives>1) 
	{
	   long lTotalFreeMin		=	(long)(m_dLog.m_lTotalDiskFree/60I64);	// in minutes
	   const long lTotalFreeHr	=	lTotalFreeMin/60;							// in hours
 	   lTotalFreeMin				=	lTotalFreeMin%60;							// 2 digit number
	
		csTemp.Format(	_T("%-2.2ld:%2.2ld(%-2.2ld:%-2.2ld)"), 
							lDiskFreeHr, 
							lDiskFreeMin, 
							lTotalFreeHr, 
							lTotalFreeMin);
	}
	else
	{
		csTemp.Format(GETMESSAGE(877), lDiskFreeHr, lDiskFreeMin);
	}

	m_MainBar.m_stcDiskFreeCtl.SetText(csTemp);
}

void CWMApp::ChangeReviewSpeed(void) 		//	CNTRL + W
{
	if(!CWMLibrary::IsSafeWindow(m_fReview) || 
		!CWMLibrary::IsSafeWindow(m_fReview->m_pSignalBar) )
	{
		return;
	}

	m_fReview->m_pSignalBar->OnStaticSpeed();
}

void CWMApp::DemoMode() //	CNTRL + H
{
#ifndef PHILIPS_VIEWER
	if(CWMLibrary::IsSafeWindow(m_vCathMap) && m_vCathMap->IsWindowVisible())
	{
		AfxTrace(_T("CMainFrame::CONTROL + H : Place Cathmap Code here\n"));

      m_dCathMap.CreateDemoPage();
      m_dCathMap.m_bCatheterMapChanges=true;
		m_vCathMap->RefreshScreen();
	}	
	else	
	{
		SetDemoMode();
	}
#else
	SetDemoMode();
#endif
}

void CWMApp::DisplayCine() 		//	CNTRL + P
{
	if( !CWMLibrary::IsSafeWindow(m_vCine) || !m_dCine.m_bInstalled)	
	{
		CMessage::PopupMessage(WMFILELINE, 158);	return;
	}

	m_fCine->ShowWindow(SW_SHOW);
	m_fCine->BringWindowToTop();
	m_MainBar.SetButtonColor(eCine);
	
	m_vCine->OnButtonPlay1();
	
	if(m_INIfile.m_iCineMaximumDevices>1)
	{
		m_vCine->OnButtonPlay2();
	}	
}

void CWMApp::Print12lead25() //	CNTRL + E
{
	if(HasSignals())
	{
		m_cgPage.SetSplit(false);
		m_bPrintFromList=true;
		m_thePrintService.SetPrintTitle(724);
		if( IsArgument(_T("PRINT_PREVIEW"))	)
		{
			m_MainBar.OnFilePrintPreview(ePrint12Lead25);
		}
		else											
		{
			m_MainBar.m_bBoth	= ( m_MainBar.m_bPrintToPrinter && m_MainBar.m_bPrintToFile );
			m_MainBar.m_bToFile = ( m_MainBar.m_bPrintToFile );

			m_MainBar.OnFilePrint(ePrint12Lead25);
		}
	}
	else
	{
		CMessage::PopupMessage(WMFILELINE, 1252);
		CMessage::Beep();
	}
}

void CWMApp::Print12lead50() //	CNTRL + F
{
	if(HasSignals())
	{
		m_cgPage.SetSplit(false);
		m_bPrintFromList=true;
		m_thePrintService.SetPrintTitle(725);
		if( IsArgument(_T("PRINT_PREVIEW"))	)
		{
			m_MainBar.OnFilePrintPreview(ePrint12Lead50);
		}
		else											
		{
			m_MainBar.m_bBoth	= ( m_MainBar.m_bPrintToPrinter && m_MainBar.m_bPrintToFile );
			m_MainBar.m_bToFile = ( m_MainBar.m_bPrintToFile );

			m_MainBar.OnFilePrint(ePrint12Lead50);
		}
	}
	else
	{
		CMessage::PopupMessage(WMFILELINE, 1252);
		CMessage::Beep();
	}
}

void CWMApp::Print12leadReview() 		//	CNTRL + G
{
	if(HasSignals())
	{
		m_cgPage.SetSplit(false);
		m_bPrintFromList=true;
		m_thePrintService.SetPrintTitle(726);
		if( IsArgument(_T("PRINT_PREVIEW"))	)	
		{
			m_MainBar.OnFilePrintPreview(ePrint12LeadScreen);
		}
		else
		{
			m_MainBar.m_bBoth	= ( m_MainBar.m_bPrintToPrinter && m_MainBar.m_bPrintToFile );
			m_MainBar.m_bToFile = ( m_MainBar.m_bPrintToFile );

			m_MainBar.OnFilePrint(ePrint12LeadScreen);
		}
	}
	else
	{
		CMessage::PopupMessage(WMFILELINE, 1252);
		CMessage::Beep();
	}
}

void CWMApp::PrintReviewFit() 		//	CNTRL + 2
{
	m_bPrintFromList=true;
	m_cgPage.SetSplit();
	m_thePrintService.SetPrintTitle(731);
   m_bReviewFit=true;
	if( IsArgument(_T("PRINT_PREVIEW"))	)
	{
		m_MainBar.OnFilePrintPreview(ePrintReview);
	}
	else
	{
		m_MainBar.m_bBoth	= ( m_MainBar.m_bPrintToPrinter && m_MainBar.m_bPrintToFile );
		m_MainBar.m_bToFile = ( m_MainBar.m_bPrintToFile );

		m_MainBar.OnFilePrint(ePrintReview);
	}
}

void CWMApp::ViewNextLogEvent() 		//	CNTRL + N
{
#ifndef PHILIPS_VIEWER
	if(CWMLibrary::IsSafeWindow(m_vCathMap) && m_vCathMap->IsWindowVisible())
	{
		AfxTrace(_T("CMainFrame::CONTROL + H : Place Cathmap Code here\n"));

      if( !m_dCathMap.AddNewChannel() )
		{
			return;
		}

      m_dCathMap.m_bCatheterMapChanges=true;
		m_vCathMap->RefreshScreen();
	}
	else
	{
		m_vLog->NextViewLogPage();
	}
#else
	m_vLog->NextViewLogPage();
#endif
}

void CWMApp::ShowStimTab(const eStimTabDialog eCurDialog)
{
#ifndef PHILIPS_VIEWER
	m_Stim.ShowStimTab(eCurDialog);
#endif
}

void CWMApp::DrawReviewScrollKnob(const eWMWindow eWnd, CReviewPortParams& rReview)
{
	switch(eWnd)	
	{
		case eReview		:	
			if(m_fReview->m_pSignalBar)	
			{	
				m_fReview->m_pSignalBar->DrawReviewScrollKnob(rReview);		
			}
		break;
		case ePrevReview	:	
			if(m_fPrevReview->m_pSignalBar)
			{
				m_fPrevReview->m_pSignalBar->DrawReviewScrollKnob(rReview);	
			}
		break;
	}
}

void CWMApp::SetCathMapDialogsActive(const bool bSet)	
{	
	if(bSet)
	{
		++m_iCathMapDlgs;
	}
	else
	{
		if(--m_iCathMapDlgs<0)
		{
			m_iCathMapDlgs=0;
		}
	}
}

void CWMApp::SetAmpBar(CReviewPortParams& rReview)
{
	switch(rReview.eType)
	{
		case eReview :
		{
			if(m_fReview && m_fReview->m_pAmpDialogBar && m_vReview)
			{
				m_fReview->SetAmpBar();
				m_fReview->m_pAmpDialogBar->PlaceControls(m_vReview->m_arcvDraw, rReview.max_channelN);
			}
		}
		break;

		case ePrevReview :
		{
			if(m_fPrevReview && m_fPrevReview->m_pAmpDialogBar && m_vPrevReview)
			{
				m_fPrevReview->SetAmpBar();
				m_fPrevReview->m_pAmpDialogBar->PlaceControls(m_vPrevReview->m_arcvDraw, rReview.max_channelN);
			}
		}
		break;
	}
}

void CWMApp::Transmit(const UINT uiCmd, const int iResponse)
{
#ifndef PHILIPS_VIEWER
	if(m_sNM.m_bConnected && m_INIfile.m_bNurseMateInstalled)
	{
		CSingleLock slLock(&m_ctsTransmit, TRUE);

		SNMPacket<int> nmSend			=	{0};

		nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
		nmSend.sHeader.uiCommand		=	uiCmd;
		nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

		nmSend.sData						=	iResponse;

		nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

		m_sNM.SendAll(&nmSend, sizeof(nmSend));
	}
#endif
}

void CWMApp::TransmitOne(const UINT uiCmd, const short iData)
{
#ifndef PHILIPS_VIEWER
	if(m_sNM.m_bConnected && m_INIfile.m_bNurseMateInstalled)
	{
		CSingleLock slLock(&m_ctsTransmit, TRUE);

		SNMPacket<short> nmSend			=	{0};

		nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
		nmSend.sHeader.uiCommand		=	uiCmd;
		nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

		nmSend.sData						=	iData;

		nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

		m_sNM.SendAll(&nmSend, sizeof(nmSend));

		if(uiCmd==WMNM_LOG_CHANGE)
		{
			Log(eNMTrace, false, _T("Sending LOG_CHANGE"));
		}
	}
#endif
}

void CWMApp::Transmit(const UINT	 uiCmd, 
							 const short iPower, 
							 const short iTemp, 
							 const short iImped, 
							 const short iTime, 
							 const short iTemp2)
{
#ifndef PHILIPS_VIEWER
	if(m_sNM.m_bConnected && m_INIfile.m_bNurseMateInstalled && (IsActiveMode()))
	{
		CSingleLock slLock(&m_ctsTransmit, TRUE);

		if(IsNMVersion(4, 2, 0))
		{
			SNMPacket<SUpdateRF> nmSend={0};

			nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
			nmSend.sHeader.uiCommand		=	uiCmd;
			nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

			nmSend.sData.sNMRF.sRF			=	m_Session;
			nmSend.sData.sNMRF.total_RF_time = m_dProcedure.m_Procedure.total_RF_time;
			nmSend.sData.sNMRF.iMaxPower	=	m_dRF.m_iMaxPower;
			nmSend.sData.sNMRF.iEnergy		=	m_dRF.m_iEnergy;
			nmSend.sData.sNMRF.iMaxTemp	=	m_dRF.m_iMaxTemp;
			nmSend.sData.sNMRF.iMaxTemp2	=	m_dRF.m_iMaxProximalTemp;
			nmSend.sData.sNMRF.iMaxImp		=	m_dRF.m_iMaxImp;
			nmSend.sData.sNMRF.iPower		=	m_dRF.m_iPower;			
			nmSend.sData.sNMRF.iTemp		=	m_dRF.m_iTemp;
			nmSend.sData.sNMRF.iTemp2		=	m_dRF.m_iProximalTemp;
			nmSend.sData.sNMRF.iImp			=	m_dRF.m_iImp;
			
			if(m_vRF)
			{	
				nmSend.sData.sNMRF.dTimeAxis	=	m_vRF->m_dTimeAxis;
			}

			if(m_dbSession.m_pList)
			{
				nmSend.sData.sNMRF.iCurSession =	m_dbSession.m_pList->temp_recN;
				nmSend.sData.sNMRF.iMaxSessions=	m_dbSession.m_pList->total_recN;

				if (m_dRF.m_bSessionActive) {
					TCHAR pszDate[DATE_SIZE] = {0};

					// this will convert the current date to MM/DD/YYYY or DD/MM/YYYY depending
					// on our internal date format (YYYY/MM/DD maps to DD/MM/YYYY).
					CDateTime::ConvDate(pszDate, MM_DD_YYYY, theApp.m_szTodaysDate, 0.0);
					memcpy(
						nmSend.sData.sNMRF.date, 
						(PCHAR)m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
						sizeof(nmSend.sData.sNMRF.date)
					);
				}
				else {
					memcpy(
						nmSend.sData.sNMRF.date, 
						(PCHAR)m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
						sizeof(nmSend.sData.sNMRF.date)
					);
				}
			}

			nmSend.sData.sNMRF.iTCCount	=	m_dRF.m_iTCCount;

			nmSend.sData.iTime				=	iTime;

			nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

			AfxTrace(_T("Total Session Time: %u\n"), nmSend.sData.sNMRF.sRF.total_session_time);

			m_sNM.SendAll(&nmSend, sizeof(nmSend));
		}
		else
		{
			SNMPacket<SUpdateRF_352> nmSend={0};

			nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
			nmSend.sHeader.uiCommand		=	uiCmd;
			nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

			nmSend.sData.sNMRF.sRF			=	m_Session;
			nmSend.sData.sNMRF.total_RF_time = m_dProcedure.m_Procedure.total_RF_time;
			nmSend.sData.sNMRF.iMaxPower	=	m_dRF.m_iMaxPower;
			nmSend.sData.sNMRF.iMaxTemp	=	m_dRF.m_iMaxTemp;
			nmSend.sData.sNMRF.iMaxTemp2	=	m_dRF.m_iMaxProximalTemp;
			nmSend.sData.sNMRF.iMaxImp		=	m_dRF.m_iMaxImp;
			nmSend.sData.sNMRF.iPower		=	m_dRF.m_iPower;
			nmSend.sData.sNMRF.iTemp		=	m_dRF.m_iTemp;
			nmSend.sData.sNMRF.iTemp2		=	m_dRF.m_iProximalTemp;
			nmSend.sData.sNMRF.iImp			=	m_dRF.m_iImp;
			
			if(m_vRF)
			{	
				nmSend.sData.sNMRF.dTimeAxis	=	m_vRF->m_dTimeAxis;
			}

			if(m_dbSession.m_pList)
			{
				nmSend.sData.sNMRF.iCurSession =	m_dbSession.m_pList->temp_recN;
				nmSend.sData.sNMRF.iMaxSessions=	m_dbSession.m_pList->total_recN;
				if (m_dRF.m_bSessionActive) {
					TCHAR pszDate[DATE_SIZE] = {0};

					// this will convert the current date to MM/DD/YYYY or DD/MM/YYYY depending
					// on our internal date format (YYYY/MM/DD maps to DD/MM/YYYY).
					CDateTime::ConvDate(pszDate, MM_DD_YYYY, theApp.m_szTodaysDate, 0.0);
					memcpy(
						nmSend.sData.sNMRF.date, 
						m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
						sizeof(nmSend.sData.sNMRF.date)
					);
				}
				else {
					memcpy(
						nmSend.sData.sNMRF.date, 
						m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
						sizeof(nmSend.sData.sNMRF.date)
					);
				}
			}

			nmSend.sData.iTime				=	iTime;

			nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

			AfxTrace(_T("Total Session Time: %u\n"), nmSend.sData.sNMRF.sRF.total_session_time);

			m_sNM.SendAll(&nmSend, sizeof(nmSend));
		}
	}
#endif
}


void CWMApp::TransmitNewProcedure(void)
{
#ifndef PHILIPS_VIEWER
	if(m_sNM.m_bConnected && m_INIfile.m_bNurseMateInstalled)
	{
		CSingleLock slLock(&m_ctsTransmit, TRUE);

		const UINT uiCmd = WM2NM_PATIENT_CHANGE;

		if(IsNMVersion(4, 2, 0))
		{
			SNMPacket<SNMDBRecord>	nmSend=	{0};

			nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
			nmSend.sHeader.uiCommand		=	uiCmd;
			nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

			nmSend.sData.sPatient			=	m_dPatient.m_Patient;
			nmSend.sData.sProcedure			=	m_dProcedure.m_Procedure;
			nmSend.sData.sProcedure.log_dir_number = m_INIfile.m_lLogDirNumber;
			nmSend.sData.sProcedure2		=	m_dProcedure.m_Procedure2;

			nmSend.sData.sPrePost			=	m_dProcedure.m_PrePost;

			nmSend.sData.sMeas.sMeasurement= m_dMeas.m_Measurement;
			memcpy(nmSend.sData.sMeas.meas_order, m_dCathMap.m_CathMap.meas_order, sizeof(nmSend.sData.sMeas.meas_order));

			nmSend.sData.sSession.sRF			=	m_Session;
			nmSend.sData.sSession.iMaxPower	=	m_dRF.m_iMaxPower;
			nmSend.sData.sSession.iEnergy		=	m_dRF.m_iEnergy;
			nmSend.sData.sSession.iMaxTemp	=	m_dRF.m_iMaxTemp;
			nmSend.sData.sSession.iMaxTemp2	=	m_dRF.m_iMaxProximalTemp;
			nmSend.sData.sSession.iMaxImp		=	m_dRF.m_iMaxImp;
			nmSend.sData.sSession.iPower		=	m_dRF.m_iPower;
			nmSend.sData.sSession.iTemp		=	m_dRF.m_iTemp;
			nmSend.sData.sSession.iTemp2		=	m_dRF.m_iProximalTemp;
			nmSend.sData.sSession.iImp			=	m_dRF.m_iImp;
			if(m_vRF)
			{	
				nmSend.sData.sSession.dTimeAxis	=	m_vRF->m_dTimeAxis;
			}
			if(m_dbSession.m_pList)
			{
				nmSend.sData.sSession.iCurSession =	m_dbSession.m_pList->temp_recN;
				nmSend.sData.sSession.iMaxSessions=	m_dbSession.m_pList->total_recN;
				if (m_dRF.m_bSessionActive) {
					TCHAR pszDate[DATE_SIZE] = {0};

					// this will convert the current date to MM/DD/YYYY or DD/MM/YYYY depending
					// on our internal date format (YYYY/MM/DD maps to DD/MM/YYYY).
					CDateTime::ConvDate(pszDate, MM_DD_YYYY, theApp.m_szTodaysDate, 0.0);
					memcpy(
						nmSend.sData.sSession.date, 
						m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
						sizeof(nmSend.sData.sSession.date)
					);
				}
				else {
					memcpy(
						nmSend.sData.sSession.date, 
						m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
						sizeof(nmSend.sData.sSession.date)
					);
				}
			}

			nmSend.sData.sAllura					=	m_sAllura;

			nmSend.sData.lLogSequenceNumber	=	m_dLog.m_lLogSequenceNumber;

			nmSend.sData.sHolterConfig			=	m_dHolter.m_HolterConfig;

			nmSend.sData.sLogHeader				=	m_dLog.m_lhLogHeader;

			nmSend.sData.sStatus.bRecording	=	m_dLog.m_iSaveData?true:false;			
			
			nmSend.sData.sStatus.iState		=	GetModeNbr();			

			nmSend.sHeader.usCRC					=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

			m_sNM.SendAll(&nmSend, sizeof(nmSend));

			if(uiCmd==WM2NM_PATIENT_CHANGE)
			{
				Log(eNMTrace, 
					 false, 
					 _T("Sending PATIENT_CHANGE: CRC=%u, DataLen=%u"), 
					 nmSend.sHeader.usCRC, 
					 nmSend.sHeader.uiDataLength);
			}
			else
			{
				Log(eNMTrace, 
					 false, 
					 _T("Sending DB_CHANGE: CRC=%u, DataLen=%u"), 
					 nmSend.sHeader.usCRC, 
					 nmSend.sHeader.uiDataLength);
			}
		}
		else
		{
			SNMPacket<SNMDBRecord_110>	nmSend=	{0};

			nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
			nmSend.sHeader.uiCommand		=	uiCmd;
			nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

			nmSend.sData.sPatient			=	m_dPatient.m_Patient;
			nmSend.sData.sProcedure			=	m_dProcedure.m_Procedure;
			nmSend.sData.sProcedure.log_dir_number = m_INIfile.m_lLogDirNumber;
			memcpy(&nmSend.sData.sProcedure2, &m_dProcedure.m_Procedure2, sizeof(nmSend.sData.sProcedure2));

			nmSend.sData.sMeas.sMeasurement= m_dMeas.m_Measurement;
			memcpy(nmSend.sData.sMeas.meas_order, m_dCathMap.m_CathMap.meas_order, sizeof(nmSend.sData.sMeas.meas_order));

			nmSend.sData.sSession.sRF			=	m_Session;
			nmSend.sData.sSession.iMaxPower	=	m_dRF.m_iMaxPower;
			nmSend.sData.sSession.iMaxTemp	=	m_dRF.m_iMaxTemp;
			nmSend.sData.sSession.iMaxTemp2	=	m_dRF.m_iMaxProximalTemp;
			nmSend.sData.sSession.iMaxImp		=	m_dRF.m_iMaxImp;
			nmSend.sData.sSession.iPower		=	m_dRF.m_iPower;
			nmSend.sData.sSession.iTemp		=	m_dRF.m_iTemp;
			nmSend.sData.sSession.iTemp2		=	m_dRF.m_iProximalTemp;
			nmSend.sData.sSession.iImp			=	m_dRF.m_iImp;
			if(m_vRF)
			{	
				nmSend.sData.sSession.dTimeAxis	=	m_vRF->m_dTimeAxis;
			}
			if(m_dbSession.m_pList)
			{
				nmSend.sData.sSession.iCurSession =	m_dbSession.m_pList->temp_recN;
				nmSend.sData.sSession.iMaxSessions=	m_dbSession.m_pList->total_recN;
				if (m_dRF.m_bSessionActive) {
					TCHAR pszDate[DATE_SIZE] = {0};

					// this will convert the current date to MM/DD/YYYY or DD/MM/YYYY depending
					// on our internal date format (YYYY/MM/DD maps to DD/MM/YYYY).
					CDateTime::ConvDate(pszDate, MM_DD_YYYY, theApp.m_szTodaysDate, 0.0);
					memcpy(
						nmSend.sData.sSession.date, 
						m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
						sizeof(nmSend.sData.sSession.date)
					);
				}
				else {
					memcpy(
						nmSend.sData.sSession.date, 
						m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
						sizeof(nmSend.sData.sSession.date)
					);
				}
			}

			nmSend.sData.sAllura					=	m_sAllura;

			nmSend.sData.lLogSequenceNumber	=	m_dLog.m_lLogSequenceNumber;

			nmSend.sData.sHolterConfig			=	m_dHolter.m_HolterConfig;

			nmSend.sData.sLogHeader				=	m_dLog.m_lhLogHeader;

			nmSend.sData.sStatus.bRecording	=	m_dLog.m_iSaveData?true:false;

			nmSend.sHeader.usCRC					=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

			m_sNM.SendAll(&nmSend, sizeof(nmSend));

			if(uiCmd==WM2NM_PATIENT_CHANGE)
			{
				Log(eNMTrace, 
					 false, 
					 _T("Sending PATIENT_CHANGE: CRC=%u, DataLen=%u"), 
					 nmSend.sHeader.usCRC, 
					 nmSend.sHeader.uiDataLength);
			}
			else
			{
				Log(eNMTrace, 
					 false, 
					 _T("Sending DB_CHANGE: CRC=%u, DataLen=%u"), 
					 nmSend.sHeader.usCRC, 
					 nmSend.sHeader.uiDataLength);
			}
		}

	}
#endif
}


void CWMApp::TransmitViewModel(ViewModelKey viewModelKey)
{
#ifndef  PHILIPS_VIEWER
	if (this->m_INIfile.m_bNurseMateInstalled && this->m_sNM.m_bConnected) {
		if (this->IsNMVersion(4, 2, 0)) {
			SNMPacket<SNMDBRecord> nmSend = {0};

			nmSend.sHeader.usSignature = NM_HEADER_SIGNATURE;
			nmSend.sHeader.uiCommand = WMNM_DB_TAB_CHANGE;
			nmSend.sHeader.uiDataLength = sizeof(nmSend.sData);
			nmSend.sData.nViewModelKey = viewModelKey;

			// [hkc:11.24.2012]: these are required to identify patient-study {
			std::memcpy(nmSend.sData.sPatient.name, theApp.m_dPatient.m_Patient.name, sizeof(nmSend.sData.sPatient.name));
			std::memcpy(nmSend.sData.sPatient.id, theApp.m_dPatient.m_Patient.id, sizeof(nmSend.sData.sPatient.id));
			nmSend.sData.sProcedure.log_dir_number = theApp.m_dProcedure.m_Procedure.log_dir_number;
			// }

			CDatabaseViewModel::GetDatabaseViewModel(viewModelKey).SaveViewModel(nmSend.sData);

			nmSend.sHeader.usCRC = ::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));
			this->m_sNM.SendAll(&nmSend, sizeof(nmSend));
		}			
	}
#endif
}


void CWMApp::Transmit(const UINT uiCmd)
{
#ifndef PHILIPS_VIEWER
	if(m_sNM.m_bConnected && m_INIfile.m_bNurseMateInstalled)
	{
		CSingleLock slLock(&m_ctsTransmit, TRUE);

		switch(uiCmd)
		{	
			case WM2NM_SEND_STATE:
			{
				SNMPacket<int>	nmSend = {0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	uiCmd;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);
				
				nmSend.sData						=	GetModeNbr();

				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));

				Log(eNMTrace, 
					 false, 
					 _T("Sending WM2NM_SEND_STATE: CRC=%u, State=%s"), 
					 nmSend.sHeader.usCRC, 
					 (m_bActiveMode?_T("Active"):_T("Passive")));
				}
			break;

			case WMNM_CHART_SUPPLIES_TREE_CHANGE:
			{
				SNMHeader sHeader		=	{0};
				sHeader.usSignature	=	NM_HEADER_SIGNATURE;
				sHeader.uiCommand		=	uiCmd;
				sHeader.uiDataLength	=	0;
				sHeader.usCRC			=	::CheckSum3(&sHeader, sizeof(sHeader));

				m_sNM.SendAll(&sHeader, sizeof(sHeader));

				Log(eNMTrace, false, _T("Sending WMNM_CHART_SUPPLIES_TREE_CHANGE"));
			}
			break;

			case WMNM_CHART_EVENT_TREE_CHANGE:
			{
				SNMHeader sHeader		=	{0};
				sHeader.usSignature	=	NM_HEADER_SIGNATURE;
				sHeader.uiCommand		=	uiCmd;
				sHeader.uiDataLength	=	0;
				sHeader.usCRC			=	::CheckSum3(&sHeader, sizeof(sHeader));

				m_sNM.SendAll(&sHeader, sizeof(sHeader));

				Log(eNMTrace, false, _T("Sending WMNM_CHART_EVENT_TREE_CHANGE"));
			}
			break;

			case WM2NM_UPDATE_CONSCIOUS_SEDATION_MENUS:
			{
				SNMHeader sHeader		=	{0};
				sHeader.usSignature	=	NM_HEADER_SIGNATURE;
				sHeader.uiCommand		=	uiCmd;
				sHeader.uiDataLength	=	0;
				sHeader.usCRC			=	::CheckSum3(&sHeader, sizeof(sHeader));

				m_sNM.SendAll(&sHeader, sizeof(sHeader));

				Log(eNMTrace, 
					 false, 
					 _T("Sending WM2NM_UPDATE_CONSCIOUS_SEDATION_MENUS"));
			}
			break;
					
			case WMNM_SEND_DB_DRUG:
			{
				if(IsNMVersion(4, 2, 0))
				{
					SNMPacket<SNMDBDrugRecord>	nmSend = {0};

					nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
					nmSend.sHeader.uiCommand		=	uiCmd;
					nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);
					
					nmSend.sData.sProcedure			=	m_dProcedure.m_Procedure;
					nmSend.sData.sProcedure2		=	m_dProcedure.m_Procedure2;
					nmSend.sData.sPrePost			=	m_dProcedure.m_PrePost;					

					nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

					m_sNM.SendAll(&nmSend, sizeof(nmSend));

					Log(eNMTrace, 
						 false, 
						 _T("Sending (4.0.0) WMNM_SEND_DB_DRUG: CRC=%u, DataLen=%u"),
						 nmSend.sHeader.usCRC, 
						 nmSend.sHeader.uiDataLength);
				}
				else
				{
					SNMPacket<SNMDBDrugRecord_110> nmSend = {0};

					nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
					nmSend.sHeader.uiCommand		=	uiCmd;
					nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);
					
					nmSend.sData.sProcedure			=	m_dProcedure.m_Procedure;
					memcpy(&nmSend.sData.sProcedure2, &m_dProcedure.m_Procedure2, sizeof(nmSend.sData.sProcedure2));

					nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

					m_sNM.SendAll(&nmSend, sizeof(nmSend));

					Log(eNMTrace, 
						 false, 
						 _T("Sending WMNM_SEND_DB_DRUG: CRC=%u, DataLen=%u"), 
						 nmSend.sHeader.usCRC, 
						 nmSend.sHeader.uiDataLength);
				}
			}
			break;

			case WMNM_DB_SEND_CONSED:
			{
				SNMPacket<SNMConSedRecord>	nmSend = {0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	uiCmd;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);
				
				memcpy(nmSend.sData.arConSed, m_dProcedure.m_Procedure2.arConSed, sizeof(nmSend.sData.arConSed));

				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));

				Log(eNMTrace, 
				    false, 
				    _T("Sending WMNM_DB_SEND_CONSED: CRC=%u, DataLen=%u"), 
				    nmSend.sHeader.usCRC, 
				    nmSend.sHeader.uiDataLength);
			}
			break;

			case WMNM_SEND_DB_MEASUREMENT:
			{
				SNMPacket<SMeasure>	nmSend = {0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	uiCmd;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);
				
				nmSend.sData						=	m_dMeas.m_Measurement;

				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));

				Log(eNMTrace, 
					 false, 
					 _T("Sending WMNM_SEND_DB_MEASUREMENT: CRC=%u, DataLen=%u"),
					 nmSend.sHeader.usCRC, 
					 nmSend.sHeader.uiDataLength);
			}
			break;

			case WM2NM_SYNC_TIME	:
			{
				DYNAMIC_TIME_ZONE_INFORMATION sTimeZone={0};
				DWORD dwTZRet = ::GetDynamicTimeZoneInformation(&sTimeZone); // TIME_ZONE_ID_DAYLIGHT

				SYSTEMTIME sysUTC={0}; ::GetLocalTime( &sysUTC );

				SNMPacket<SWMNMVersion>	nmSend = {0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	uiCmd;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);
				nmSend.sData.sTimeZone			=	sTimeZone;
				nmSend.sData.sysTime				=	sysUTC;
				nmSend.sData.ucMajor				=	WORKMATE_VERSION_MAJOR;
				nmSend.sData.ucMinor				=	WORKMATE_VERSION_MINOR;
				nmSend.sData.ucRelease			=	WORKMATE_VERSION_RELEASE;

				nmSend.sData.ucDBScreen			=	m_bDBScrnActive;
				nmSend.sData.iState				=	GetModeNbr();

				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));

				USES_CONVERSION;
				CString cs;
				cs.Format(	_T("Sending SYNC_TIME: %d, %s %u\\%u\\%u %u:%u:%u %d"), 
								nmSend.sData.sTimeZone.Bias/60,
								W2A(nmSend.sData.sTimeZone.StandardName),
								nmSend.sData.sTimeZone.StandardDate.wMonth, 
								nmSend.sData.sTimeZone.StandardDate.wDay, 
								nmSend.sData.sTimeZone.StandardDate.wYear,
								nmSend.sData.sTimeZone.StandardDate.wHour,
								nmSend.sData.sTimeZone.StandardDate.wMinute,
								nmSend.sData.sTimeZone.StandardDate.wSecond,
								nmSend.sData.sTimeZone.StandardBias);
				Log(eNMTrace, false, cs);
				
				cs.Format(	_T("Sending SYNC_TIME: %s %u\\%u\\%u %u:%u:%u %d"), 
								W2A(nmSend.sData.sTimeZone.DaylightName),
								nmSend.sData.sTimeZone.DaylightDate.wMonth, 
								nmSend.sData.sTimeZone.DaylightDate.wDay, 
								nmSend.sData.sTimeZone.DaylightDate.wYear,
								nmSend.sData.sTimeZone.DaylightDate.wHour,
								nmSend.sData.sTimeZone.DaylightDate.wMinute,
								nmSend.sData.sTimeZone.DaylightDate.wSecond,
								nmSend.sData.sTimeZone.DaylightBias);
				Log(eNMTrace, false, cs);

				cs.Format(	_T("Sending SYNC_TIME: %u\\%u\\%u %u:%u:%u"), 
								nmSend.sData.sysTime.wMonth, 
								nmSend.sData.sysTime.wDay, 
								nmSend.sData.sysTime.wYear,
								nmSend.sData.sysTime.wHour,
								nmSend.sData.sysTime.wMinute,
								nmSend.sData.sysTime.wSecond);
				Log(eNMTrace, false, cs);

				cs.Format(_T("Sending SYNC_TIME:_timezone: %d _tzname[0]:%s _tzname[1]:%s _dstbias:%d _daylight:%d"), 
							_timezone,
							_tzname[0],
							_tzname[1],
							_dstbias,
							_daylight);
				Log(eNMTrace, false, cs);
			}			
			break;

			case WM2NM_PATIENT_CHANGE	:
			case WMNM_DB_CHANGE			:
			{
				if(IsNMVersion(4, 2, 0))
				{

					SNMPacket<SNMDBRecord>	nmSend=	{0};

					nmSend.sHeader.usSignature			=	NM_HEADER_SIGNATURE;
					nmSend.sHeader.uiCommand			=	uiCmd;
					nmSend.sHeader.uiDataLength		=	sizeof(nmSend.sData);

					nmSend.sData.nViewModelKey			=	ViewModelKeyCount;
					nmSend.sData.sPatient				=	m_dPatient.m_Patient;
					nmSend.sData.sProcedure				=	m_dProcedure.m_Procedure;
					nmSend.sData.sProcedure2			=	m_dProcedure.m_Procedure2;
					nmSend.sData.sPrePost				=	m_dProcedure.m_PrePost;

					nmSend.sData.sMeas.sMeasurement	=	m_dMeas.m_Measurement;
					memcpy(nmSend.sData.sMeas.meas_order, 
							 m_dCathMap.m_CathMap.meas_order, 
							 sizeof(nmSend.sData.sMeas.meas_order));

					nmSend.sData.sSession.sRF			=	m_Session;
					nmSend.sData.sSession.iMaxPower	=	m_dRF.m_iMaxPower;
					nmSend.sData.sSession.iEnergy		=	m_dRF.m_iEnergy;
					nmSend.sData.sSession.iMaxTemp	=	m_dRF.m_iMaxTemp;
					nmSend.sData.sSession.iMaxTemp2	=	m_dRF.m_iMaxProximalTemp;
					nmSend.sData.sSession.iMaxImp		=	m_dRF.m_iMaxImp;
					nmSend.sData.sSession.iPower		=	m_dRF.m_iPower;
					nmSend.sData.sSession.iEnergy		=	m_dRF.m_iEnergy;
					nmSend.sData.sSession.iTemp		=	m_dRF.m_iTemp;
					nmSend.sData.sSession.iTemp2		=	m_dRF.m_iProximalTemp;
					nmSend.sData.sSession.iImp			=	m_dRF.m_iImp;
					if(m_vRF)
					{	
						nmSend.sData.sSession.dTimeAxis	=	m_vRF->m_dTimeAxis;
					}
					if(m_dbSession.m_pList)
					{
						nmSend.sData.sSession.iCurSession =	m_dbSession.m_pList->temp_recN;
						nmSend.sData.sSession.iMaxSessions=	m_dbSession.m_pList->total_recN;
						if (m_dRF.m_bSessionActive) {
							TCHAR pszDate[DATE_SIZE] = {0};

							// this will convert the current date to MM/DD/YYYY or DD/MM/YYYY depending
							// on our internal date format (YYYY/MM/DD maps to DD/MM/YYYY).
							CDateTime::ConvDate(pszDate, MM_DD_YYYY, theApp.m_szTodaysDate, 0.0);
							memcpy(
								nmSend.sData.sSession.date, 
								m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
								sizeof(nmSend.sData.sSession.date)
							);
						}
						else {
							memcpy(
								nmSend.sData.sSession.date, 
								m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
								sizeof(nmSend.sData.sSession.date)
							);
						}
					}

					nmSend.sData.sAllura					=	m_sAllura;

					nmSend.sData.lLogSequenceNumber	=	m_dLog.m_lLogSequenceNumber;
					
					nmSend.sData.sHolterConfig			=	m_dHolter.m_HolterConfig;

					nmSend.sData.sLogHeader				=	m_dLog.m_lhLogHeader;

					nmSend.sData.sStatus.bRecording	=	m_dLog.m_iSaveData?true:false;
					nmSend.sData.sStatus.iState		=	GetModeNbr();
					
					nmSend.sHeader.usCRC					=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

					m_sNM.SendAll(&nmSend, sizeof(nmSend));

					if(uiCmd==WM2NM_PATIENT_CHANGE)
					{
						Log(eNMTrace, 
							 false, 
							 _T("Sending PATIENT_CHANGE: CRC=%u, DataLen=%u"), 
							 nmSend.sHeader.usCRC, 
							 nmSend.sHeader.uiDataLength);
					}
					else
					{
						Log(eNMTrace, 
							 false, 
							 _T("Sending DB_CHANGE: CRC=%u, DataLen=%u"), 
							 nmSend.sHeader.usCRC, 
							 nmSend.sHeader.uiDataLength);
					}
				}
				else
				{
					Log(	eNMTrace, 
							false, 
							_T("WM2NM_PATIENT_CHANGE: Invalid NM Version(%u.%u.%u)"), 
							m_sNMVersion.version[0], 
							m_sNMVersion.version[1], 
							m_sNMVersion.version[2]);
				}				
			}
			break;

			case WM2NM_START_RECORD	:
			{
				SNMPacket<SNMStartRecord> nmSend= {0};
				nmSend.sHeader.usSignature		= NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		= uiCmd;
				nmSend.sHeader.uiDataLength		= sizeof(nmSend.sData);
				nmSend.sData.lTime				= (long)(m_dMonitor.m_shSignalHeader.time_ms/1000);
				nmSend.sData.lLogSequenceNumber	= m_dLog.m_lLogSequenceNumber;
				nmSend.sData.lhLogHeader		= m_dLog.m_lhLogHeader;
				nmSend.sHeader.usCRC			= ::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));

				Log(eNMTrace, false, _T("Sending START_RECORD"));
			}
			break;

			case WMNM_DB_SCREEN_OPEN	:
			case WMNM_DB_SCREEN_CLOSE	:
			case WM2NM_STOP_RECORD		:
			case WMNM_CHART_CHANGE		:
			{
				SNMHeader sHeader		=	{0};
				sHeader.usSignature	=	NM_HEADER_SIGNATURE;
				sHeader.uiCommand		=	uiCmd;
				sHeader.uiDataLength	=	0;
				sHeader.usCRC			=	::CheckSum3(&sHeader, sizeof(sHeader));

				m_sNM.SendAll(&sHeader, sizeof(sHeader));

				if(uiCmd==WM2NM_STOP_RECORD)
				{
					Log(eNMTrace, false, _T("Sending STOP_RECORD"));
				}
				else if(uiCmd==WMNM_CHART_CHANGE)
				{
					Log(eNMTrace, false, _T("Sending CHART_CHANGE"));
				}
				else if(uiCmd==WMNM_DB_SCREEN_OPEN)
				{
					Log(eNMTrace, false, _T("Sending DB_SCREEN_OPEN"));
				}
				else if(uiCmd==WMNM_DB_SCREEN_CLOSE)
				{
					Log(eNMTrace, false, _T("Sending DB_SCREEN_CLOSE"));
				}
			}
			break;

			case WM2NM_RF_START	:
			case WM2NM_RF_END		:
			case WM2NM_RELOAD_RF	:
			case WMNM_RF_DELETE_CYCLE:
			{
				if(IsNMVersion(4, 2, 0))
				{
					SNMPacket<SNMRFSession> nmSend={0};

					nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
					nmSend.sHeader.uiCommand		=	uiCmd;
					nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

					nmSend.sData.sRF					=	m_Session;
					
					if(m_Session.rf_generator>=RF_ATAKR && m_Session.rf_generator<=RF_LAST_ONE)
					{
						nmSend.sData.sRF.rf_generator	=	 m_Session.rf_generator;
					}
					else
					{
						nmSend.sData.sRF.rf_generator	=	m_INIfile.m_iRFGeneratorInstalled;
					}
					
					nmSend.sData.iMaxPower			=	m_dRF.m_iMaxPower;
					nmSend.sData.iEnergy				=	m_dRF.m_iEnergy;
					nmSend.sData.iMaxTemp			=	m_dRF.m_iMaxTemp;
					nmSend.sData.iMaxTemp2			=	m_dRF.m_iMaxProximalTemp;
					nmSend.sData.iMaxImp				=	m_dRF.m_iMaxImp;
					nmSend.sData.iPower				=	m_dRF.m_iPower;					
					nmSend.sData.iTemp				=	m_dRF.m_iTemp;
					nmSend.sData.iTemp2				=	m_dRF.m_iProximalTemp;
					nmSend.sData.iImp					=	m_dRF.m_iImp;
					if(m_vRF)
					{	
						nmSend.sData.dTimeAxis	=	m_vRF->m_dTimeAxis;
					}
					if(m_dbSession.m_pList)
					{
						nmSend.sData.iCurSession =	m_dbSession.m_pList->temp_recN;
						nmSend.sData.iMaxSessions=	m_dbSession.m_pList->total_recN;
						if (m_dRF.m_bSessionActive) {
							TCHAR pszDate[DATE_SIZE] = {0};

							// this will convert the current date to MM/DD/YYYY or DD/MM/YYYY depending
							// on our internal date format (YYYY/MM/DD maps to DD/MM/YYYY).
							CDateTime::ConvDate(pszDate, MM_DD_YYYY, theApp.m_szTodaysDate, 0.0);
							memcpy(
								nmSend.sData.date, 
								m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
								sizeof(nmSend.sData.date)
							);
						}
						else {
							memcpy(
								nmSend.sData.date, 
								m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
								sizeof(nmSend.sData.date)
							);
						}
					}

					nmSend.sData.total_RF_time		=	m_dProcedure.m_Procedure.total_RF_time;

					nmSend.sData.iTCCount			=	m_dRF.m_iTCCount;

					nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

					if(uiCmd==WM2NM_RF_START)
					{
						Log(	eNMTrace, 
								false, 
								_T("Sending WM2NM_RF_START: CRC=%u, DataLen=%u"), 
								nmSend.sHeader.usCRC, 
								nmSend.sHeader.uiDataLength);
					}
					else if(uiCmd==WM2NM_RF_END)
					{
						Log(	eNMTrace, 
								false, 
								_T("Sending WM2NM_RF_END: CRC=%u, DataLen=%u"), 
								nmSend.sHeader.usCRC, 
								nmSend.sHeader.uiDataLength);
					}
					else if(uiCmd==WM2NM_RELOAD_RF)
					{
						Log(	eNMTrace, 
								false, 
								_T("Sending WM2NM_RELOAD_RF: CRC=%u, DataLen=%u"), 
								nmSend.sHeader.usCRC, 
								nmSend.sHeader.uiDataLength);
					}
					else if(uiCmd==WMNM_RF_DELETE_CYCLE)
					{
						Log(	eNMTrace, 
								false, 
								_T("Sending WMNM_RF_DELETE_CYCLE: CRC=%u, DataLen=%u"), 
								nmSend.sHeader.usCRC, 
								nmSend.sHeader.uiDataLength);
					}

					m_sNM.SendAll(&nmSend, sizeof(nmSend));
				}
				else
				{
					SNMPacket<SNMRFSession_352> nmSend={0};

					nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
					nmSend.sHeader.uiCommand		=	uiCmd;
					nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

					nmSend.sData.sRF					=	m_Session;
					if(m_Session.rf_generator>=RF_ATAKR && m_Session.rf_generator<=RF_LAST_ONE)
					{
						nmSend.sData.sRF.rf_generator	=	 m_Session.rf_generator;
					}
					else
					{
						nmSend.sData.sRF.rf_generator	=	m_INIfile.m_iRFGeneratorInstalled;
					}
					nmSend.sData.iMaxPower			=	m_dRF.m_iMaxPower;
					nmSend.sData.iMaxTemp			=	m_dRF.m_iMaxTemp;
					nmSend.sData.iMaxTemp2			=	m_dRF.m_iMaxProximalTemp;
					nmSend.sData.iMaxImp				=	m_dRF.m_iMaxImp;
					nmSend.sData.iPower				=	m_dRF.m_iPower;
					nmSend.sData.iTemp				=	m_dRF.m_iTemp;
					nmSend.sData.iTemp2				=	m_dRF.m_iProximalTemp;
					nmSend.sData.iImp					=	m_dRF.m_iImp;
					if(m_vRF)
					{	
						nmSend.sData.dTimeAxis	=	m_vRF->m_dTimeAxis;
					}
					if(m_dbSession.m_pList)
					{
						nmSend.sData.iCurSession =	m_dbSession.m_pList->temp_recN;
						nmSend.sData.iMaxSessions=	m_dbSession.m_pList->total_recN;
						if (m_dRF.m_bSessionActive) {
							TCHAR pszDate[DATE_SIZE] = {0};

							// this will convert the current date to MM/DD/YYYY or DD/MM/YYYY depending
							// on our internal date format (YYYY/MM/DD maps to DD/MM/YYYY).
							CDateTime::ConvDate(pszDate, MM_DD_YYYY, theApp.m_szTodaysDate, 0.0);
							memcpy(
								nmSend.sData.date, 
								m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
								sizeof(nmSend.sData.date)
							);
						}
						else {
							memcpy(
								nmSend.sData.date, 
								m_dbSession.m_pList->date2[m_dbSession.m_pList->temp_recN],
								sizeof(nmSend.sData.date)
							);
						}
					}

					nmSend.sData.total_RF_time		=	m_dProcedure.m_Procedure.total_RF_time;

					nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

					m_sNM.SendAll(&nmSend, sizeof(nmSend));
				}				
			}			
			break;

			case WMNM_RF_COMMENT_CHANGE:
			{
				SNMPacket<TCHAR[RF_COMMENT_LENGTH]> nmSend	=	{0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	uiCmd;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

				::WMStrnCpy(nmSend.sData, 	CA2T((PCHAR)m_Session.comment), sizeof(nmSend.sData));

				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));
			}
			break;

			case WMNM_RF_SITE_CHANGE:
			{
				SNMPacket<TCHAR[MAX_MENU_CHARS]> nmSend	=	{0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	uiCmd;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

				::WMStrnCpy(nmSend.sData, CA2T((PCHAR)m_Session.site), sizeof(nmSend.sData));

				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));
			}
			break;

			case WMNM_RF_SUCCESS_CHANGE:
			{
				SNMPacket<USHORT> nmSend		=	{0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	uiCmd;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

				nmSend.sData						=	m_Session.success;

				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));
			}
			break;

			case NM2WM_GET_MEASUREMENTS_RESPONSE:
			{
				SNMPacket<SNMMeasure>	nmSend=	{0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	uiCmd;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

				nmSend.sData.sMeasurement		=	m_dMeas.m_Measurement;
				memcpy(nmSend.sData.meas_order, m_dCathMap.m_CathMap.meas_order, sizeof(nmSend.sData.meas_order));
		
				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));

				Log(	eNMTrace, 
						false, 
						_T("Sending NM2WM_GET_MEASUREMENTS_RESPONSE: CRC=%u, DataLen=%u"), 
						nmSend.sHeader.usCRC, 
						nmSend.sHeader.uiDataLength);
			}
			break;

			case WMNM_MEASUREMENT_COMMENT_CHANGE:
			{
				SNMPacket<SNMMeasCommentChange> nmSend	=	{0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	uiCmd;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

				nmSend.sData.iSaveMeasType		=	m_dMeas.m_iSaveMeasType;
				nmSend.sData.iSaveMeasPage		=	m_dMeas.m_iSaveMeasPage;
				::WMStrnCpy((PCHAR)nmSend.sData.szComment, 
								(PCHAR)m_dMeas.m_Measurement.measurements[m_dMeas.m_iSaveMeasType][m_dMeas.m_iSaveMeasPage].comment,
								sizeof(nmSend.sData.szComment));

				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));
			}
			break;

			case WMNM_MEASUREMENT_DELETE_ROW:
			{
				SNMPacket<long> nmSend			=	{0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	uiCmd;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

				nmSend.sData						=	MAKELONG(m_dMeas.m_iSaveMeasType, m_dMeas.m_iSaveMeasPage);

				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));
			}
			break;

			case WMNM_MEASUREMENT_S1_TO_S7:
			{
				SNMPacket<long> nmSend			=	{0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	uiCmd;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

				nmSend.sData						=	MAKELONG(m_dMeas.m_iSaveMeasType, m_dMeas.m_iSaveMeasPage);

				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));
			}
			break;

			case WMNM_UPDATE_HOLTER:
			{
				SNMPacket<SChannelConfig>	nmSend = {0};

				nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
				nmSend.sHeader.uiCommand		=	WMNM_UPDATE_HOLTER;
				nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

				nmSend.sData						=	m_dHolter.m_HolterConfig;

				nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

				m_sNM.SendAll(&nmSend, sizeof(nmSend));

				Log(eNMTrace, 
					 false, 
					 _T("Sending UPDATE_HOLTER: CRC=%u, DataLen=%u"), 
					 nmSend.sHeader.usCRC, 
					 nmSend.sHeader.uiDataLength);
			}
			break;

			default:
				break;
		}
	}
#endif
}

void CWMApp::Transmit(const UINT uiCmd, const SDrugItem& sConf)
{
#ifndef PHILIPS_VIEWER
	if(m_sNM.m_bConnected && m_INIfile.m_bNurseMateInstalled)
	{
		CSingleLock slLock(&m_ctsTransmit, TRUE);

#ifdef TEST_4_NOW
		if(IsPassiveMode())
		{
			SNMPacket<int>	nmSend = {0};

			nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
			nmSend.sHeader.uiCommand		=	WM2NM_SEND_STATE;
			nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);
			
			nmSend.sData						=	GetModeNbr();

			nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

			m_sNM.SendAll(&nmSend, sizeof(nmSend));

			Log(eNMTrace, 
				 false, 
				 _T("Sending WM2NM_SEND_STATE: CRC=%u, State=%s"), 
				 nmSend.sHeader.usCRC, 
				 (m_bActiveMode?_T("Active"):_T("Passive")));

			return; // Dont Proceed further and the state is passive.
		}
#endif

		SNMPacket<SDrugItem> nmSend			=	{0};

		nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
		nmSend.sHeader.uiCommand		=	uiCmd;
		nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

		nmSend.sData						=	sConf;

		nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

		m_sNM.SendAll(&nmSend, sizeof(nmSend));

		Log(eNMTrace, false, _T("Sending WM2NM_MARK_MEDICATION_CONF: "));
	}
#endif
}

void CWMApp::Transmit(const UINT uiCmd, const SNMLogParam& sConf)
{
#ifndef PHILIPS_VIEWER
	if(m_sNM.m_bConnected && m_INIfile.m_bNurseMateInstalled)
	{
		CSingleLock slLock(&m_ctsTransmit, TRUE);

#ifdef TEST_4_NOW
		if(IsPassiveMode())
		{
			SNMPacket<int>	nmSend = {0};

			nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
			nmSend.sHeader.uiCommand		=	WM2NM_SEND_STATE;
			nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);
			
			nmSend.sData						=	GetModeNbr();

			nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

			m_sNM.SendAll(&nmSend, sizeof(nmSend));

			Log(eNMTrace, 
				 false, 
				 _T("Sending WM2NM_SEND_STATE: CRC=%u, State=%s"), 
				 nmSend.sHeader.usCRC, 
				 (m_bActiveMode?_T("Active"):_T("Passive")));

			return; // Dont Proceed further and the state is passive.
		}
#endif

		SNMPacket<SNMLogParam> nmSend = {0};

		nmSend.sHeader.usSignature		=	NM_HEADER_SIGNATURE;
		nmSend.sHeader.uiCommand		=	uiCmd;
		nmSend.sHeader.uiDataLength	=	sizeof(nmSend.sData);

		nmSend.sData						=	sConf;

		nmSend.sHeader.usCRC				=	::CheckSum3(&nmSend.sData, sizeof(nmSend.sData));

		m_sNM.SendAll(&nmSend, sizeof(nmSend));

		Log(	eNMTrace,
				false,
				(uiCmd==WM2NM_MARK_NOTE_CONF) ?  _T("Sending WM2NM_MARK_NOTE_CONF") : _T("Sending WM2NM_MARK_EVENT_CONF"));
	}
#endif
}

void CWMApp::TransmitOTARequest(const UINT uiReuest)
{
	if (m_OTAClient.m_bConnected)
	{
		SNMHeader sHeader = { 0 };
		sHeader.usSignature = NM_HEADER_SIGNATURE;
		sHeader.uiCommand = uiReuest;
		sHeader.uiDataLength = 0;
		sHeader.usCRC = ::CheckSum3(&sHeader, sizeof(sHeader));

		m_OTAClient.Send(&sHeader, sizeof(sHeader));
	}
}

LPTSTR CWMApp::MakePrintFileName(PTCHAR szPrintFile, const int iSize)
{	
	memset(szPrintFile, 0, iSize);

	TCHAR szTemp[MAX_PATH]={0};

   for(register USHORT usIndex=1; usIndex<MAXWORD; usIndex++)
	{
		_stprintf(szTemp, _T("WMPRINT%4.4X.JPG"), usIndex);

		m_dLog.MakeLogName(szTemp, szPrintFile, iSize);

      if(!CFileDB::IsExists(szPrintFile))
		{
			break;
		}
   }

	return szPrintFile;
}

bool CWMApp::HasSignals(void)
{
	TCHAR szFullPath[MAX_PATH]={0};
	return ( CFileDB::IsExists(m_dLog.MakeLogName(m_szBaseLogName, szFullPath, sizeof(szFullPath))) && 
				(m_dReview.m_rppReview.max_channelN>0) );
}

int CWMApp::Run() 
{
	CMessage::m_bPumpStarted = true;

#ifdef MESSAGE_TEST
	CMessage::RunTest();
#endif
	
	return CWinApp::Run();
}

void CWMApp::Log(const eTrace eTrc, bool bConnection, LPCTSTR szFormat, ...)
{
#ifndef PHILIPS_VIEWER
	if(CWMLibrary::IsSafeWindow(m_pTrace))
	{
		STrace sTrace = { eTrc, bConnection };

		va_list vaList;
		va_start(vaList, szFormat);
		_vstprintf(sTrace.szMessage, szFormat, vaList);
		va_end(vaList);

		::SendMessage(	m_pTrace->GetSafeHwnd(), 
							WM_TRACE_LOG, 
							0, 
							(LPARAM)&sTrace);
	}
#endif
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::LogAuditTrail()

	Description	:	This function traces all the user's logins and logouts to 
						a AuditTrail.log file in the Application's working folder.

	Returns		:	None

	Setup			:	1. Launch the WorkMate application.

	Testing		:	1. Press the Begin/Review Study button and verify the login window
							displays.
						2. Select the user and enter the password. Verify the system allows
							the user login.
						3.	Press the Exit button on the mainbar and verify the AuditTrail.log
							file traces the user name.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::LogAuditTrail(SYSTEMTIME& sysTime, SLogin& sLogin, bool bIn)
{
	TCHAR szFullPath[MAX_PATH]={0};
	MakePath(_T("AuditTrail.log"), szFullPath, sizeof(szFullPath));

	HANDLE hAuditTrail =::CreateFile(szFullPath, 
												GENERIC_READ|GENERIC_WRITE, 
												FILE_SHARE_READ, 
												NULL, 
												OPEN_ALWAYS, 
												FILE_ATTRIBUTE_HIDDEN, 
												NULL);

	if(hAuditTrail && hAuditTrail!=INVALID_HANDLE_VALUE)
	{
		const DWORD dwSize = ::GetFileSize(hAuditTrail, NULL);
		
		if(dwSize!=MAXDWORD)
		{
			::SetFilePointer(hAuditTrail, dwSize, NULL, FILE_BEGIN);

			CStringA csUser;
			CStringA csMesg;
			CString csPrivilege;
			GetUserPrivilege(sLogin.uiPrivilege, csPrivilege);

			csUser.Format(("User: %s, Privilege: %s, Logged: %s"), 
								sLogin.szUserName, 
								CStringA(csPrivilege), 
								bIn?("IN"):("OUT"));

			csMesg.Format(	("[%.2d-%.2d-%.4d %.2d:%.2d:%.2d.%.3d] [%s]\r\n"), 
								sysTime.wMonth, 
								sysTime.wDay, 
								sysTime.wYear, 
								sysTime.wHour, 
								sysTime.wMinute, 
								sysTime.wSecond, 
								sysTime.wMilliseconds, 
								csUser);

			DWORD dwWrite = csMesg.GetLength();
			DWORD dwWritten=	0UL;

			::WriteFile(hAuditTrail, (LPCSTR)csMesg, dwWrite, &dwWritten, NULL);
		}

		::CloseHandle(hAuditTrail);

		hAuditTrail = INVALID_HANDLE_VALUE;
	}
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::LogAuditTrail()

	Description	:	This function traces all the user's logins attempt failures to 
						the AuditTrail.log file in the Application working folder.

	Returns		:	None

	Setup			:	1. Launch the WorkMate application.

	Testing		:	1. Press the Begin/Review Study button and verify the login window
							displays.
						2. Enter an invalid user name and password. Verify the system does NOT
							allows the user to login.
						3.	Press the Exit button on the mainbar and verify the AuditTrail.log
							file traces the user name.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
void CWMApp::LogAuditTrail(SYSTEMTIME& sysTime, LPCTSTR szUserName)
{
	TCHAR szFullPath[MAX_PATH]={0};
	MakePath(_T("AuditTrail.log"), szFullPath, sizeof(szFullPath));

	HANDLE hAuditTrail =::CreateFile(szFullPath, 
												GENERIC_READ|GENERIC_WRITE, 
												FILE_SHARE_READ, 
												NULL, 
												OPEN_ALWAYS, 
												FILE_ATTRIBUTE_HIDDEN, 
												NULL);

	if(hAuditTrail && hAuditTrail!=INVALID_HANDLE_VALUE)
	{
		const DWORD dwSize = ::GetFileSize(hAuditTrail, NULL);
		
		if(dwSize!=MAXDWORD)
		{
			::SetFilePointer(hAuditTrail, dwSize, NULL, FILE_BEGIN);

			CStringA csUser;
			CStringA csMesg;

			csUser.Format("User: %s, Login Attempt Failed", CStringA(CString(szUserName)).GetBuffer());

			csMesg.Format("[%.2d-%.2d-%.4d %.2d:%.2d:%.2d.%.3d] [%s]\r\n",
								sysTime.wMonth, 
								sysTime.wDay, 
								sysTime.wYear, 
								sysTime.wHour, 
								sysTime.wMinute, 
								sysTime.wSecond, 
								sysTime.wMilliseconds, 
								csUser.GetBuffer());

			DWORD dwWrite	=	csMesg.GetLength();
			DWORD dwWritten=	0UL;

			::WriteFile(hAuditTrail, (LPCSTR)csMesg, dwWrite, &dwWritten, NULL);
		}

		::CloseHandle(hAuditTrail);

		hAuditTrail = INVALID_HANDLE_VALUE;
	}
}

/*-------------------------------------------------------------------------
	Function Name	:	CWMApp::GetUserPrivilege()

	Description	:	This function reads the privileges by the bit wise format 
						and concatenates to the passed string.

	Returns		:	None

	Setup			:	1. Launch the WorkMate application.

	Testing		:	1. Press the Begin/Review Study button and verify the login window
							displays.
						2. Press the Admin button and enter the password. Verify the 
							Administrator window displays.
						3.	Press the Create button and verify the User window displays.
						4. Create a username with password, check on the privileges and
							press the Save button. Verify the user is created in the list
							control of the Admin window and the privileges are shown under 
							the Privileges column.

Software Version:_______	Date:_______	Initials:___	All Tests Passed:	Yes		No
-------------------------------------------------------------------------*/
LPCTSTR CWMApp::GetUserPrivilege(UINT uiPrivilege, CString& csPrivilege)
{
	csPrivilege.Empty();

	bool bAppendDash = false;

	if(uiPrivilege & USER_PRIVILEGE_ADD_EDIT)
	{
		csPrivilege = _T("A");

		bAppendDash = true;
	}

	if(uiPrivilege & USER_PRIVILEGE_DELETE)
	{
		if(bAppendDash)	{	csPrivilege += _T("-");	}

		csPrivilege += _T("D");

		bAppendDash = true;
	}

	if(uiPrivilege & USER_PRIVILEGE_VIEW)
	{
		if(bAppendDash)	{	csPrivilege += _T("-");	}

		csPrivilege += _T("V");

		bAppendDash = true;
	}

	if(uiPrivilege & USER_PRIVILEGE_EDIT_PREVIOUS)
	{
		if(bAppendDash)	{	csPrivilege += _T("-");	}

		csPrivilege += _T("P");

		bAppendDash = true;
	}

	if(uiPrivilege & USER_PRIVILEGE_CONFIG)
	{
		if(bAppendDash)	{	csPrivilege += _T("-");	}

		csPrivilege += _T("C");

		bAppendDash = true;
	}

	if(uiPrivilege & USER_PRIVILEGE_APPROVE_REPORT)
	{
		if(bAppendDash)	{	csPrivilege += _T("-");	}

		csPrivilege += _T("R");

		bAppendDash = true;
	}

	if(uiPrivilege==USER_PRIVILEGE_NONE)
	{
		csPrivilege = GETMESSAGE(2115);
	}

	return csPrivilege;
}

void CWMApp::Logout(void)
{
	// Prompt user before closing ALL LibreOffice documents and saving them AS-IS
	// Since Logout() calls ExitWorkMate() when LEAVE_ALONE > 0
	// This is still necessary to be called before, because:
	//		1. Prompt should appear before CLoginDialog popup which invokes ExitWorkMate()
	//		2. Active reports if open should not be accessible to another user in the same instance
	if(m_INIfile.m_iDBAccessMode != DISABLE_PASSWORDS)
	{
		HWND hWndMain = ::AfxGetMainWnd()->GetSafeHwnd();
		if (CReport::FindLibreOfficeWriter(hWndMain)) {
			if (CMessage::YesNo(WMFILELINE, 3181) == IDNO) {
				return;
			}
			try
			{
				AFX_THREADPROC ExitLoFunc = [](LPVOID pParam)->UINT {
					CLibreOfficeWriter::Instance()->FreeApp();
					return EXIT_SUCCESS;
				};
				::AfxBeginThread(ExitLoFunc, NULL);
			}
			catch (const _com_error& e)
			{
				CMessage::m_erLog.ReportError(e.ErrorMessage());
			}
		}

	#if defined(ALLURA_TSM) && !defined(PHILIPS_VIEWER)
		// Disable all the Allura TSM buttons.
		EPWM_BUTTON_STATE_RECORDING_TYPE			lPrevRecord			=	EPWM_BUTTON_STATE_RECORDING_DEFAULT;
		EPWM_BUTTON_STATE_RECORDPAST_TYPE		lPrevRecordPast	=	EPWM_BUTTON_STATE_RECORDPAST_DEFAULT;
		EPWM_BUTTON_STATE_SAVEIMAGE_TYPE			lPrevSaveImage		=	EPWM_BUTTON_STATE_ADDMAPPOINT_DEFAULT;
		EPWM_BUTTON_STATE_ADDMAPPOINT_TYPE		lPrevAddMapPoint	=	EPWM_BUTTON_STATE_MARKEVENT_DEFAULT;
		EPWM_BUTTON_STATE_MARKEVENT_TYPE			lPrevMarkEvent		=	EPWM_BUTTON_STATE_MARKEVENT_DEFAULT;
		EPWM_BUTTON_STATE_EVENTS_SUBMENU_TYPE	lPrevEventsSubMenu=	EPWM_BUTTON_STATE_SIGNALS_SUBMENU_DEFAULT;
		EPWM_BUTTON_STATE_SIGNALS_SUBMENU_TYPE	lPrevSignalsSubMenu=	EPWM_BUTTON_STATE_SIGNALS_SUBMENU_DEFAULT;
		EPWM_BUTTON_STATE_TIMER_SUBMENU_TYPE	lPrevTimerSubMenu	=	EPWM_BUTTON_STATE_TIMER_SUBMENU_DEFAULT;
		EPWM_BUTTON_STATE_PRINT_SUBMENU_TYPE	lPrevPrintSubMenu	=	EPWM_BUTTON_STATE_PRINT_SUBMENU_DEFAULT;
		EPWM_BUTTON_STATE_EVENT1_TYPE				lPrevEvent1			=	EPWM_BUTTON_STATE_EVENT1_DEFAULT;
		EPWM_BUTTON_STATE_EVENT2_TYPE				lPrevEvent2			=	EPWM_BUTTON_STATE_EVENT2_DEFAULT;
		EPWM_BUTTON_STATE_EVENT3_TYPE				lPrevEvent3			=	EPWM_BUTTON_STATE_EVENT3_DEFAULT;
		EPWM_BUTTON_STATE_EVENT4_TYPE				lPrevEvent4			=	EPWM_BUTTON_STATE_EVENT4_DEFAULT;
		EPWM_BUTTON_STATE_EVENT5_TYPE				lPrevEvent5			=	EPWM_BUTTON_STATE_EVENT5_DEFAULT;
		EPWM_BUTTON_STATE_EVENT6_TYPE				lPrevEvent6			=	EPWM_BUTTON_STATE_EVENT6_DEFAULT;
		EPWM_BUTTON_STATE_EVENT7_TYPE				lPrevEvent7			=	EPWM_BUTTON_STATE_EVENT7_DEFAULT;
		EPWM_BUTTON_STATE_EVENT8_TYPE				lPrevEvent8			=	EPWM_BUTTON_STATE_EVENT8_DEFAULT;
		EPWM_BUTTON_STATE_EVENT9_TYPE				lPrevEvent9			=	EPWM_BUTTON_STATE_EVENT9_DEFAULT;
		EPWM_BUTTON_STATE_EVENT10_TYPE			lPrevEvent10		=	EPWM_BUTTON_STATE_EVENT10_DEFAULT;
		EPWM_BUTTON_STATE_SPEEDUP_TYPE			lPrevSpeedUp		=	EPWM_BUTTON_STATE_SPEEDUP_DEFAULT;
		EPWM_BUTTON_STATE_SPEEDDOWN_TYPE			lPrevSpeedDown		=	EPWM_BUTTON_STATE_SPEEDDOWN_DEFAULT;
		EPWM_BUTTON_STATE_PAGEUP_TYPE				lPrevPageUp			=	EPWM_BUTTON_STATE_PAGEUP_DEFAULT;
		EPWM_BUTTON_STATE_PAGEDOWN_TYPE			lPrevPageDown		=	EPWM_BUTTON_STATE_PAGEDOWN_DEFAULT;
		EPWM_BUTTON_STATE_AMPLITUDEUP_TYPE		lPrevAmpUp			=	EPWM_BUTTON_STATE_AMPLITUDEUP_DEFAULT;
		EPWM_BUTTON_STATE_AMPLITUDEDOWN_TYPE	lPrevAmpDown		=	EPWM_BUTTON_STATE_AMPLITUDEDOWN_DEFAULT;
		EPWM_BUTTON_STATE_TIMER_TYPE				lPrevTimer			=	EPWM_BUTTON_STATE_TIMER_DEFAULT;
		EPWM_BUTTON_STATE_TIMERRESET_TYPE		lPrevTimerReset	=	EPWM_BUTTON_STATE_TIMERRESET_DEFAULT;
		EPWM_BUTTON_STATE_TIMERCLOSE_TYPE		lPrevTimerClose	=	EPWM_BUTTON_STATE_TIMERCLOSE_DEFAULT;
		EPWM_BUTTON_STATE_PRINTREAL12_TYPE		lPrevPrintReal12	=	EPWM_BUTTON_STATE_PRINTREAL12_DEFAULT;
		EPWM_BUTTON_STATE_PRINTREVIEW_TYPE		lPrevReview			=	EPWM_BUTTON_STATE_PRINTREVIEW_DEFAULT;
		EPWM_BUTTON_STATE_PRINTREV12_TYPE		lPrevReview12		=	EPWM_BUTTON_STATE_PRINTREV12_DEFAULT;

		m_TSM.GetButtonState(lPrevRecord,
									lPrevRecordPast,	
									lPrevSaveImage,	
									lPrevAddMapPoint,
									lPrevMarkEvent,
									lPrevEventsSubMenu,
									lPrevSignalsSubMenu,
									lPrevTimerSubMenu,
									lPrevPrintSubMenu,
									lPrevEvent1,
									lPrevEvent2,
									lPrevEvent3,
									lPrevEvent4,
									lPrevEvent5,
									lPrevEvent6,
									lPrevEvent7,
									lPrevEvent8,
									lPrevEvent9,
									lPrevEvent10,
									lPrevSpeedUp,
									lPrevSpeedDown,
									lPrevPageUp,
									lPrevPageDown,
									lPrevAmpUp,
									lPrevAmpDown,
									lPrevTimer,
									lPrevTimerReset,
									lPrevTimerClose,
									lPrevPrintReal12,
									lPrevReview,
									lPrevReview12);


		m_TSM.SetButtonState(lPrevRecord==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevRecordPast==EPWM_INVISIBLE_STATE ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,	
									lPrevSaveImage==EPWM_INVISIBLE_STATE ?		EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,	
									lPrevAddMapPoint==EPWM_INVISIBLE_STATE ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevMarkEvent==EPWM_INVISIBLE_STATE ?		EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevEventsSubMenu==EPWM_INVISIBLE_STATE?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevSignalsSubMenu==EPWM_INVISIBLE_STATE?EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevTimerSubMenu==EPWM_INVISIBLE_STATE ? EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevPrintSubMenu==EPWM_INVISIBLE_STATE ? EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevEvent1==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevEvent2==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevEvent3==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevEvent4==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevEvent5==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevEvent6==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevEvent7==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevEvent8==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevEvent9==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevEvent10==EPWM_INVISIBLE_STATE ?		EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevSpeedUp==EPWM_INVISIBLE_STATE ?		EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevSpeedDown==EPWM_INVISIBLE_STATE ?		EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevPageUp==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevPageDown==EPWM_INVISIBLE_STATE ?		EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevAmpUp==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevAmpDown==EPWM_INVISIBLE_STATE ?		EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevTimer==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevTimerReset==EPWM_INVISIBLE_STATE ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevTimerClose==EPWM_INVISIBLE_STATE ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevPrintReal12==EPWM_INVISIBLE_STATE ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevReview==EPWM_INVISIBLE_STATE ?			EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE,
									lPrevReview12==EPWM_INVISIBLE_STATE ?		EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE);

	#endif

		SYSTEMTIME sysTime={0}; ::GetLocalTime( &sysTime );
		LogAuditTrail(sysTime, m_sLogin, false);
		SLogin sPrevLogin = m_sLogin;
		m_dbLogin.FreeRecord();

		// Get the Login
		CLoginDialog lgDialog(m_fMain, sysTime);
		
		if(lgDialog.DoModal()!=IDOK)
		{
			// Since we called m_dbLogin.FreeRecord() above, we need to pull it back.
			if(sPrevLogin.szUserName[0])
			{
				m_dbLogin.InitRecord();
				::strncpy((PCHAR)m_dbLogin.m_pIndex->key1, 
								(PCHAR)sPrevLogin.szUserName, 
								m_dbLogin.m_pIndex->key1_length);
				m_dbLogin.GetRecord(GET_FROM_INDEX, LOCK_EDIT, 9999);
			}

			ExitWorkMate(true);
			m_dbLogin.FreeRecord();
			return;
		}

		DisableOnViewOnly();

	#if defined(ALLURA_TSM) && !defined(PHILIPS_VIEWER)
		// Enable them according to the state.

		if(m_INIfile.m_iDBAccessMode!=DISABLE_PASSWORDS)
		{
			if(m_sLogin.uiPrivilege & USER_PRIVILEGE_VIEW)
			{
				lPrevRecord		= (lPrevRecord==EPWM_INVISIBLE_STATE)		?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevRecordPast= (lPrevRecordPast==EPWM_INVISIBLE_STATE)	?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;	
				lPrevSaveImage = (lPrevSaveImage==EPWM_INVISIBLE_STATE)	?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;	
				lPrevAddMapPoint=(lPrevAddMapPoint==EPWM_INVISIBLE_STATE)?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevMarkEvent	= (lPrevMarkEvent==EPWM_INVISIBLE_STATE)	?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevEventsSubMenu=(lPrevEventsSubMenu==EPWM_INVISIBLE_STATE)?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevEvent1		=	(lPrevEvent1==EPWM_INVISIBLE_STATE) ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevEvent2		=	(lPrevEvent2==EPWM_INVISIBLE_STATE) ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevEvent3		=	(lPrevEvent3==EPWM_INVISIBLE_STATE) ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevEvent4		=	(lPrevEvent4==EPWM_INVISIBLE_STATE) ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevEvent5		=	(lPrevEvent5==EPWM_INVISIBLE_STATE) ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevEvent6		=	(lPrevEvent6==EPWM_INVISIBLE_STATE) ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevEvent7		=	(lPrevEvent7==EPWM_INVISIBLE_STATE) ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevEvent8		=	(lPrevEvent8==EPWM_INVISIBLE_STATE) ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevEvent9		=	(lPrevEvent9==EPWM_INVISIBLE_STATE) ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
				lPrevEvent10	=	(lPrevEvent10==EPWM_INVISIBLE_STATE) ?	EPWM_INVISIBLE_STATE : EPWM_DISABLE_STATE;
			}
			else
			{
				lPrevRecord			=	EPWM_ENABLE_STATE;
				lPrevRecordPast	=	EPWM_ENABLE_STATE;	
				lPrevSaveImage		=	(m_dCine.GetInterrupt()) ? EPWM_ENABLE_STATE : EPWM_DISABLE_STATE;
				lPrevAddMapPoint	=	EPWM_ENABLE_STATE;
				lPrevMarkEvent		=	EPWM_ENABLE_STATE;
				lPrevEventsSubMenu=	EPWM_ENABLE_STATE;
				lPrevEvent1			=	EPWM_BUTTON_STATE_EVENT1_DEFAULT;
				lPrevEvent2			=	EPWM_BUTTON_STATE_EVENT2_DEFAULT;
				lPrevEvent3			=	EPWM_BUTTON_STATE_EVENT3_DEFAULT;
				lPrevEvent4			=	EPWM_BUTTON_STATE_EVENT4_DEFAULT;
				lPrevEvent5			=	EPWM_BUTTON_STATE_EVENT5_DEFAULT;
				lPrevEvent6			=	EPWM_BUTTON_STATE_EVENT6_DEFAULT;
				lPrevEvent7			=	EPWM_BUTTON_STATE_EVENT7_DEFAULT;
				lPrevEvent8			=	EPWM_BUTTON_STATE_EVENT8_DEFAULT;
				lPrevEvent9			=	EPWM_BUTTON_STATE_EVENT9_DEFAULT;
				lPrevEvent10		=	EPWM_BUTTON_STATE_EVENT10_DEFAULT;
			}
		}
		
		m_TSM.SetButtonState(lPrevRecord,
									lPrevRecordPast,	
									lPrevSaveImage,	
									lPrevAddMapPoint,
									lPrevMarkEvent,
									lPrevEventsSubMenu,
									lPrevSignalsSubMenu,
									lPrevTimerSubMenu,
									lPrevPrintSubMenu,
									lPrevEvent1,
									lPrevEvent2,
									lPrevEvent3,
									lPrevEvent4,
									lPrevEvent5,
									lPrevEvent6,
									lPrevEvent7,
									lPrevEvent8,
									lPrevEvent9,
									lPrevEvent10,
									lPrevSpeedUp,
									lPrevSpeedDown,
									lPrevPageUp,
									lPrevPageDown,
									lPrevAmpUp,
									lPrevAmpDown,
									lPrevTimer,
									lPrevTimerReset,
									lPrevTimerClose,
									lPrevPrintReal12,
									lPrevReview,
									lPrevReview12);
	#endif
	}
}

LPCTSTR CWMApp::MakeECGPath(LPCTSTR szFile, PTCHAR szFullName, size_t uiSize)
{
	TCHAR szPath[MAX_PATH]={0};

	MakePath(_T("ECGS"), szPath, sizeof(szPath));

	if( !CFileDB::IsExists(szPath) )
	{
		CWMLibrary::CreateDirectory(szPath);
	}

	return CFileDB::MakeFileName(szPath, szFile, szFullName, uiSize);
}

int CWMApp::PushWindow(const HWND& hWnd)
{
	m_arTop[m_iTopLevel] = hWnd;

	if(++m_iTopLevel>=ARRAY_SIZE(m_arTop))
	{
		m_iTopLevel = 0;
	}

	return m_iTopLevel;
}

void CWMApp::PopWindow(void)
{
	if(m_iTopLevel>0 && m_iTopLevel<ARRAY_SIZE(m_arTop))
	{
		m_arTop[m_iTopLevel] = NULL;
				
		if(--m_iTopLevel<0)
		{
			m_iTopLevel = 0;
		}
	}
}

void CWMApp::ReloadFromWorkMate(const SNMDBRecord_110& rDB)
{
	const long file_number	= m_dReview.m_rppReview.file_number;
	const long file_position= m_dReview.m_rppReview.file_position;

	const long prev_file_number	= m_dPrevReview.m_rppReview.file_number;
	const long prev_file_position	= m_dPrevReview.m_rppReview.file_position;

	const short iPrevViewLogLine = m_vLog->m_iViewLogLine;

	_locale_t myLocale;
	myLocale = _create_locale(LC_CTYPE, ".1252");

	if ((rDB.sProcedure.log_dir_number != m_dProcedure.m_Procedure.log_dir_number) ||
		(::_strnicmp_l((PCHAR)m_dPatient.m_Patient.name, (PCHAR)rDB.sPatient.name, ARRAY_SIZE(m_dPatient.m_Patient.name), myLocale) != 0) ||
		(::_strnicmp_l((PCHAR)m_dPatient.m_Patient.id, (PCHAR)rDB.sPatient.id, ARRAY_SIZE(m_dPatient.m_Patient.id), myLocale) != 0))
	{
		// The WM and NM are out of Sync.

#ifdef _DEBUG
		// Display an assertion in the debug mode
		CMessage::PopupMessage(	WMFILELINE, _T("NurseMate Database & Study data is Out of Sync."));
		WMASSERT(0);
#endif

		// Send the current study to the NM.
		
		m_MainBar.PostMessage(WM_SEND_PATIENT_CHANGE, 0, 0);
		return;
	}

	const SPatient		sOrgPatient		=	m_dPatient.m_Patient;
	const SProcedure	sOrgProcedure	=	m_dProcedure.m_Procedure;
	const SProcedure2 sOrgProcedure2	=	m_dProcedure.m_Procedure2;

	m_dPatient.m_Patient			=	rDB.sPatient;
	m_dProcedure.m_Procedure	=	rDB.sProcedure;
	memcpy(&m_dProcedure.m_Procedure2, &rDB.sProcedure2, sizeof(rDB.sProcedure2));
	m_dMeas.m_Measurement		=	rDB.sMeas.sMeasurement;

	// Retain the read only settinlog directory number	
	// 1. Patient Name
	::strncpy((PCHAR)m_dPatient.m_Patient.name,
					(PCHAR)sOrgPatient.name, 
					ARRAY_SIZE(m_dPatient.m_Patient.name));

	// 2. Patient Id
	::strncpy((PCHAR)m_dPatient.m_Patient.id,
					(PCHAR)sOrgPatient.id, 
					ARRAY_SIZE(m_dPatient.m_Patient.id));

	// 3. Study Instance UID
	::strncpy((PCHAR)m_dProcedure.m_Procedure2.szStudyInstanceUId,
					(PCHAR)sOrgProcedure2.szStudyInstanceUId, 
					ARRAY_SIZE(m_dProcedure.m_Procedure2.szStudyInstanceUId));
	
	m_dProcedure.m_Procedure2.sSUID = sOrgProcedure2.sSUID;

	// 4. Catalog Number
	m_dProcedure.m_Procedure.log_dir_number = sOrgProcedure.log_dir_number;

	// 5. Study Date
	::strncpy((PCHAR)m_dProcedure.m_Procedure.date,
					(PCHAR)sOrgProcedure.date, 
					ARRAY_SIZE(m_dProcedure.m_Procedure.date));

	// 6. Archive Disk Name
	::strncpy((PCHAR)m_dProcedure.m_Procedure.tape_name,
					(PCHAR)sOrgProcedure.tape_name, 
					ARRAY_SIZE(m_dProcedure.m_Procedure.tape_name));

	if(m_vDB)
	{
		m_vDB->DataToGUIExchange();

		m_dPatient.StoreAllPatientData();

		//m_dPrevReview.m_rppReview.Reset();
		m_dPrevReview.m_rppReview.file_number	= prev_file_number;
		m_dPrevReview.m_rppReview.file_position= prev_file_position;

		m_dPrevReview.GetCurrentLogPage();
		m_vPrevReview->InvalidateView();
		DrawReviewScrollKnob(ePrevReview, m_dPrevReview.m_rppReview);

		//m_dReview.m_rppReview.Reset();
		m_dReview.m_rppReview.file_number = file_number;
		m_dReview.m_rppReview.file_position= file_position;

		m_dReview.GetCurrentLogPage();
		m_vReview->InvalidateView();
		DrawReviewScrollKnob(eReview, m_dReview.m_rppReview);

		m_dLog.GetLogEntries();
		m_dLog.CreateLogEntriesMenu(true); // because it was changed above
		m_vLog->DrawLogEntries(true);

		m_vLog->SetSelection(iPrevViewLogLine);
		Log(eNMTrace, false, _T("iPrevViewLogLine:%d"), iPrevViewLogLine);

		m_dChart.GetChartEntries();
		m_dChart.CreateChartEntriesMenu(true); // because it was changed above
		m_vChart->DrawChartEntries(true);
	}
}

void CWMApp::ReloadFromWorkMate(const SNMDBRecord& rDB)
{
	const long file_number	= m_dReview.m_rppReview.file_number;
	const long file_position= m_dReview.m_rppReview.file_position;

	const long prev_file_number	= m_dPrevReview.m_rppReview.file_number;
	const long prev_file_position	= m_dPrevReview.m_rppReview.file_position;

	const short iPrevViewLogLine	= m_vLog->m_iViewLogLine;

	_locale_t myLocale;
	myLocale = _create_locale(LC_CTYPE, ".1252");

	if((rDB.sProcedure.log_dir_number!=m_dProcedure.m_Procedure.log_dir_number)								||
		(_strnicmp_l((PCHAR)m_dPatient.m_Patient.name, (PCHAR)rDB.sPatient.name, sizeof(m_dPatient.m_Patient.name), myLocale)!=0)	||
		(_strnicmp_l((PCHAR)m_dPatient.m_Patient.id, (PCHAR)rDB.sPatient.id, sizeof(m_dPatient.m_Patient.id), myLocale)!=0)	)
	{
		// The WM and NM are out of Sync.

#ifdef _DEBUG
		// Display an assertion in the debug mode
		CMessage::PopupMessage(	WMFILELINE, _T("NurseMate Database & Study data is Out of Sync."));
#endif

		// Send the current study to the NM.
		
		m_MainBar.PostMessage(WM_SEND_PATIENT_CHANGE, 0, 0);
		return;
	}

	const SPatient		sOrgPatient		=	m_dPatient.m_Patient;
	const SProcedure	sOrgProcedure	=	m_dProcedure.m_Procedure;
	const SProcedure2 sOrgProcedure2	=	m_dProcedure.m_Procedure2;

	if (rDB.nViewModelKey == ViewModelKeyCount) {
		m_dPatient.m_Patient			=	rDB.sPatient;
		m_dProcedure.m_Procedure	=	rDB.sProcedure;
		m_dProcedure.m_Procedure2	=	rDB.sProcedure2;
		m_dMeas.m_Measurement		=	rDB.sMeas.sMeasurement;
		m_dProcedure.m_PrePost		=	rDB.sPrePost;
	}
	else {
		CDatabaseViewModel& databaseViewModel = CDatabaseViewModel::GetDatabaseViewModel(rDB.nViewModelKey);
		databaseViewModel.MoveViewModel(rDB);

		if ((this->m_fDB != NULL) && (this->m_fDB->IsWindowVisible()) && (this->m_vDB != NULL)) {
			CTabDialog* pTabDialog = this->m_vDB->GetActiveChild();

			if ((pTabDialog != NULL) && (pTabDialog->GetViewModelKey() == rDB.nViewModelKey)) {
				pTabDialog->LoadViewModel();
			}
			else {
				pTabDialog->GUIToDataExchange();
			}
		}

		// [hkc:11.24.2012]:
		//
		// Don't persist view-model updates to disk immediately.  We will write
		// out the entire database when the database window is closed.

		return;
	}

	// Retain the read only settinlog directory number	
	// 1. Patient Name
	::strncpy((PCHAR)m_dPatient.m_Patient.name,
					(PCHAR)sOrgPatient.name, 
					ARRAY_SIZE(m_dPatient.m_Patient.name));

	// 2. Patient Id
	::strncpy((PCHAR)m_dPatient.m_Patient.id,
					(PCHAR)sOrgPatient.id, 
					ARRAY_SIZE(m_dPatient.m_Patient.id));

	// 3. Study Instance UID
	::strncpy((PCHAR)m_dProcedure.m_Procedure2.szStudyInstanceUId,
					(PCHAR)sOrgProcedure2.szStudyInstanceUId, 
					ARRAY_SIZE(m_dProcedure.m_Procedure2.szStudyInstanceUId));
	
	m_dProcedure.m_Procedure2.sSUID = sOrgProcedure2.sSUID;

	// 4. Catalog Number
	m_dProcedure.m_Procedure.log_dir_number = sOrgProcedure.log_dir_number;

	// 5. Study Date
	::strncpy((PCHAR)m_dProcedure.m_Procedure.date,
					(PCHAR)sOrgProcedure.date, 
					ARRAY_SIZE(m_dProcedure.m_Procedure.date));

	// 6. Archive Disk Name
	::strncpy((PCHAR)m_dProcedure.m_Procedure.tape_name,
					(PCHAR)sOrgProcedure.tape_name, 
					ARRAY_SIZE(m_dProcedure.m_Procedure.tape_name));

	if(m_vDB)
	{
		m_dPatient.StoreAllPatientData();

		//m_dPrevReview.m_rppReview.Reset();
		m_dPrevReview.m_rppReview.file_number	= prev_file_number;
		m_dPrevReview.m_rppReview.file_position= prev_file_position;

		m_dPrevReview.GetCurrentLogPage();
		m_vPrevReview->InvalidateView();
		DrawReviewScrollKnob(ePrevReview, m_dPrevReview.m_rppReview);

		//m_dReview.m_rppReview.Reset();
		m_dReview.m_rppReview.file_number = file_number;
		m_dReview.m_rppReview.file_position= file_position;

		m_dReview.GetCurrentLogPage();
		m_vReview->InvalidateView();
		DrawReviewScrollKnob(eReview, m_dReview.m_rppReview);

		m_dLog.GetLogEntries();
		m_dLog.CreateLogEntriesMenu(true); // because it was changed above
		m_vLog->DrawLogEntries(true);

		m_vLog->SetSelection(iPrevViewLogLine);
		Log(eNMTrace, false, _T("iPrevViewLogLine:%d"), iPrevViewLogLine);

		m_dChart.GetChartEntries();
		m_dChart.CreateChartEntriesMenu(true); // because it was changed above
		m_vChart->DrawChartEntries(true);
	}

	if(CWMLibrary::IsSafeWindow(m_MainBar))
	{
		m_MainBar.SetDrugIcon();
	}
}

bool CWMApp::IsOptionLicensed(const short iOption)
{
	switch(iOption)
	{
		case WM_LICENSE_FFT	:	
		{
			return true;
		}
		
		case WM_LICENSE_CARTO:
		{
			return false;
		}
		
		case WM_LICENSE_DICOM:
		{
			return m_sLicense.arbOptions[WM_LICENSE_DICOM];
		}
				
		case WM_LICENSE_CATHMAP:
		{
			return true; 
		}
		
	}

	return false;
}

void CWMApp::ValidateLicensing(void)
{
	TCHAR szFullPath[MAX_PATH]={0};
	MakePath(WM_LICENSE_FILE_NAME, szFullPath, sizeof(szFullPath));

	bool bExists = CFileDB::IsExists(szFullPath);

	bool bSuccess = bExists;

	if(bSuccess)
	{
		::SetFileAttributes(szFullPath, FILE_ATTRIBUTE_NORMAL);

		HANDLE hFile = ::CreateFile(szFullPath, 
											 GENERIC_READ, 
											 0, 
											 NULL, 
											 OPEN_EXISTING, 
											 FILE_ATTRIBUTE_NORMAL, 
											 NULL);

		bSuccess = ( (hFile!=NULL) && (hFile!=INVALID_HANDLE_VALUE) );

		if(bSuccess)
		{
			DWORD dwPos = ::SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

			SFileRecord<SLicense> sRecord = {0};

			DWORD dwRead	=	0U;
			bSuccess =	(::ReadFile(hFile, &sRecord, sizeof(sRecord), &dwRead, NULL)==TRUE);

			if(bSuccess)
			{
				bSuccess = ((dwRead==sizeof(sRecord)) && 
								(sRecord.ucCRC==::CheckSum5((PUCHAR)&sRecord.sData, sizeof(sRecord.sData))) );

				if(bSuccess)
				{
					m_sLicense = sRecord.sData;

					if(::_strnicmp((PCHAR)m_sLicense.szAppName, "WorkMate Claris", _countof(m_sLicense.szAppName))==0)
					{
						m_sLicense.arbOptions[WM_LICENSE_CATHMAP] = true;

						if(m_sLicense.arbOptions[WM_LICENSE_CARTO])	
						{
							m_sLicense.arbOptions[WM_LICENSE_CARTO] = false;
						}
						
						if(m_INIfile.m_usMappingSystemInstalled==MAPPING_SYSTEM_CARTO)
						{
							CString	csMesg;
							csMesg.Format(_T("%s\r\n%s"), GETMESSAGE(1797), GETMESSAGE(1794));

							CMessage::StartupMessage(WMFILELINE, 0, csMesg, true, true);
							m_INIfile.m_usMappingSystemInstalled=MAPPING_SYSTEM_NONE;

							m_INIfile.PutConfig();
						}
						
						if(!m_sLicense.arbOptions[WM_LICENSE_DICOM])	
						{
							if(m_INIfile.m_bDicomServerInstalled)
							{
								CString	csMesg;
								csMesg.Format(_T("%s\r\n%s"), GETMESSAGE(1798), GETMESSAGE(1794));

								CMessage::StartupMessage(WMFILELINE, 0, csMesg, true, true);

								m_INIfile.m_bDicomServerInstalled=FALSE;

								m_INIfile.PutConfig();
							}
						}
					}
					else
					{
						bSuccess = false;
					}
				}				
			}
			::CloseHandle(hFile);
		}
	}

	if(!bSuccess)
	{

		m_sLicense.arbOptions[WM_LICENSE_CATHMAP] = true;
			
		m_sLicense.arbOptions[WM_LICENSE_CARTO] = false;	
		
		if(m_INIfile.m_usMappingSystemInstalled==MAPPING_SYSTEM_CARTO)
		{
			CString	csMesg;
			csMesg.Format(	_T("%s\r\n%s"), 
									GETMESSAGE(1797), 
									GETMESSAGE(1794));

			CMessage::StartupMessage(WMFILELINE, 0, csMesg, true, true);

			m_INIfile.m_usMappingSystemInstalled=MAPPING_SYSTEM_NONE;

			m_INIfile.PutConfig();		
		}

		if(!m_sLicense.arbOptions[WM_LICENSE_DICOM])	
		{
			if(m_INIfile.m_bDicomServerInstalled)
			{
				CString	csMesg;
				csMesg.Format(	_T("%s\r\n%s"), 
									GETMESSAGE(1798), 
									GETMESSAGE(1794));

				CMessage::StartupMessage(WMFILELINE, 0, csMesg, true, true);

				m_INIfile.m_bDicomServerInstalled=FALSE;

				m_INIfile.PutConfig();
			}
		}

		if(bExists)
		{
			::SetFileAttributes(szFullPath, FILE_ATTRIBUTE_NORMAL);
		}

		ZEROSET(m_sLicense);
		::strncpy((PCHAR)m_sLicense.szAppName, 
						"WorkMate Claris", 
						ARRAY_SIZE(m_sLicense.szAppName));

		HANDLE hFile =::CreateFile(szFullPath, 
											GENERIC_READ|GENERIC_WRITE, 
											0, 
											NULL, 
											CREATE_ALWAYS, 
											FILE_ATTRIBUTE_NORMAL, 
											NULL);

		if((hFile==NULL) || 
			(hFile==INVALID_HANDLE_VALUE) )
		{
			return;
		}

		DWORD dwPos = ::SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

		SFileRecord<SLicense> sRecord = {0};

		sRecord.sData = m_sLicense;
		sRecord.ucCRC = ::CheckSum5((PUCHAR)&sRecord.sData, sizeof(sRecord.sData));

		DWORD dwWrite	=	sizeof(sRecord);
		DWORD dwWritten=	0;
		::WriteFile(hFile, (LPCVOID)&sRecord, dwWrite, &dwWritten, NULL);

		::CloseHandle(hFile);
	}

	::SetFileAttributes(szFullPath, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY);
}

void CWMApp::SetReportLogDirConfig(void)
{
	TCHAR szLogPath[MAX_PATH]={0};
	m_dLog.MakeLogName(szLogPath, sizeof(szLogPath));

	CRegistry::Instance()->SetString(_T("REPORTS\\CURLOGDIR"), szLogPath);
}

bool CWMApp::IsNMVersion(const uint32 uiMajor, const uint32 uiMinor, const uint32 uiRelease)
{
	/*return (	(m_sNMVersion.version[0]>=uiMajor)	&&
				(m_sNMVersion.version[1]>=uiMinor)	&&
				(m_sNMVersion.version[2]>=uiRelease));*/

	return (	(m_sNMVersion.version[0]>uiMajor) || 
				(m_sNMVersion.version[0]==uiMajor && m_sNMVersion.version[1]>uiMinor) || 
				(m_sNMVersion.version[0]==uiMajor && m_sNMVersion.version[1]==uiMinor && m_sNMVersion.version[2]>=uiRelease) );
}

void CWMApp::ResetPatientStudy(void)
{
	m_dLog.m_lCurrentLogDirNumber = 0;

	m_dPatient.m_Access.FreeRecord();
	m_dPatient.m_Access.InitRecord();
	
	m_dProcedure.m_Access.FreeRecord();
	m_dProcedure.m_Access.InitRecord();

	CMessage::ShowMessage(WMFILELINE, 1953);
}

void CWMApp::SetCurrentLogDirectoryNumber(void)
{
	m_dPatient.m_Access.InitRecord();

	long	current_log_dir_number = m_INIfile.m_lLogDirNumber;
	int	get_mode	=	GET_FIRST_RECN;

	// if this returns 0, its time to get out
	while( ( m_dPatient.GetMasterRecord(get_mode, LOCK_VIEW, 9999)) != DB_EOF ) 
	{
		get_mode=GET_NEXT_RECN; // if it is set to GET_FROM_OFFSET, recN is set to 0 on failure

		// sort through all procedures
		for(register short sort_recN=1; sort_recN<=m_dProcedure.m_Access.m_pList->total_recN; sort_recN++) 
		{
			m_dProcedure.m_Access.m_pList->temp_recN=sort_recN;
			m_dProcedure.m_Access.FreeRecord();
			m_dProcedure.m_Access.m_usRecordNumber=m_dProcedure.m_Access.m_pList->perm_recs[m_dProcedure.m_Access.m_pList->temp_recN];
			m_dProcedure.m_Access.GetRecord(GET_FROM_RECN, 0, 2642);

			if(m_dProcedure.m_Procedure.log_dir_number>current_log_dir_number)
			{
				current_log_dir_number = m_dProcedure.m_Procedure.log_dir_number;
			}
		}
	}

	m_dPatient.m_Access.FreeRecord();

	if((current_log_dir_number>m_INIfile.m_lLogDirNumber) && 
		(current_log_dir_number<0x7fffffff))
	{ 
		m_INIfile.m_lLogDirNumber = current_log_dir_number+1;

		// write this m_lLogDirNumber to the registry
		m_INIfile.PutLogDirectoryNumber();
				
		m_INIfile.m_lLastOpenedLogNumber =   m_INIfile.m_lLogDirNumber;
		m_INIfile.PutLastLogDirectoryNumber();
	}
}

bool CWMApp::GetLastRecord(const KDrugRecord& sKey, SDrugRecord& sRecord)
{
	memset(&sRecord, 0, sizeof(SDrugRecord));
	
	const UINT uiMaxRecords = m_tblDrugs.GetMaxRecords();
	
	if(uiMaxRecords<=0)
	{
		return false;
	}
	
	bool bFound = false;
	SDrugRecord sLastRecord={0};
	for(register UINT uiRecord=0; uiRecord<uiMaxRecords; ++uiRecord)
	{
		SDrugRecord sTempRecord={0};
		if(m_tblDrugs.GetRecord(uiRecord, sTempRecord))
		{
			if((_strnicmp((PCHAR)sKey.sPrimary.szName, (PCHAR)sTempRecord.szName, sizeof(sKey.sPrimary.szName))==0) &&
				(sKey.sPrimary.iType==sTempRecord.iType))
			{
				sLastRecord = sTempRecord;
				
				bFound = true;
			}
		}
	}
	
	if(bFound)
	{
		sRecord = sLastRecord;
	}
	
	return bFound;
}

bool CWMApp::IsDialogCreated(void) const 
{
	for(register int iIndex=0; iIndex<ARRAY_SIZE(m_mpDialogMap); ++iIndex)	
	{
		if(m_mpDialogMap[iIndex].bActive)	
		{
			return true;	
		}
	}
	
	return false;
}

void CWMApp::UpdateStudyState()
{
	// update the study state based on the current status
	SetMode(IsPassiveMode());
	m_dMapping->Reset();	// reset the MapMate, to notify of study changes
	SetStateControls();
}

void CWMApp::SetModeActive(bool considerTape/*=true*/)
{
	SetMode(false, considerTape);
}

void CWMApp::SetModePassive(bool considerTape/*=true*/)
{
	SetMode(true, considerTape);
}

void CWMApp::SetMode(bool bEditOnly, bool considerTape/*=true*/)
{
	// it has to be on the hard drive to continue a study otherwise you are in review mode
    m_bActiveMode = !bEditOnly                        && 
                    !m_INIfile.IsArchiveStudyLoaded() && 
                    // RLG 18-Oct-2012: The considerTape flag preserves pre-CL#80765 logic were 
                    // in 1 call site, CLOGDoc::OpenLogFiles(), the tape_name check was ignored
                    (!considerTape || 
                     !m_dProcedure.m_Procedure.tape_name[0]);
	
	if(m_INIfile.m_bNurseMateInstalled)
	{
		Transmit(WM2NM_SEND_STATE);
	}	
}

void CWMApp::SetStateControls(void)
{
	const bool bEnable = (IsActiveMode());
	
	if(bEnable)
	{
#ifndef PHILIPS_VIEWER	
		// try enabling the realtime signals
		m_bProcessData = true;
#else	
		m_bProcessData = false;		
#endif
		
		// enable auto record
		m_bDisableAutoRec = false;
		m_MainBar.m_chkAutoRecCtl.SetItemData(m_dCathMap.m_CathMap.iAutoRecordMode);
	}
	else
	{
		//CMessage::m_erLog.ReportError("Before SetStateControls()::m_MainBar.m_chkAutoRecCtl.SetItemData()");
		
		// disable auto record
		m_bDisableAutoRec = true;
		m_MainBar.m_chkAutoRecCtl.SetItemData(m_dCathMap.m_CathMap.iAutoRecordMode);

		m_MainBar.SetAutoRecButtonColor();
		
#ifndef PHILIPS_VIEWER
		// try enabling the realtime signals
		m_bProcessData = true;
#else	
		m_bProcessData = false;		
#endif
		
		// Close the following windows before disabling them, if open
		//CMessage::m_erLog.ReportError("Before SetStateControls()::CWMLibrary::IsWindowVisible(m_fMonitor)");
		if(CWMLibrary::IsWindowVisible(m_fMonitor))
		{
			m_MainBar.OnMonitorButton();
		}

#ifndef PHILIPS_VIEWER
		//CMessage::m_erLog.ReportError("Before SetStateControls()::m_Stim.IsActive()");
		if(m_Stim.IsActive())
		{
			m_MainBar.OnStimButton();
		}
		
		//CMessage::m_erLog.ReportError("Before SetStateControls()::IsCreated(IDD_CATHMAP_FORM)");
		if(IsCreated(IDD_CATHMAP_FORM))
		{
			SetCreated( m_fCathMap, IDD_CATHMAP_FORM, false );

			CWMLibrary::HandleClicks(m_fCathMap, eCathMap);

			m_MainBar.SetButtonColor(eCathMap);		
		}
#endif		
	}
	
	m_MainBar.m_btnDrugCtl.EnableWindow(bEnable);
	m_MainBar.m_chkAutoRecCtl.EnableWindow(bEnable);
	m_MainBar.m_btnStartRecCtl.EnableWindow(bEnable);

	if(CWMLibrary::IsSafeWindow(m_fChart))
	{
		if(CWMLibrary::IsSafeWindow(m_fChart->m_pChartDialogBar))
		{
			m_fChart->m_pChartDialogBar->UpdateControls(bEnable);
		}		
	}

	if(CWMLibrary::IsSafeWindow(m_vCine))
	{
		m_vCine->SetStateControls(bEnable);
	}
}

void CWMApp::NewSession(const bool bATMClear)
{
	//CMessage::m_erLog.ReportError("In NewSession()");

	if(m_vATMMap)
	{
		m_vATMMap->NewSession(bATMClear);
		m_vATMMap->InvalidateView();
	}

	//CMessage::m_erLog.ReportError("Before NewSession()::theApp.SetStateControls()");
	theApp.SetModeActive();
	theApp.SetStateControls();
	//CMessage::m_erLog.ReportError("After NewSession()::theApp.SetStateControls()");
}

void CWMApp::GetSession(void)
{
	if(m_vATMMap)
	{
		m_vATMMap->GetSession();
	}
}

void CWMApp::Beep(LPCTSTR szFile)
{
#ifndef PHILIPS_VIEWER
	m_SoundManager.Play(szFile);
#endif	
}

LPCTSTR CWMApp::MakeLockPath(LPCTSTR szLockName, PTCHAR szLock)
{
	if(szLock)
	{
		TCHAR szPath[MAX_PATH]={0};
		CWMLibrary::FindPath(theApp.m_INIfile.m_szLogDirName, 
									szPath, 
									sizeof(szPath));

		const int iLen = _tcslen(szPath);

		if((iLen>0)	&& 
			(szPath[iLen-1]=='\\'))
		{
			_stprintf(szLock, _T("%s%s"), szPath, szLockName);
		}
		else
		{
			_stprintf(szLock, _T("%s\\%s"), szPath, szLockName);
		}
	}

	return szLock;
}

bool CWMApp::IsLockAvailable(CFileLock& rLock, LPCTSTR szLockName, const bool bTry)
{
	bool bAvailable = false;
	if ( !m_INIfile.IsArchiveStudyLoaded() )
	{
		TCHAR szLock[MAX_PATH]={0};
		MakeLockPath(szLockName, szLock);
		
		if(rLock.Create(szLock))
		{			
			bAvailable = true;
			
			if(bTry)
			{
				bAvailable = (rLock.TryLock()!=INVALID_HANDLE_VALUE);
			}
		}
		else
		{
			bAvailable = false;
		}
	}
	else
	{
		bAvailable = true;
	}
	
	return bAvailable;
}

int CWMApp::GetRealTimeBarHeight(void)
{
	// Border of MainFrame, RealTimeChildBarFrame, RealTimeChildBarView 
	// and RealTimeChildFrame + Spacing(used a border)
	const int iBorder = 0; // GetSystemMetrics(SM_CYBORDER);

	const int iHeightMult = (m_INIfile.m_bShowBP2) ? 2 : 1;	

	const int offset = (m_INIfile.m_iRTTextSize > REALTIME_BAR_HEIGHT_MIN + 5) ? 2 : 1;
	
	return (m_INIfile.m_iRTTextSize<=REALTIME_BAR_HEIGHT_MIN) ? 
				((REALTIME_BAR_HEIGHT_MIN*iHeightMult)+iBorder - 2) : (((m_INIfile.m_iRTTextSize-offset)*2)+iBorder - 2); 
}

bool CWMApp::AddMappingNotes(void)
{
#ifndef PHILIPS_VIEWER		
	if(CWMLibrary::IsSafeWindow(m_vATMMap) && !IsCreated(IDD_DIALOG_MAP_NOTES) )
	{
		if( IsDialogsActive() )
		{
			return false;
		}

		// Should call local function to trigger button status update, I-3101
		if ( m_fMapping )
			m_fMapping->ShowNotesDialog();

		return true;
	}			
#endif			

	return false;
}


int CWMApp::ReadUpdateCrashLog(long log_dir_number)
{
	TCHAR szFullDirPath[MAX_PATH]={0}, szFullPath[MAX_PATH] = {0};
	CString csEventLog;
	
	_sntprintf( szFullDirPath, sizeof(szFullDirPath), _T("%s\\LOG_DHR%lu_%8.8lx"),
				theApp.m_INIfile.m_szLogDirName,				
				theApp.m_dLog.m_dwCurDHR,
				log_dir_number );

	_sntprintf(szFullPath, sizeof(szFullPath), _T("%s\\%s"), szFullDirPath, WM_CASE_CRASH_LOG_FILE_NAME);

	bool bExists = CFileDB::IsExists(szFullPath);
	bool bSuccess = bExists;

	if(bSuccess)
	{
		::SetFileAttributes(szFullPath, FILE_ATTRIBUTE_NORMAL);

		HANDLE hFile = ::CreateFile(szFullPath, 
											 GENERIC_READ|GENERIC_WRITE, 
											 0, 
											 NULL, 
											 OPEN_EXISTING, 
											 FILE_ATTRIBUTE_NORMAL, 
											 NULL);

		
		if((hFile!=NULL) && (hFile!=INVALID_HANDLE_VALUE))
		{
			TCHAR buffer[20000] = {0};
			CString inputFile;
			CFile recoverFile(hFile);

			SYSTEMTIME	sysTime={0}; ::GetLocalTime(&sysTime);

			UINT actualRead = recoverFile.Read((LPVOID)&buffer, sizeof(buffer));
						
			buffer[actualRead] = _T('\0');

			TCHAR *find = _tcsrchr(buffer,'=');

			if (find == NULL)
			{
				csEventLog.Format(_T("%s %d Unknown file format in Crash Tracker file. Crash logging failed, case %x"),WMFILELINE,log_dir_number);
				CMessage::m_erLog.ReportError(csEventLog); 
				::CloseHandle(hFile);
				return 0;
			}
			
			int lastOccur = 0;

			_stscanf(find+1,_T("%d"), &lastOccur);

			_sntprintf(buffer, sizeof(buffer),_T("\r\n[%.2d-%.2d-%.4d %.2d:%.2d:%.2d.%.3d] CNT=%d"),sysTime.wMonth, sysTime.wDay, 
				sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds, lastOccur+1);
	
			recoverFile.Seek(actualRead, CFile::begin);

			recoverFile.Write((LPVOID)&buffer, _tcslen(buffer));

			::CloseHandle(hFile);

		return lastOccur+1;
		
		}
		else
		{
			csEventLog.Format(_T("%s %d Crash logging failed. Failed to grab a handle for the file, case %x"),WMFILELINE,log_dir_number);
			CMessage::m_erLog.ReportError(csEventLog); 
			return 0;
		}
	}
	else	
	{
	
		HANDLE hFile = ::CreateFile(szFullPath, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

		if( (hFile==NULL) || (hFile==INVALID_HANDLE_VALUE) )
		{
			if(bExists)
			{
			::SetFileAttributes(szFullPath, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY);
			}
			
			csEventLog.Format(_T("%s %d Crash logging failed. Failed to grab a handle for the file, case %x"),WMFILELINE,log_dir_number);
			CMessage::m_erLog.ReportError(csEventLog);
			return 0;
		}

			TCHAR buffer[2000] = {0};
			CString append;

			SYSTEMTIME	sysTime={0}; ::GetLocalTime(&sysTime);
	
			
			_sntprintf(buffer, sizeof(buffer), _T("[%.2d-%.2d-%.4d %.2d:%.2d:%.2d.%.3d] CNT=%d"),sysTime.wMonth, sysTime.wDay, 
				sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds, 1);

			DWORD dwWrite	=	_tcslen(buffer);
			DWORD dwWritten=	0;
			::WriteFile(hFile, (LPCVOID)&buffer, dwWrite, &dwWritten, NULL);

			::CloseHandle(hFile);

		::SetFileAttributes(szFullPath, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY);

		return 1;
	}
}

void CWMApp::AssignNonDuplicateStudyDir()
{
	TCHAR szFullDirPath[MAX_PATH]={0};
	CString csEventLog;
	bool bSearch = true;

	do
	{

		_sntprintf( szFullDirPath, sizeof(szFullDirPath), _T("%s\\LOG_DHR%lu_%8.8lx"),
				theApp.m_INIfile.m_szLogDirName,				
				theApp.m_INIfile.m_dwDHR,
				theApp.m_INIfile.m_lLogDirNumber );

		//if duplicate exists, increment the LOG DIR #
		if (GetFileAttributes(szFullDirPath) != INVALID_FILE_ATTRIBUTES)
		{
			csEventLog.Format(_T("Log Dir with Case# already exists, increment the log dir number in INI. Duplicate case# %8.8lx") , theApp.m_INIfile.m_lLogDirNumber );
			CMessage::m_erLog.ReportError(csEventLog);
			
			theApp.m_INIfile.m_lLogDirNumber++;		
		}
		//If DIR is unique, write the LOG DIR # to INI
		else
		{
			theApp.m_INIfile.PutConfig();
			bSearch = false;
		}

	} while(bSearch);
}

void CWMApp::DisableAutoRec(bool disable)
{
	m_bDisableAutoRec = disable;
}

bool CWMApp::IsAutoRecDisable()
{
	return m_bDisableAutoRec;
}

CLibreOfficeImpress& CWMApp::LibreOfficeImpress()
{
	// Manage access here to the instance of the "Impress manager" class.
	static CLibreOfficeImpress instance(
		// Pass a lamba to act as a callback to consolidate logic of how to get 
		// the all important path to the powerpoint file for the current study.
		[this]()
		{
			CString pptStudyFileName;
			auto studyId = m_dProcedure.m_Procedure.log_dir_number;
			if (!m_bShellActive && studyId) // return an empty string when not in a study
			{
				pptStudyFileName.Format(_T("%s\\PPT_DHR%lu_000%x.ppt"),
					m_INIfile.m_szSlidePath,
					m_INIfile.m_dwDHR,
					studyId);
			}
			return pptStudyFileName;
		}
	);
	return instance;
}
